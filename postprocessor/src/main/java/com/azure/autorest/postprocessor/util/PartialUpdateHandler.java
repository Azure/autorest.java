package com.azure.autorest.postprocessor.util;

import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.BodyDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.expr.SimpleName;
import com.github.javaparser.ast.nodeTypes.NodeWithSimpleName;

import java.util.ArrayList;
import java.util.List;

import static com.github.javaparser.StaticJavaParser.parse;

/**
 * Partial update handler. It can handle partial update for .java class files.
 *
 * <p>Below partial update use cases are supported:
 *
 * <ul>
 * <li>Manually add class member (field / method / constructor) -> keep the added member
 * <li>Manually update method signature, e.g. parameter change, method access level change -> keep the manual changed signature, and not generate the corresponding method with the same method name
 * <li>Manually remove one class member -> if the member's definition is in swagger, this member will be auto generated again
 * <li>Swagger add a new api -> add the new api to generated file
 * <li>Swagger update an existing api -> if the api is auto generated, then the existing generated member will be replaced to the new one. If it is manual updated, we will keep the manual updated member.
 * <li>Swagger delete an existing api -> if the existing api is auto generated, then it should be removed. If it is manual updated, we will keep the manual updated member.
 * </ul>
 */
public class PartialUpdateHandler {

    /**
     * Handle partial update by comparing generatedFileContent and existingFileContent. When handling partial update for each file, it will compare existing file which has manual update and generated file which is generated by autorest. It keeps the manual update members and replace generated members with the newly generated one.
     *
     * <p>Handle partial update steps:
     * <ul>
     *  <li>Parse existing file content and generated file content using JavaParser
     *  <li>Get class members for existing file and generated file
     *  <li>Check if the file is in scope of partial update by iterate the members in generated file to see if there is a method has {@code @Generated} annotation. If it has {@code @Generated} annotation, then the file is in scope of partial update, otherwise return generated file content directly.
     *  <li>Iterate existing file members, keep manual updated members, and replace generated members with the corresponding newly generated one. Here we will not do the replace on the existing file member list,  we just create a new member list {@code updatedMembersList} and put in those manually update members and newly generated members.
     *  <li>Add remaining newly generated members to {@code updatedMembersList}
     *  <li>Update generated file members with {@code updatedMembersList}
     *  <li>Update generated file imports
     * </ul>
     *
     * @param generatedFileContent the newly generated file content
     * @param existingFileContent  the existing file content that contains user's manual update code
     * @return the file content after handling partial update
     */
    public static String handlePartialUpdateForFile(String generatedFileContent, String existingFileContent) {
        // 1. Parse existing file content and generated file content using JavaParser
        CompilationUnit compilationUnitForGeneratedFile = parse(generatedFileContent);
        CompilationUnit compilationUnitForExistingFile = parse(existingFileContent);
        ClassOrInterfaceDeclaration generatedClazz = getClassOrInterfaceDeclaration(compilationUnitForGeneratedFile);
        ClassOrInterfaceDeclaration existingClazz = getClassOrInterfaceDeclaration(compilationUnitForExistingFile);

        // 2. Get class members for existing file and generated file
        List<BodyDeclaration<?>> generatedFileMembers = new ArrayList<>();
        if (generatedClazz != null) {
            generatedFileMembers = generatedClazz.getMembers();
        }
        List<BodyDeclaration<?>> existingFileMembers = new ArrayList<>();
        if (existingClazz != null) {
            existingFileMembers = existingClazz.getMembers();
        }

        // 3. Check if the file is in scope of partial update:
        // if there is a method has @Generated annotation, then the file is in scope of partial update, otherwise return directly
        boolean hasGeneratedAnnotations = generatedFileMembers.stream().anyMatch(member -> hasGeneratedAnnotation(member));

        if (!hasGeneratedAnnotations) {
            return generatedFileContent;
        }

        NodeList<BodyDeclaration<?>> updatedMembersList = new NodeList<>();
        // 4. Iterate existingFileMembers, keep manual written members, and replace generated members with the corresponding newly generated one
        for (BodyDeclaration<?> existingMember : existingFileMembers) {
            boolean isGeneratedMethod = hasGeneratedAnnotation(existingMember);
            if (!isGeneratedMethod) { // manual written member
                updatedMembersList.add(existingMember);
            } else {
                // find the corresponding newly generated member
                for (BodyDeclaration<?> generatedMember : generatedFileMembers) {
                    if (isMembersCorresponding(existingMember, generatedMember)) {
                        updatedMembersList.add(generatedMember);
                    }
                }
            }
        }

        // 5. add remaining members in generated file to the new members list
        for (BodyDeclaration<?> generatedMember : generatedFileMembers) {
            boolean hasMembersWithSameName = false;
            for (BodyDeclaration<?> existingMember : updatedMembersList) {
                if (isMembersWithSameName(existingMember, generatedMember)) {
                    hasMembersWithSameName = true;
                }
            }
            if (!hasMembersWithSameName) {
                updatedMembersList.add(generatedMember);
            }
        }

        // 6. update members
        generatedClazz.setMembers(updatedMembersList);

        // 7. update imports
        compilationUnitForGeneratedFile.getImports().addAll(compilationUnitForExistingFile.getImports());

        return compilationUnitForGeneratedFile.toString();
    }

    private static boolean hasGeneratedAnnotation(BodyDeclaration<?> member) {
        if (member.getAnnotations() != null && member.getAnnotations().size() > 0) {
            return member.getAnnotations().stream().anyMatch(annotationExpr -> annotationExpr.getName().toString().equals("Generated"));
        } else {
            return false;
        }
    }

    private static boolean isMembersCorresponding(BodyDeclaration<?> member1, BodyDeclaration<?> member2) {
        if (member1.isCallableDeclaration() && member2.isCallableDeclaration()) {
            // compare signature
            if (member1.asCallableDeclaration().getSignature().equals(member2.asCallableDeclaration().getSignature())) {
                return true;
            }
        } else if (isMembersWithSameName(member1, member2)) {
            return true;
        }
        return false;
    }

    private static boolean isMembersWithSameName(BodyDeclaration<?> member1, BodyDeclaration<?> member2) {
        if (member1.isFieldDeclaration() && member2.isFieldDeclaration()) {
            return isFieldDeclarationWithSameName(member1, member2);
        } else if (member1.getMetaModel().equals(member2.getMetaModel()) &&
                member1 instanceof NodeWithSimpleName && member2 instanceof NodeWithSimpleName) {
            // compare name
            if (((NodeWithSimpleName) member2).getName().equals(((NodeWithSimpleName) member1).getName())) {
                return true;
            }
        }
        return false;
    }

    private static boolean isFieldDeclarationWithSameName(BodyDeclaration<?> member1, BodyDeclaration<?> member2) {
        if (member1.asFieldDeclaration().getVariables() != null &&
                member1.asFieldDeclaration().getVariables().size() > 0 &&
                member2.asFieldDeclaration().getVariables() != null &&
                member2.asFieldDeclaration().getVariables().size() > 0) {
            // for FieldDeclaration, currently make it simple, we only compare the first variable, if the first variable has the same name, then we consider they are field declarations with same name
            if (member1.asFieldDeclaration().getVariables().get(0).getName().equals(member2.asFieldDeclaration().getVariables().get(0).getName())) {
                return true;
            }
        }
        return false;
    }

    private static ClassOrInterfaceDeclaration getClassOrInterfaceDeclaration(CompilationUnit cu) {
        NodeList<TypeDeclaration<?>> types = cu.getTypes();
        if (types.size() == 1 && types.get(0).isClassOrInterfaceDeclaration()) {
            SimpleName className = types.get(0).getName();
            if (cu.getClassByName(className.asString()).isPresent()) {
                return cu.getClassByName(className.asString()).get();
            }
        }
        return null;
    }
}
