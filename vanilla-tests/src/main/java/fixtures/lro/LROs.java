// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package fixtures.lro;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.Put;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.ResponseBase;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.polling.ChainedPollingStrategy;
import com.azure.core.util.polling.DefaultPollingStrategy;
import com.azure.core.util.polling.LocationPollingStrategy;
import com.azure.core.util.polling.OperationResourcePollingStrategy;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.PollingStrategyOptions;
import com.azure.core.util.polling.StatusCheckPollingStrategy;
import com.azure.core.util.polling.SyncPoller;
import com.azure.core.util.serializer.TypeReference;
import fixtures.lro.models.CloudErrorException;
import fixtures.lro.models.LROsDelete202NoRetry204Headers;
import fixtures.lro.models.LROsDelete202Retry200Headers;
import fixtures.lro.models.LROsDeleteAsyncNoHeaderInRetryHeaders;
import fixtures.lro.models.LROsDeleteAsyncNoRetrySucceededHeaders;
import fixtures.lro.models.LROsDeleteAsyncRetrycanceledHeaders;
import fixtures.lro.models.LROsDeleteAsyncRetryFailedHeaders;
import fixtures.lro.models.LROsDeleteAsyncRetrySucceededHeaders;
import fixtures.lro.models.LROsDeleteNoHeaderInRetryHeaders;
import fixtures.lro.models.LROsDeleteProvisioning202Accepted200SucceededHeaders;
import fixtures.lro.models.LROsDeleteProvisioning202Deletingcanceled200Headers;
import fixtures.lro.models.LROsDeleteProvisioning202DeletingFailed200Headers;
import fixtures.lro.models.LROsPatch200SucceededIgnoreHeadersHeaders;
import fixtures.lro.models.LROsPatch201RetryWithAsyncHeaderHeaders;
import fixtures.lro.models.LROsPatch202RetryWithAsyncAndLocationHeaderHeaders;
import fixtures.lro.models.LROsPost202ListHeaders;
import fixtures.lro.models.LROsPost202NoRetry204Headers;
import fixtures.lro.models.LROsPost202Retry200Headers;
import fixtures.lro.models.LROsPostAsyncNoRetrySucceededHeaders;
import fixtures.lro.models.LROsPostAsyncRetrycanceledHeaders;
import fixtures.lro.models.LROsPostAsyncRetryFailedHeaders;
import fixtures.lro.models.LROsPostAsyncRetrySucceededHeaders;
import fixtures.lro.models.LROsPutAsyncNoHeaderInRetryHeaders;
import fixtures.lro.models.LROsPutAsyncNoRetrycanceledHeaders;
import fixtures.lro.models.LROsPutAsyncNoRetrySucceededHeaders;
import fixtures.lro.models.LROsPutAsyncRetryFailedHeaders;
import fixtures.lro.models.LROsPutAsyncRetrySucceededHeaders;
import fixtures.lro.models.LROsPutNoHeaderInRetryHeaders;
import fixtures.lro.models.Product;
import fixtures.lro.models.Sku;
import fixtures.lro.models.SubProduct;
import java.time.Duration;
import java.util.List;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in LROs.
 */
public final class LROs {
    /**
     * The proxy service used to perform REST calls.
     */
    private final LROsService service;

    /**
     * The service client containing this operation class.
     */
    private final AutoRestLongRunningOperationTestService client;

    /**
     * Initializes an instance of LROs.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    LROs(AutoRestLongRunningOperationTestService client) {
        this.service = RestProxy.create(LROsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for AutoRestLongRunningOperationTestServiceLROs to be used by the proxy
     * service to perform REST calls.
     */
    @Host("{$host}")
    @ServiceInterface(name = "AutoRestLongRunningO")
    public interface LROsService {
        @Put("/lro/put/200/succeeded")
        @ExpectedResponses({ 200, 204 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> put200Succeeded(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Patch("/lro/patch/200/succeeded/ignoreheaders")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPatch200SucceededIgnoreHeadersHeaders, Product>> patch200SucceededIgnoreHeaders(
            @HostParam("$host") String host, @BodyParam("application/json") Product product,
            @HeaderParam("Accept") String accept, Context context);

        @Patch("/lro/patch/200/succeeded/ignoreheaders")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> patch200SucceededIgnoreHeadersNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Patch("/lro/patch/201/retry/onlyAsyncHeader")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPatch201RetryWithAsyncHeaderHeaders, Product>> patch201RetryWithAsyncHeader(
            @HostParam("$host") String host, @BodyParam("application/json") Product product,
            @HeaderParam("Accept") String accept, Context context);

        @Patch("/lro/patch/201/retry/onlyAsyncHeader")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> patch201RetryWithAsyncHeaderNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Patch("/lro/patch/202/retry/asyncAndLocationHeader")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPatch202RetryWithAsyncAndLocationHeaderHeaders, Product>>
            patch202RetryWithAsyncAndLocationHeader(@HostParam("$host") String host,
                @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Patch("/lro/patch/202/retry/asyncAndLocationHeader")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> patch202RetryWithAsyncAndLocationHeaderNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/put/201/succeeded")
        @ExpectedResponses({ 201 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> put201Succeeded(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/list")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPost202ListHeaders, List<Product>>> post202List(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/list")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<List<Product>>> post202ListNoCustomHeaders(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/put/200/succeeded/nostate")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> put200SucceededNoState(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/put/202/retry/200")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> put202Retry200(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/put/201/creating/succeeded/200")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> put201CreatingSucceeded200(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/put/200/updating/succeeded/200")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> put200UpdatingSucceeded204(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/put/201/created/failed/200")
        @ExpectedResponses({ 200, 201 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> put201CreatingFailed200(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/put/200/accepted/canceled/200")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> put200Acceptedcanceled200(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/put/noheader/202/200")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPutNoHeaderInRetryHeaders, Product>> putNoHeaderInRetry(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/put/noheader/202/200")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> putNoHeaderInRetryNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putasync/retry/succeeded")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPutAsyncRetrySucceededHeaders, Product>> putAsyncRetrySucceeded(
            @HostParam("$host") String host, @BodyParam("application/json") Product product,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putasync/retry/succeeded")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> putAsyncRetrySucceededNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putasync/noretry/succeeded")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPutAsyncNoRetrySucceededHeaders, Product>> putAsyncNoRetrySucceeded(
            @HostParam("$host") String host, @BodyParam("application/json") Product product,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putasync/noretry/succeeded")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> putAsyncNoRetrySucceededNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putasync/retry/failed")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPutAsyncRetryFailedHeaders, Product>> putAsyncRetryFailed(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putasync/retry/failed")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> putAsyncRetryFailedNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putasync/noretry/canceled")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPutAsyncNoRetrycanceledHeaders, Product>> putAsyncNoRetrycanceled(
            @HostParam("$host") String host, @BodyParam("application/json") Product product,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putasync/noretry/canceled")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> putAsyncNoRetrycanceledNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putasync/noheader/201/200")
        @ExpectedResponses({ 201 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPutAsyncNoHeaderInRetryHeaders, Product>> putAsyncNoHeaderInRetry(
            @HostParam("$host") String host, @BodyParam("application/json") Product product,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putasync/noheader/201/200")
        @ExpectedResponses({ 201 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> putAsyncNoHeaderInRetryNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putnonresource/202/200")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Sku>> putNonResource(@HostParam("$host") String host, @BodyParam("application/json") Sku sku,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putnonresourceasync/202/200")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Sku>> putAsyncNonResource(@HostParam("$host") String host, @BodyParam("application/json") Sku sku,
            @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putsubresource/202/200")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<SubProduct>> putSubResource(@HostParam("$host") String host,
            @BodyParam("application/json") SubProduct product, @HeaderParam("Accept") String accept, Context context);

        @Put("/lro/putsubresourceasync/202/200")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<SubProduct>> putAsyncSubResource(@HostParam("$host") String host,
            @BodyParam("application/json") SubProduct product, @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/provisioning/202/accepted/200/succeeded")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsDeleteProvisioning202Accepted200SucceededHeaders, Product>>
            deleteProvisioning202Accepted200Succeeded(@HostParam("$host") String host,
                @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/provisioning/202/accepted/200/succeeded")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> deleteProvisioning202Accepted200SucceededNoCustomHeaders(
            @HostParam("$host") String host, @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/provisioning/202/deleting/200/failed")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsDeleteProvisioning202DeletingFailed200Headers, Product>>
            deleteProvisioning202DeletingFailed200(@HostParam("$host") String host,
                @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/provisioning/202/deleting/200/failed")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> deleteProvisioning202DeletingFailed200NoCustomHeaders(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/provisioning/202/deleting/200/canceled")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsDeleteProvisioning202Deletingcanceled200Headers, Product>>
            deleteProvisioning202Deletingcanceled200(@HostParam("$host") String host,
                @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/provisioning/202/deleting/200/canceled")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> deleteProvisioning202Deletingcanceled200NoCustomHeaders(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/204/succeeded")
        @ExpectedResponses({ 204 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Void>> delete204Succeeded(@HostParam("$host") String host, @HeaderParam("Accept") String accept,
            Context context);

        @Delete("/lro/delete/202/retry/200")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsDelete202Retry200Headers, Product>> delete202Retry200(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/202/retry/200")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> delete202Retry200NoCustomHeaders(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/202/noretry/204")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsDelete202NoRetry204Headers, Product>> delete202NoRetry204(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/202/noretry/204")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> delete202NoRetry204NoCustomHeaders(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/noheader")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsDeleteNoHeaderInRetryHeaders, Void>> deleteNoHeaderInRetry(
            @HostParam("$host") String host, @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/delete/noheader")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Void>> deleteNoHeaderInRetryNoCustomHeaders(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/deleteasync/noheader/202/204")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsDeleteAsyncNoHeaderInRetryHeaders, Void>> deleteAsyncNoHeaderInRetry(
            @HostParam("$host") String host, @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/deleteasync/noheader/202/204")
        @ExpectedResponses({ 202, 204 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Void>> deleteAsyncNoHeaderInRetryNoCustomHeaders(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/deleteasync/retry/succeeded")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsDeleteAsyncRetrySucceededHeaders, Void>> deleteAsyncRetrySucceeded(
            @HostParam("$host") String host, @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/deleteasync/retry/succeeded")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Void>> deleteAsyncRetrySucceededNoCustomHeaders(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/deleteasync/noretry/succeeded")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsDeleteAsyncNoRetrySucceededHeaders, Void>> deleteAsyncNoRetrySucceeded(
            @HostParam("$host") String host, @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/deleteasync/noretry/succeeded")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Void>> deleteAsyncNoRetrySucceededNoCustomHeaders(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/deleteasync/retry/failed")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsDeleteAsyncRetryFailedHeaders, Void>> deleteAsyncRetryFailed(
            @HostParam("$host") String host, @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/deleteasync/retry/failed")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Void>> deleteAsyncRetryFailedNoCustomHeaders(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/deleteasync/retry/canceled")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsDeleteAsyncRetrycanceledHeaders, Void>> deleteAsyncRetrycanceled(
            @HostParam("$host") String host, @HeaderParam("Accept") String accept, Context context);

        @Delete("/lro/deleteasync/retry/canceled")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Void>> deleteAsyncRetrycanceledNoCustomHeaders(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/post/payload/200")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Sku>> post200WithPayload(@HostParam("$host") String host, @HeaderParam("Accept") String accept,
            Context context);

        @Post("/lro/post/202/retry/200")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPost202Retry200Headers, Void>> post202Retry200(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/post/202/retry/200")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Void>> post202Retry200NoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/post/202/noretry/204")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPost202NoRetry204Headers, Product>> post202NoRetry204(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/post/202/noretry/204")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> post202NoRetry204NoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/LROPostDoubleHeadersFinalLocationGet")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> postDoubleHeadersFinalLocationGet(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/LROPostDoubleHeadersFinalAzureHeaderGet")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> postDoubleHeadersFinalAzureHeaderGet(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/LROPostDoubleHeadersFinalAzureHeaderGetDefault")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> postDoubleHeadersFinalAzureHeaderGetDefault(@HostParam("$host") String host,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/postasync/retry/succeeded")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPostAsyncRetrySucceededHeaders, Product>> postAsyncRetrySucceeded(
            @HostParam("$host") String host, @BodyParam("application/json") Product product,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/postasync/retry/succeeded")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> postAsyncRetrySucceededNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/postasync/noretry/succeeded")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPostAsyncNoRetrySucceededHeaders, Product>> postAsyncNoRetrySucceeded(
            @HostParam("$host") String host, @BodyParam("application/json") Product product,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/postasync/noretry/succeeded")
        @ExpectedResponses({ 200, 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Product>> postAsyncNoRetrySucceededNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/postasync/retry/failed")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPostAsyncRetryFailedHeaders, Void>> postAsyncRetryFailed(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/postasync/retry/failed")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Void>> postAsyncRetryFailedNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/postasync/retry/canceled")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<ResponseBase<LROsPostAsyncRetrycanceledHeaders, Void>> postAsyncRetrycanceled(
            @HostParam("$host") String host, @BodyParam("application/json") Product product,
            @HeaderParam("Accept") String accept, Context context);

        @Post("/lro/postasync/retry/canceled")
        @ExpectedResponses({ 202 })
        @UnexpectedResponseExceptionType(CloudErrorException.class)
        Mono<Response<Void>> postAsyncRetrycanceledNoCustomHeaders(@HostParam("$host") String host,
            @BodyParam("application/json") Product product, @HeaderParam("Accept") String accept, Context context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put200SucceededWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> put200SucceededWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put200SucceededWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.put200Succeeded(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200SucceededAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put200SucceededWithResponseAsync(product),
            new ChainedPollingStrategy<>(java.util.Arrays.asList(
                new OperationResourcePollingStrategy<>(this.client.getHttpPipeline(), null, "Azure-AsyncOperation",
                    Context.NONE),
                new LocationPollingStrategy<>(this.client.getHttpPipeline(), null, Context.NONE),
                new StatusCheckPollingStrategy<>())),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200SucceededAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put200SucceededWithResponseAsync(product),
            new ChainedPollingStrategy<>(java.util.Arrays.asList(
                new OperationResourcePollingStrategy<>(this.client.getHttpPipeline(), null, "Azure-AsyncOperation",
                    Context.NONE),
                new LocationPollingStrategy<>(this.client.getHttpPipeline(), null, Context.NONE),
                new StatusCheckPollingStrategy<>())),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200SucceededAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put200SucceededWithResponseAsync(product, context),
            new ChainedPollingStrategy<>(java.util.Arrays.asList(
                new OperationResourcePollingStrategy<>(this.client.getHttpPipeline(), null, "Azure-AsyncOperation",
                    context),
                new LocationPollingStrategy<>(this.client.getHttpPipeline(), null, context),
                new StatusCheckPollingStrategy<>())),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200Succeeded(Product product) {
        return this.beginPut200SucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200Succeeded() {
        final Product product = null;
        return this.beginPut200SucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200Succeeded(Product product, Context context) {
        return this.beginPut200SucceededAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPatch200SucceededIgnoreHeadersHeaders, Product>>
        patch200SucceededIgnoreHeadersWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> patch200SucceededIgnoreHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPatch200SucceededIgnoreHeadersHeaders, Product>>
        patch200SucceededIgnoreHeadersWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.patch200SucceededIgnoreHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch200SucceededIgnoreHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch200SucceededIgnoreHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch200SucceededIgnoreHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch200SucceededIgnoreHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch200SucceededIgnoreHeadersAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch200SucceededIgnoreHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch200SucceededIgnoreHeaders(Product product) {
        return this.beginPatch200SucceededIgnoreHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch200SucceededIgnoreHeaders() {
        final Product product = null;
        return this.beginPatch200SucceededIgnoreHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch200SucceededIgnoreHeaders(Product product, Context context) {
        return this.beginPatch200SucceededIgnoreHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> patch200SucceededIgnoreHeadersNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil
            .withContext(context -> patch200SucceededIgnoreHeadersNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> patch200SucceededIgnoreHeadersNoCustomHeadersWithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.patch200SucceededIgnoreHeadersNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch200SucceededIgnoreHeadersNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch200SucceededIgnoreHeadersNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch200SucceededIgnoreHeadersNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch200SucceededIgnoreHeadersNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch200SucceededIgnoreHeadersNoCustomHeadersAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch200SucceededIgnoreHeadersNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch200SucceededIgnoreHeadersNoCustomHeaders(Product product) {
        return this.beginPatch200SucceededIgnoreHeadersNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch200SucceededIgnoreHeadersNoCustomHeaders() {
        final Product product = null;
        return this.beginPatch200SucceededIgnoreHeadersNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request with location header. We should not have
     * any subsequent calls after receiving this first response.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch200SucceededIgnoreHeadersNoCustomHeaders(Product product,
        Context context) {
        return this.beginPatch200SucceededIgnoreHeadersNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPatch201RetryWithAsyncHeaderHeaders, Product>>
        patch201RetryWithAsyncHeaderWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> patch201RetryWithAsyncHeaderWithResponseAsync(product, context));
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPatch201RetryWithAsyncHeaderHeaders, Product>>
        patch201RetryWithAsyncHeaderWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.patch201RetryWithAsyncHeader(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch201RetryWithAsyncHeaderAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch201RetryWithAsyncHeaderWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch201RetryWithAsyncHeaderAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch201RetryWithAsyncHeaderWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch201RetryWithAsyncHeaderAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch201RetryWithAsyncHeaderWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch201RetryWithAsyncHeader(Product product) {
        return this.beginPatch201RetryWithAsyncHeaderAsync(product).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch201RetryWithAsyncHeader() {
        final Product product = null;
        return this.beginPatch201RetryWithAsyncHeaderAsync(product).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch201RetryWithAsyncHeader(Product product, Context context) {
        return this.beginPatch201RetryWithAsyncHeaderAsync(product, context).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> patch201RetryWithAsyncHeaderNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil
            .withContext(context -> patch201RetryWithAsyncHeaderNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> patch201RetryWithAsyncHeaderNoCustomHeadersWithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.patch201RetryWithAsyncHeaderNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch201RetryWithAsyncHeaderNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch201RetryWithAsyncHeaderNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch201RetryWithAsyncHeaderNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch201RetryWithAsyncHeaderNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch201RetryWithAsyncHeaderNoCustomHeadersAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch201RetryWithAsyncHeaderNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch201RetryWithAsyncHeaderNoCustomHeaders(Product product) {
        return this.beginPatch201RetryWithAsyncHeaderNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch201RetryWithAsyncHeaderNoCustomHeaders() {
        final Product product = null;
        return this.beginPatch201RetryWithAsyncHeaderNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 201 to the initial request with async header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch201RetryWithAsyncHeaderNoCustomHeaders(Product product,
        Context context) {
        return this.beginPatch201RetryWithAsyncHeaderNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPatch202RetryWithAsyncAndLocationHeaderHeaders, Product>>
        patch202RetryWithAsyncAndLocationHeaderWithResponseAsync(Product product) {
        return FluxUtil
            .withContext(context -> patch202RetryWithAsyncAndLocationHeaderWithResponseAsync(product, context));
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPatch202RetryWithAsyncAndLocationHeaderHeaders, Product>>
        patch202RetryWithAsyncAndLocationHeaderWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.patch202RetryWithAsyncAndLocationHeader(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch202RetryWithAsyncAndLocationHeaderAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch202RetryWithAsyncAndLocationHeaderWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch202RetryWithAsyncAndLocationHeaderAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch202RetryWithAsyncAndLocationHeaderWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch202RetryWithAsyncAndLocationHeaderAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch202RetryWithAsyncAndLocationHeaderWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch202RetryWithAsyncAndLocationHeader(Product product) {
        return this.beginPatch202RetryWithAsyncAndLocationHeaderAsync(product).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch202RetryWithAsyncAndLocationHeader() {
        final Product product = null;
        return this.beginPatch202RetryWithAsyncAndLocationHeaderAsync(product).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch202RetryWithAsyncAndLocationHeader(Product product, Context context) {
        return this.beginPatch202RetryWithAsyncAndLocationHeaderAsync(product, context).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>>
        patch202RetryWithAsyncAndLocationHeaderNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil.withContext(
            context -> patch202RetryWithAsyncAndLocationHeaderNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>>
        patch202RetryWithAsyncAndLocationHeaderNoCustomHeadersWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.patch202RetryWithAsyncAndLocationHeaderNoCustomHeaders(this.client.getHost(), product, accept,
            context);
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product>
        beginPatch202RetryWithAsyncAndLocationHeaderNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch202RetryWithAsyncAndLocationHeaderNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPatch202RetryWithAsyncAndLocationHeaderNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch202RetryWithAsyncAndLocationHeaderNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product>
        beginPatch202RetryWithAsyncAndLocationHeaderNoCustomHeadersAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.patch202RetryWithAsyncAndLocationHeaderNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch202RetryWithAsyncAndLocationHeaderNoCustomHeaders(Product product) {
        return this.beginPatch202RetryWithAsyncAndLocationHeaderNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch202RetryWithAsyncAndLocationHeaderNoCustomHeaders() {
        final Product product = null;
        return this.beginPatch202RetryWithAsyncAndLocationHeaderNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running patch request, service returns a 202 to the initial request with async and location header.
     * 
     * @param product Product to patch.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPatch202RetryWithAsyncAndLocationHeaderNoCustomHeaders(Product product,
        Context context) {
        return this.beginPatch202RetryWithAsyncAndLocationHeaderNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put201SucceededWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> put201SucceededWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put201SucceededWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.put201Succeeded(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut201SucceededAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put201SucceededWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut201SucceededAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put201SucceededWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut201SucceededAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put201SucceededWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut201Succeeded(Product product) {
        return this.beginPut201SucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut201Succeeded() {
        final Product product = null;
        return this.beginPut201SucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut201Succeeded(Product product, Context context) {
        return this.beginPut201SucceededAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return array of Product along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPost202ListHeaders, List<Product>>> post202ListWithResponseAsync() {
        return FluxUtil.withContext(context -> post202ListWithResponseAsync(context));
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return array of Product along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPost202ListHeaders, List<Product>>> post202ListWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.post202List(this.client.getHost(), accept, context);
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of array of Product.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<List<Product>, List<Product>> beginPost202ListAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post202ListWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TYPE_REFERENCE_LIST_PRODUCT, TYPE_REFERENCE_LIST_PRODUCT);
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of array of Product.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<List<Product>, List<Product>> beginPost202ListAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post202ListWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TYPE_REFERENCE_LIST_PRODUCT, TYPE_REFERENCE_LIST_PRODUCT);
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of array of Product.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<List<Product>, List<Product>> beginPost202List() {
        return this.beginPost202ListAsync().getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of array of Product.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<List<Product>, List<Product>> beginPost202List(Context context) {
        return this.beginPost202ListAsync(context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return array of Product along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<List<Product>>> post202ListNoCustomHeadersWithResponseAsync() {
        return FluxUtil.withContext(context -> post202ListNoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return array of Product along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<List<Product>>> post202ListNoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.post202ListNoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of array of Product.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<List<Product>, List<Product>> beginPost202ListNoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post202ListNoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TYPE_REFERENCE_LIST_PRODUCT, TYPE_REFERENCE_LIST_PRODUCT);
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of array of Product.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<List<Product>, List<Product>> beginPost202ListNoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post202ListNoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TYPE_REFERENCE_LIST_PRODUCT, TYPE_REFERENCE_LIST_PRODUCT);
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of array of Product.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<List<Product>, List<Product>> beginPost202ListNoCustomHeaders() {
        return this.beginPost202ListNoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 with empty body to first request, returns a 200 with body [{
     * 'id': '100', 'name': 'foo' }].
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of array of Product.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<List<Product>, List<Product>> beginPost202ListNoCustomHeaders(Context context) {
        return this.beginPost202ListNoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put200SucceededNoStateWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> put200SucceededNoStateWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put200SucceededNoStateWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.put200SucceededNoState(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200SucceededNoStateAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put200SucceededNoStateWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200SucceededNoStateAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put200SucceededNoStateWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200SucceededNoStateAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.put200SucceededNoStateWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200SucceededNoState(Product product) {
        return this.beginPut200SucceededNoStateAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200SucceededNoState() {
        final Product product = null;
        return this.beginPut200SucceededNoStateAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200SucceededNoState(Product product, Context context) {
        return this.beginPut200SucceededNoStateAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a
     * polling URL that returns a 200 and an entity that doesn't contains ProvisioningState.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put202Retry200WithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> put202Retry200WithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a
     * polling URL that returns a 200 and an entity that doesn't contains ProvisioningState.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put202Retry200WithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.put202Retry200(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a
     * polling URL that returns a 200 and an entity that doesn't contains ProvisioningState.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut202Retry200Async(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put202Retry200WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a
     * polling URL that returns a 200 and an entity that doesn't contains ProvisioningState.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut202Retry200Async() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put202Retry200WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a
     * polling URL that returns a 200 and an entity that doesn't contains ProvisioningState.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut202Retry200Async(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put202Retry200WithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a
     * polling URL that returns a 200 and an entity that doesn't contains ProvisioningState.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut202Retry200(Product product) {
        return this.beginPut202Retry200Async(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a
     * polling URL that returns a 200 and an entity that doesn't contains ProvisioningState.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut202Retry200() {
        final Product product = null;
        return this.beginPut202Retry200Async(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a
     * polling URL that returns a 200 and an entity that doesn't contains ProvisioningState.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut202Retry200(Product product, Context context) {
        return this.beginPut202Retry200Async(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put201CreatingSucceeded200WithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> put201CreatingSucceeded200WithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put201CreatingSucceeded200WithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.put201CreatingSucceeded200(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut201CreatingSucceeded200Async(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put201CreatingSucceeded200WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut201CreatingSucceeded200Async() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put201CreatingSucceeded200WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut201CreatingSucceeded200Async(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.put201CreatingSucceeded200WithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut201CreatingSucceeded200(Product product) {
        return this.beginPut201CreatingSucceeded200Async(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut201CreatingSucceeded200() {
        final Product product = null;
        return this.beginPut201CreatingSucceeded200Async(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut201CreatingSucceeded200(Product product, Context context) {
        return this.beginPut201CreatingSucceeded200Async(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put200UpdatingSucceeded204WithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> put200UpdatingSucceeded204WithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put200UpdatingSucceeded204WithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.put200UpdatingSucceeded204(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200UpdatingSucceeded204Async(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put200UpdatingSucceeded204WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200UpdatingSucceeded204Async() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put200UpdatingSucceeded204WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200UpdatingSucceeded204Async(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.put200UpdatingSucceeded204WithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200UpdatingSucceeded204(Product product) {
        return this.beginPut200UpdatingSucceeded204Async(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200UpdatingSucceeded204() {
        final Product product = null;
        return this.beginPut200UpdatingSucceeded204Async(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Updating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200UpdatingSucceeded204(Product product, Context context) {
        return this.beginPut200UpdatingSucceeded204Async(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put201CreatingFailed200WithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> put201CreatingFailed200WithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put201CreatingFailed200WithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.put201CreatingFailed200(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut201CreatingFailed200Async(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put201CreatingFailed200WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut201CreatingFailed200Async() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put201CreatingFailed200WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut201CreatingFailed200Async(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.put201CreatingFailed200WithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut201CreatingFailed200(Product product) {
        return this.beginPut201CreatingFailed200Async(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut201CreatingFailed200() {
        final Product product = null;
        return this.beginPut201CreatingFailed200Async(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Created’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut201CreatingFailed200(Product product, Context context) {
        return this.beginPut201CreatingFailed200Async(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put200Acceptedcanceled200WithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> put200Acceptedcanceled200WithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> put200Acceptedcanceled200WithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.put200Acceptedcanceled200(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200Acceptedcanceled200Async(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put200Acceptedcanceled200WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200Acceptedcanceled200Async() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.put200Acceptedcanceled200WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPut200Acceptedcanceled200Async(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.put200Acceptedcanceled200WithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200Acceptedcanceled200(Product product) {
        return this.beginPut200Acceptedcanceled200Async(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200Acceptedcanceled200() {
        final Product product = null;
        return this.beginPut200Acceptedcanceled200Async(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPut200Acceptedcanceled200(Product product, Context context) {
        return this.beginPut200Acceptedcanceled200Async(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutNoHeaderInRetryHeaders, Product>>
        putNoHeaderInRetryWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> putNoHeaderInRetryWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutNoHeaderInRetryHeaders, Product>>
        putNoHeaderInRetryWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putNoHeaderInRetry(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutNoHeaderInRetryAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putNoHeaderInRetryWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutNoHeaderInRetryAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putNoHeaderInRetryWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutNoHeaderInRetryAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putNoHeaderInRetryWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutNoHeaderInRetry(Product product) {
        return this.beginPutNoHeaderInRetryAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutNoHeaderInRetry() {
        final Product product = null;
        return this.beginPutNoHeaderInRetryAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutNoHeaderInRetry(Product product, Context context) {
        return this.beginPutNoHeaderInRetryAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putNoHeaderInRetryNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> putNoHeaderInRetryNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putNoHeaderInRetryNoCustomHeadersWithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putNoHeaderInRetryNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutNoHeaderInRetryNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putNoHeaderInRetryNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutNoHeaderInRetryNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putNoHeaderInRetryNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutNoHeaderInRetryNoCustomHeadersAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putNoHeaderInRetryNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutNoHeaderInRetryNoCustomHeaders(Product product) {
        return this.beginPutNoHeaderInRetryNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutNoHeaderInRetryNoCustomHeaders() {
        final Product product = null;
        return this.beginPutNoHeaderInRetryNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutNoHeaderInRetryNoCustomHeaders(Product product, Context context) {
        return this.beginPutNoHeaderInRetryNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutAsyncRetrySucceededHeaders, Product>>
        putAsyncRetrySucceededWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> putAsyncRetrySucceededWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutAsyncRetrySucceededHeaders, Product>>
        putAsyncRetrySucceededWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putAsyncRetrySucceeded(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetrySucceededAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncRetrySucceededWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetrySucceededAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncRetrySucceededWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetrySucceededAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncRetrySucceededWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetrySucceeded(Product product) {
        return this.beginPutAsyncRetrySucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetrySucceeded() {
        final Product product = null;
        return this.beginPutAsyncRetrySucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetrySucceeded(Product product, Context context) {
        return this.beginPutAsyncRetrySucceededAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putAsyncRetrySucceededNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil
            .withContext(context -> putAsyncRetrySucceededNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putAsyncRetrySucceededNoCustomHeadersWithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putAsyncRetrySucceededNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetrySucceededNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncRetrySucceededNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetrySucceededNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncRetrySucceededNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetrySucceededNoCustomHeadersAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncRetrySucceededNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetrySucceededNoCustomHeaders(Product product) {
        return this.beginPutAsyncRetrySucceededNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetrySucceededNoCustomHeaders() {
        final Product product = null;
        return this.beginPutAsyncRetrySucceededNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetrySucceededNoCustomHeaders(Product product, Context context) {
        return this.beginPutAsyncRetrySucceededNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutAsyncNoRetrySucceededHeaders, Product>>
        putAsyncNoRetrySucceededWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> putAsyncNoRetrySucceededWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutAsyncNoRetrySucceededHeaders, Product>>
        putAsyncNoRetrySucceededWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putAsyncNoRetrySucceeded(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrySucceededAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncNoRetrySucceededWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrySucceededAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncNoRetrySucceededWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrySucceededAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoRetrySucceededWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrySucceeded(Product product) {
        return this.beginPutAsyncNoRetrySucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrySucceeded() {
        final Product product = null;
        return this.beginPutAsyncNoRetrySucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrySucceeded(Product product, Context context) {
        return this.beginPutAsyncNoRetrySucceededAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil
            .withContext(context -> putAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putAsyncNoRetrySucceededNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrySucceededNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrySucceededNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrySucceededNoCustomHeadersAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrySucceededNoCustomHeaders(Product product) {
        return this.beginPutAsyncNoRetrySucceededNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrySucceededNoCustomHeaders() {
        final Product product = null;
        return this.beginPutAsyncNoRetrySucceededNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrySucceededNoCustomHeaders(Product product, Context context) {
        return this.beginPutAsyncNoRetrySucceededNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutAsyncRetryFailedHeaders, Product>>
        putAsyncRetryFailedWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> putAsyncRetryFailedWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutAsyncRetryFailedHeaders, Product>>
        putAsyncRetryFailedWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putAsyncRetryFailed(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetryFailedAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncRetryFailedWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetryFailedAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncRetryFailedWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetryFailedAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncRetryFailedWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetryFailed(Product product) {
        return this.beginPutAsyncRetryFailedAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetryFailed() {
        final Product product = null;
        return this.beginPutAsyncRetryFailedAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetryFailed(Product product, Context context) {
        return this.beginPutAsyncRetryFailedAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putAsyncRetryFailedNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> putAsyncRetryFailedNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putAsyncRetryFailedNoCustomHeadersWithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putAsyncRetryFailedNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetryFailedNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncRetryFailedNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetryFailedNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncRetryFailedNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncRetryFailedNoCustomHeadersAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncRetryFailedNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetryFailedNoCustomHeaders(Product product) {
        return this.beginPutAsyncRetryFailedNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetryFailedNoCustomHeaders() {
        final Product product = null;
        return this.beginPutAsyncRetryFailedNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncRetryFailedNoCustomHeaders(Product product, Context context) {
        return this.beginPutAsyncRetryFailedNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutAsyncNoRetrycanceledHeaders, Product>>
        putAsyncNoRetrycanceledWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> putAsyncNoRetrycanceledWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutAsyncNoRetrycanceledHeaders, Product>>
        putAsyncNoRetrycanceledWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putAsyncNoRetrycanceled(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrycanceledAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncNoRetrycanceledWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrycanceledAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncNoRetrycanceledWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrycanceledAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoRetrycanceledWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrycanceled(Product product) {
        return this.beginPutAsyncNoRetrycanceledAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrycanceled() {
        final Product product = null;
        return this.beginPutAsyncNoRetrycanceledAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrycanceled(Product product, Context context) {
        return this.beginPutAsyncNoRetrycanceledAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putAsyncNoRetrycanceledNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil
            .withContext(context -> putAsyncNoRetrycanceledNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putAsyncNoRetrycanceledNoCustomHeadersWithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putAsyncNoRetrycanceledNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrycanceledNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoRetrycanceledNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrycanceledNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoRetrycanceledNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoRetrycanceledNoCustomHeadersAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoRetrycanceledNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrycanceledNoCustomHeaders(Product product) {
        return this.beginPutAsyncNoRetrycanceledNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrycanceledNoCustomHeaders() {
        final Product product = null;
        return this.beginPutAsyncNoRetrycanceledNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoRetrycanceledNoCustomHeaders(Product product, Context context) {
        return this.beginPutAsyncNoRetrycanceledNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutAsyncNoHeaderInRetryHeaders, Product>>
        putAsyncNoHeaderInRetryWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> putAsyncNoHeaderInRetryWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPutAsyncNoHeaderInRetryHeaders, Product>>
        putAsyncNoHeaderInRetryWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putAsyncNoHeaderInRetry(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoHeaderInRetryAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncNoHeaderInRetryWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoHeaderInRetryAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncNoHeaderInRetryWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoHeaderInRetryAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoHeaderInRetryWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoHeaderInRetry(Product product) {
        return this.beginPutAsyncNoHeaderInRetryAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoHeaderInRetry() {
        final Product product = null;
        return this.beginPutAsyncNoHeaderInRetryAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoHeaderInRetry(Product product, Context context) {
        return this.beginPutAsyncNoHeaderInRetryAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putAsyncNoHeaderInRetryNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil
            .withContext(context -> putAsyncNoHeaderInRetryNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> putAsyncNoHeaderInRetryNoCustomHeadersWithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putAsyncNoHeaderInRetryNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoHeaderInRetryNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoHeaderInRetryNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoHeaderInRetryNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoHeaderInRetryNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPutAsyncNoHeaderInRetryNoCustomHeadersAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncNoHeaderInRetryNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoHeaderInRetryNoCustomHeaders(Product product) {
        return this.beginPutAsyncNoHeaderInRetryNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoHeaderInRetryNoCustomHeaders() {
        final Product product = null;
        return this.beginPutAsyncNoHeaderInRetryNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header.
     * Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPutAsyncNoHeaderInRetryNoCustomHeaders(Product product, Context context) {
        return this.beginPutAsyncNoHeaderInRetryNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku sku to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Sku>> putNonResourceWithResponseAsync(Sku sku) {
        return FluxUtil.withContext(context -> putNonResourceWithResponseAsync(sku, context));
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku sku to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Sku>> putNonResourceWithResponseAsync(Sku sku, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (sku != null) {
            sku.validate();
        }
        final String accept = "application/json";
        return service.putNonResource(this.client.getHost(), sku, accept, context);
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku sku to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Sku, Sku> beginPutNonResourceAsync(Sku sku) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putNonResourceWithResponseAsync(sku),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Sku.class), TypeReference.createInstance(Sku.class));
    }

    /**
     * Long running put request with non resource.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Sku, Sku> beginPutNonResourceAsync() {
        final Sku sku = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putNonResourceWithResponseAsync(sku),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Sku.class), TypeReference.createInstance(Sku.class));
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku sku to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Sku, Sku> beginPutNonResourceAsync(Sku sku, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putNonResourceWithResponseAsync(sku, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Sku.class), TypeReference.createInstance(Sku.class));
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku sku to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Sku, Sku> beginPutNonResource(Sku sku) {
        return this.beginPutNonResourceAsync(sku).getSyncPoller();
    }

    /**
     * Long running put request with non resource.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Sku, Sku> beginPutNonResource() {
        final Sku sku = null;
        return this.beginPutNonResourceAsync(sku).getSyncPoller();
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku sku to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Sku, Sku> beginPutNonResource(Sku sku, Context context) {
        return this.beginPutNonResourceAsync(sku, context).getSyncPoller();
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku Sku to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Sku>> putAsyncNonResourceWithResponseAsync(Sku sku) {
        return FluxUtil.withContext(context -> putAsyncNonResourceWithResponseAsync(sku, context));
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku Sku to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Sku>> putAsyncNonResourceWithResponseAsync(Sku sku, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (sku != null) {
            sku.validate();
        }
        final String accept = "application/json";
        return service.putAsyncNonResource(this.client.getHost(), sku, accept, context);
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku Sku to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Sku, Sku> beginPutAsyncNonResourceAsync(Sku sku) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncNonResourceWithResponseAsync(sku),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Sku.class), TypeReference.createInstance(Sku.class));
    }

    /**
     * Long running put request with non resource.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Sku, Sku> beginPutAsyncNonResourceAsync() {
        final Sku sku = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncNonResourceWithResponseAsync(sku),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Sku.class), TypeReference.createInstance(Sku.class));
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku Sku to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Sku, Sku> beginPutAsyncNonResourceAsync(Sku sku, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncNonResourceWithResponseAsync(sku, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Sku.class), TypeReference.createInstance(Sku.class));
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku Sku to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Sku, Sku> beginPutAsyncNonResource(Sku sku) {
        return this.beginPutAsyncNonResourceAsync(sku).getSyncPoller();
    }

    /**
     * Long running put request with non resource.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Sku, Sku> beginPutAsyncNonResource() {
        final Sku sku = null;
        return this.beginPutAsyncNonResourceAsync(sku).getSyncPoller();
    }

    /**
     * Long running put request with non resource.
     * 
     * @param sku Sku to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Sku, Sku> beginPutAsyncNonResource(Sku sku, Context context) {
        return this.beginPutAsyncNonResourceAsync(sku, context).getSyncPoller();
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SubProduct>> putSubResourceWithResponseAsync(SubProduct product) {
        return FluxUtil.withContext(context -> putSubResourceWithResponseAsync(product, context));
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SubProduct>> putSubResourceWithResponseAsync(SubProduct product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putSubResource(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<SubProduct, SubProduct> beginPutSubResourceAsync(SubProduct product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putSubResourceWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(SubProduct.class), TypeReference.createInstance(SubProduct.class));
    }

    /**
     * Long running put request with sub resource.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<SubProduct, SubProduct> beginPutSubResourceAsync() {
        final SubProduct product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putSubResourceWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(SubProduct.class), TypeReference.createInstance(SubProduct.class));
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<SubProduct, SubProduct> beginPutSubResourceAsync(SubProduct product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putSubResourceWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(SubProduct.class), TypeReference.createInstance(SubProduct.class));
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<SubProduct, SubProduct> beginPutSubResource(SubProduct product) {
        return this.beginPutSubResourceAsync(product).getSyncPoller();
    }

    /**
     * Long running put request with sub resource.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<SubProduct, SubProduct> beginPutSubResource() {
        final SubProduct product = null;
        return this.beginPutSubResourceAsync(product).getSyncPoller();
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<SubProduct, SubProduct> beginPutSubResource(SubProduct product, Context context) {
        return this.beginPutSubResourceAsync(product, context).getSyncPoller();
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SubProduct>> putAsyncSubResourceWithResponseAsync(SubProduct product) {
        return FluxUtil.withContext(context -> putAsyncSubResourceWithResponseAsync(product, context));
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<SubProduct>> putAsyncSubResourceWithResponseAsync(SubProduct product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.putAsyncSubResource(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<SubProduct, SubProduct> beginPutAsyncSubResourceAsync(SubProduct product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncSubResourceWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(SubProduct.class), TypeReference.createInstance(SubProduct.class));
    }

    /**
     * Long running put request with sub resource.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<SubProduct, SubProduct> beginPutAsyncSubResourceAsync() {
        final SubProduct product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.putAsyncSubResourceWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(SubProduct.class), TypeReference.createInstance(SubProduct.class));
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<SubProduct, SubProduct> beginPutAsyncSubResourceAsync(SubProduct product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.putAsyncSubResourceWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(SubProduct.class), TypeReference.createInstance(SubProduct.class));
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<SubProduct, SubProduct> beginPutAsyncSubResource(SubProduct product) {
        return this.beginPutAsyncSubResourceAsync(product).getSyncPoller();
    }

    /**
     * Long running put request with sub resource.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<SubProduct, SubProduct> beginPutAsyncSubResource() {
        final SubProduct product = null;
        return this.beginPutAsyncSubResourceAsync(product).getSyncPoller();
    }

    /**
     * Long running put request with sub resource.
     * 
     * @param product Sub Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<SubProduct, SubProduct> beginPutAsyncSubResource(SubProduct product, Context context) {
        return this.beginPutAsyncSubResourceAsync(product, context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteProvisioning202Accepted200SucceededHeaders, Product>>
        deleteProvisioning202Accepted200SucceededWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteProvisioning202Accepted200SucceededWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteProvisioning202Accepted200SucceededHeaders, Product>>
        deleteProvisioning202Accepted200SucceededWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteProvisioning202Accepted200Succeeded(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDeleteProvisioning202Accepted200SucceededAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202Accepted200SucceededWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDeleteProvisioning202Accepted200SucceededAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202Accepted200SucceededWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202Accepted200Succeeded() {
        return this.beginDeleteProvisioning202Accepted200SucceededAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202Accepted200Succeeded(Context context) {
        return this.beginDeleteProvisioning202Accepted200SucceededAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> deleteProvisioning202Accepted200SucceededNoCustomHeadersWithResponseAsync() {
        return FluxUtil
            .withContext(context -> deleteProvisioning202Accepted200SucceededNoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>>
        deleteProvisioning202Accepted200SucceededNoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteProvisioning202Accepted200SucceededNoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDeleteProvisioning202Accepted200SucceededNoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202Accepted200SucceededNoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void>
        beginDeleteProvisioning202Accepted200SucceededNoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202Accepted200SucceededNoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202Accepted200SucceededNoCustomHeaders() {
        return this.beginDeleteProvisioning202Accepted200SucceededNoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Accepted’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202Accepted200SucceededNoCustomHeaders(Context context) {
        return this.beginDeleteProvisioning202Accepted200SucceededNoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteProvisioning202DeletingFailed200Headers, Product>>
        deleteProvisioning202DeletingFailed200WithResponseAsync() {
        return FluxUtil.withContext(context -> deleteProvisioning202DeletingFailed200WithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteProvisioning202DeletingFailed200Headers, Product>>
        deleteProvisioning202DeletingFailed200WithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteProvisioning202DeletingFailed200(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDeleteProvisioning202DeletingFailed200Async() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202DeletingFailed200WithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDeleteProvisioning202DeletingFailed200Async(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202DeletingFailed200WithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202DeletingFailed200() {
        return this.beginDeleteProvisioning202DeletingFailed200Async().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202DeletingFailed200(Context context) {
        return this.beginDeleteProvisioning202DeletingFailed200Async(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> deleteProvisioning202DeletingFailed200NoCustomHeadersWithResponseAsync() {
        return FluxUtil
            .withContext(context -> deleteProvisioning202DeletingFailed200NoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>>
        deleteProvisioning202DeletingFailed200NoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteProvisioning202DeletingFailed200NoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDeleteProvisioning202DeletingFailed200NoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202DeletingFailed200NoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDeleteProvisioning202DeletingFailed200NoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202DeletingFailed200NoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202DeletingFailed200NoCustomHeaders() {
        return this.beginDeleteProvisioning202DeletingFailed200NoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Failed’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202DeletingFailed200NoCustomHeaders(Context context) {
        return this.beginDeleteProvisioning202DeletingFailed200NoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteProvisioning202Deletingcanceled200Headers, Product>>
        deleteProvisioning202Deletingcanceled200WithResponseAsync() {
        return FluxUtil.withContext(context -> deleteProvisioning202Deletingcanceled200WithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteProvisioning202Deletingcanceled200Headers, Product>>
        deleteProvisioning202Deletingcanceled200WithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteProvisioning202Deletingcanceled200(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDeleteProvisioning202Deletingcanceled200Async() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202Deletingcanceled200WithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDeleteProvisioning202Deletingcanceled200Async(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202Deletingcanceled200WithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202Deletingcanceled200() {
        return this.beginDeleteProvisioning202Deletingcanceled200Async().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202Deletingcanceled200(Context context) {
        return this.beginDeleteProvisioning202Deletingcanceled200Async(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> deleteProvisioning202Deletingcanceled200NoCustomHeadersWithResponseAsync() {
        return FluxUtil
            .withContext(context -> deleteProvisioning202Deletingcanceled200NoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>>
        deleteProvisioning202Deletingcanceled200NoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteProvisioning202Deletingcanceled200NoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDeleteProvisioning202Deletingcanceled200NoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202Deletingcanceled200NoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void>
        beginDeleteProvisioning202Deletingcanceled200NoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteProvisioning202Deletingcanceled200NoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202Deletingcanceled200NoCustomHeaders() {
        return this.beginDeleteProvisioning202Deletingcanceled200NoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Polls return this value until the last poll returns a ‘200’ with
     * ProvisioningState=’Canceled’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDeleteProvisioning202Deletingcanceled200NoCustomHeaders(Context context) {
        return this.beginDeleteProvisioning202Deletingcanceled200NoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running delete succeeds and returns right away.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> delete204SucceededWithResponseAsync() {
        return FluxUtil.withContext(context -> delete204SucceededWithResponseAsync(context));
    }

    /**
     * Long running delete succeeds and returns right away.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> delete204SucceededWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.delete204Succeeded(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete succeeds and returns right away.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDelete204SucceededAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.delete204SucceededWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete succeeds and returns right away.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDelete204SucceededAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.delete204SucceededWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete succeeds and returns right away.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDelete204Succeeded() {
        return this.beginDelete204SucceededAsync().getSyncPoller();
    }

    /**
     * Long running delete succeeds and returns right away.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDelete204Succeeded(Context context) {
        return this.beginDelete204SucceededAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDelete202Retry200Headers, Product>> delete202Retry200WithResponseAsync() {
        return FluxUtil.withContext(context -> delete202Retry200WithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDelete202Retry200Headers, Product>>
        delete202Retry200WithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.delete202Retry200(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDelete202Retry200Async() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.delete202Retry200WithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDelete202Retry200Async(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.delete202Retry200WithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDelete202Retry200() {
        return this.beginDelete202Retry200Async().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDelete202Retry200(Context context) {
        return this.beginDelete202Retry200Async(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> delete202Retry200NoCustomHeadersWithResponseAsync() {
        return FluxUtil.withContext(context -> delete202Retry200NoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> delete202Retry200NoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.delete202Retry200NoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDelete202Retry200NoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.delete202Retry200NoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDelete202Retry200NoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.delete202Retry200NoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDelete202Retry200NoCustomHeaders() {
        return this.beginDelete202Retry200NoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDelete202Retry200NoCustomHeaders(Context context) {
        return this.beginDelete202Retry200NoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDelete202NoRetry204Headers, Product>> delete202NoRetry204WithResponseAsync() {
        return FluxUtil.withContext(context -> delete202NoRetry204WithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDelete202NoRetry204Headers, Product>>
        delete202NoRetry204WithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.delete202NoRetry204(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDelete202NoRetry204Async() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.delete202NoRetry204WithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDelete202NoRetry204Async(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.delete202NoRetry204WithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDelete202NoRetry204() {
        return this.beginDelete202NoRetry204Async().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDelete202NoRetry204(Context context) {
        return this.beginDelete202NoRetry204Async(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> delete202NoRetry204NoCustomHeadersWithResponseAsync() {
        return FluxUtil.withContext(context -> delete202NoRetry204NoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> delete202NoRetry204NoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.delete202NoRetry204NoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDelete202NoRetry204NoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.delete202NoRetry204NoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Void> beginDelete202NoRetry204NoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.delete202NoRetry204NoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDelete202NoRetry204NoCustomHeaders() {
        return this.beginDelete202NoRetry204NoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last
     * poll returns a ‘200’ with ProvisioningState=’Succeeded’.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Void> beginDelete202NoRetry204NoCustomHeaders(Context context) {
        return this.beginDelete202NoRetry204NoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteNoHeaderInRetryHeaders, Void>> deleteNoHeaderInRetryWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteNoHeaderInRetryWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteNoHeaderInRetryHeaders, Void>>
        deleteNoHeaderInRetryWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteNoHeaderInRetry(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteNoHeaderInRetryAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.deleteNoHeaderInRetryWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteNoHeaderInRetryAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.deleteNoHeaderInRetryWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteNoHeaderInRetry() {
        return this.beginDeleteNoHeaderInRetryAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteNoHeaderInRetry(Context context) {
        return this.beginDeleteNoHeaderInRetryAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteNoHeaderInRetryNoCustomHeadersWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteNoHeaderInRetryNoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteNoHeaderInRetryNoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteNoHeaderInRetryNoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteNoHeaderInRetryNoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteNoHeaderInRetryNoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteNoHeaderInRetryNoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteNoHeaderInRetryNoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteNoHeaderInRetryNoCustomHeaders() {
        return this.beginDeleteNoHeaderInRetryNoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to
     * operation status do not contain location header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteNoHeaderInRetryNoCustomHeaders(Context context) {
        return this.beginDeleteNoHeaderInRetryNoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteAsyncNoHeaderInRetryHeaders, Void>>
        deleteAsyncNoHeaderInRetryWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteAsyncNoHeaderInRetryWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteAsyncNoHeaderInRetryHeaders, Void>>
        deleteAsyncNoHeaderInRetryWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteAsyncNoHeaderInRetry(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncNoHeaderInRetryAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.deleteAsyncNoHeaderInRetryWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncNoHeaderInRetryAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.deleteAsyncNoHeaderInRetryWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncNoHeaderInRetry() {
        return this.beginDeleteAsyncNoHeaderInRetryAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncNoHeaderInRetry(Context context) {
        return this.beginDeleteAsyncNoHeaderInRetryAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAsyncNoHeaderInRetryNoCustomHeadersWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteAsyncNoHeaderInRetryNoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAsyncNoHeaderInRetryNoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteAsyncNoHeaderInRetryNoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncNoHeaderInRetryNoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteAsyncNoHeaderInRetryNoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncNoHeaderInRetryNoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteAsyncNoHeaderInRetryNoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncNoHeaderInRetryNoCustomHeaders() {
        return this.beginDeleteAsyncNoHeaderInRetryNoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent
     * calls to operation status do not contain Azure-AsyncOperation header.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncNoHeaderInRetryNoCustomHeaders(Context context) {
        return this.beginDeleteAsyncNoHeaderInRetryNoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteAsyncRetrySucceededHeaders, Void>> deleteAsyncRetrySucceededWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteAsyncRetrySucceededWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteAsyncRetrySucceededHeaders, Void>>
        deleteAsyncRetrySucceededWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteAsyncRetrySucceeded(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetrySucceededAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.deleteAsyncRetrySucceededWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetrySucceededAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.deleteAsyncRetrySucceededWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetrySucceeded() {
        return this.beginDeleteAsyncRetrySucceededAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetrySucceeded(Context context) {
        return this.beginDeleteAsyncRetrySucceededAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAsyncRetrySucceededNoCustomHeadersWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteAsyncRetrySucceededNoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAsyncRetrySucceededNoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteAsyncRetrySucceededNoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetrySucceededNoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteAsyncRetrySucceededNoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetrySucceededNoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteAsyncRetrySucceededNoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetrySucceededNoCustomHeaders() {
        return this.beginDeleteAsyncRetrySucceededNoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetrySucceededNoCustomHeaders(Context context) {
        return this.beginDeleteAsyncRetrySucceededNoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteAsyncNoRetrySucceededHeaders, Void>>
        deleteAsyncNoRetrySucceededWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteAsyncNoRetrySucceededWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteAsyncNoRetrySucceededHeaders, Void>>
        deleteAsyncNoRetrySucceededWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteAsyncNoRetrySucceeded(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncNoRetrySucceededAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.deleteAsyncNoRetrySucceededWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncNoRetrySucceededAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteAsyncNoRetrySucceededWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncNoRetrySucceeded() {
        return this.beginDeleteAsyncNoRetrySucceededAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncNoRetrySucceeded(Context context) {
        return this.beginDeleteAsyncNoRetrySucceededAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteAsyncNoRetrySucceededNoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncNoRetrySucceededNoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncNoRetrySucceededNoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncNoRetrySucceededNoCustomHeaders() {
        return this.beginDeleteAsyncNoRetrySucceededNoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncNoRetrySucceededNoCustomHeaders(Context context) {
        return this.beginDeleteAsyncNoRetrySucceededNoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteAsyncRetryFailedHeaders, Void>> deleteAsyncRetryFailedWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteAsyncRetryFailedWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteAsyncRetryFailedHeaders, Void>>
        deleteAsyncRetryFailedWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteAsyncRetryFailed(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetryFailedAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.deleteAsyncRetryFailedWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetryFailedAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.deleteAsyncRetryFailedWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetryFailed() {
        return this.beginDeleteAsyncRetryFailedAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetryFailed(Context context) {
        return this.beginDeleteAsyncRetryFailedAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAsyncRetryFailedNoCustomHeadersWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteAsyncRetryFailedNoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAsyncRetryFailedNoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteAsyncRetryFailedNoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetryFailedNoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteAsyncRetryFailedNoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetryFailedNoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteAsyncRetryFailedNoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetryFailedNoCustomHeaders() {
        return this.beginDeleteAsyncRetryFailedNoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetryFailedNoCustomHeaders(Context context) {
        return this.beginDeleteAsyncRetryFailedNoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteAsyncRetrycanceledHeaders, Void>> deleteAsyncRetrycanceledWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteAsyncRetrycanceledWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsDeleteAsyncRetrycanceledHeaders, Void>>
        deleteAsyncRetrycanceledWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteAsyncRetrycanceled(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetrycanceledAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.deleteAsyncRetrycanceledWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetrycanceledAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.deleteAsyncRetrycanceledWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetrycanceled() {
        return this.beginDeleteAsyncRetrycanceledAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetrycanceled(Context context) {
        return this.beginDeleteAsyncRetrycanceledAsync(context).getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAsyncRetrycanceledNoCustomHeadersWithResponseAsync() {
        return FluxUtil.withContext(context -> deleteAsyncRetrycanceledNoCustomHeadersWithResponseAsync(context));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteAsyncRetrycanceledNoCustomHeadersWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.deleteAsyncRetrycanceledNoCustomHeaders(this.client.getHost(), accept, context);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetrycanceledNoCustomHeadersAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteAsyncRetrycanceledNoCustomHeadersWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, Void> beginDeleteAsyncRetrycanceledNoCustomHeadersAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.deleteAsyncRetrycanceledNoCustomHeadersWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(Void.class));
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetrycanceledNoCustomHeaders() {
        return this.beginDeleteAsyncRetrycanceledNoCustomHeadersAsync().getSyncPoller();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the
     * Azure-AsyncOperation header for operation status.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, Void> beginDeleteAsyncRetrycanceledNoCustomHeaders(Context context) {
        return this.beginDeleteAsyncRetrycanceledNoCustomHeadersAsync(context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a
     * 200 with a response body after success.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Sku>> post200WithPayloadWithResponseAsync() {
        return FluxUtil.withContext(context -> post200WithPayloadWithResponseAsync(context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a
     * 200 with a response body after success.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Sku>> post200WithPayloadWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.post200WithPayload(this.client.getHost(), accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a
     * 200 with a response body after success.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Sku, Sku> beginPost200WithPayloadAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post200WithPayloadWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Sku.class), TypeReference.createInstance(Sku.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a
     * 200 with a response body after success.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Sku, Sku> beginPost200WithPayloadAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post200WithPayloadWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Sku.class), TypeReference.createInstance(Sku.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a
     * 200 with a response body after success.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Sku, Sku> beginPost200WithPayload() {
        return this.beginPost200WithPayloadAsync().getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a
     * 200 with a response body after success.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Sku, Sku> beginPost200WithPayload(Context context) {
        return this.beginPost200WithPayloadAsync(context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPost202Retry200Headers, Void>> post202Retry200WithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> post202Retry200WithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPost202Retry200Headers, Void>> post202Retry200WithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.post202Retry200(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPost202Retry200Async(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post202Retry200WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPost202Retry200Async() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post202Retry200WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPost202Retry200Async(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post202Retry200WithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPost202Retry200(Product product) {
        return this.beginPost202Retry200Async(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPost202Retry200() {
        final Product product = null;
        return this.beginPost202Retry200Async(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPost202Retry200(Product product, Context context) {
        return this.beginPost202Retry200Async(product, context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> post202Retry200NoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> post202Retry200NoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> post202Retry200NoCustomHeadersWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.post202Retry200NoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPost202Retry200NoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.post202Retry200NoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPost202Retry200NoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.post202Retry200NoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPost202Retry200NoCustomHeadersAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.post202Retry200NoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPost202Retry200NoCustomHeaders(Product product) {
        return this.beginPost202Retry200NoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPost202Retry200NoCustomHeaders() {
        final Product product = null;
        return this.beginPost202Retry200NoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After'
     * headers, Polls return a 200 with a response body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPost202Retry200NoCustomHeaders(Product product, Context context) {
        return this.beginPost202Retry200NoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPost202NoRetry204Headers, Product>>
        post202NoRetry204WithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> post202NoRetry204WithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPost202NoRetry204Headers, Product>> post202NoRetry204WithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.post202NoRetry204(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPost202NoRetry204Async(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post202NoRetry204WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPost202NoRetry204Async() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post202NoRetry204WithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPost202NoRetry204Async(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.post202NoRetry204WithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPost202NoRetry204(Product product) {
        return this.beginPost202NoRetry204Async(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPost202NoRetry204() {
        final Product product = null;
        return this.beginPost202NoRetry204Async(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPost202NoRetry204(Product product, Context context) {
        return this.beginPost202NoRetry204Async(product, context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> post202NoRetry204NoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> post202NoRetry204NoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> post202NoRetry204NoCustomHeadersWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.post202NoRetry204NoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPost202NoRetry204NoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.post202NoRetry204NoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPost202NoRetry204NoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.post202NoRetry204NoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPost202NoRetry204NoCustomHeadersAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.post202NoRetry204NoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPost202NoRetry204NoCustomHeaders(Product product) {
        return this.beginPost202NoRetry204NoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPost202NoRetry204NoCustomHeaders() {
        final Product product = null;
        return this.beginPost202NoRetry204NoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with
     * noresponse body after success.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPost202NoRetry204NoCustomHeaders(Product product, Context context) {
        return this.beginPost202NoRetry204NoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should poll Location to get the final object.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> postDoubleHeadersFinalLocationGetWithResponseAsync() {
        return FluxUtil.withContext(context -> postDoubleHeadersFinalLocationGetWithResponseAsync(context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should poll Location to get the final object.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> postDoubleHeadersFinalLocationGetWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.postDoubleHeadersFinalLocationGet(this.client.getHost(), accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should poll Location to get the final object.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostDoubleHeadersFinalLocationGetAsync() {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.postDoubleHeadersFinalLocationGetWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should poll Location to get the final object.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostDoubleHeadersFinalLocationGetAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postDoubleHeadersFinalLocationGetWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should poll Location to get the final object.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostDoubleHeadersFinalLocationGet() {
        return this.beginPostDoubleHeadersFinalLocationGetAsync().getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should poll Location to get the final object.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostDoubleHeadersFinalLocationGet(Context context) {
        return this.beginPostDoubleHeadersFinalLocationGetAsync(context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> postDoubleHeadersFinalAzureHeaderGetWithResponseAsync() {
        return FluxUtil.withContext(context -> postDoubleHeadersFinalAzureHeaderGetWithResponseAsync(context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> postDoubleHeadersFinalAzureHeaderGetWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.postDoubleHeadersFinalAzureHeaderGet(this.client.getHost(), accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostDoubleHeadersFinalAzureHeaderGetAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postDoubleHeadersFinalAzureHeaderGetWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostDoubleHeadersFinalAzureHeaderGetAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postDoubleHeadersFinalAzureHeaderGetWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostDoubleHeadersFinalAzureHeaderGet() {
        return this.beginPostDoubleHeadersFinalAzureHeaderGetAsync().getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostDoubleHeadersFinalAzureHeaderGet(Context context) {
        return this.beginPostDoubleHeadersFinalAzureHeaderGetAsync(context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object if you support
     * initial Autorest behavior.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> postDoubleHeadersFinalAzureHeaderGetDefaultWithResponseAsync() {
        return FluxUtil.withContext(context -> postDoubleHeadersFinalAzureHeaderGetDefaultWithResponseAsync(context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object if you support
     * initial Autorest behavior.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> postDoubleHeadersFinalAzureHeaderGetDefaultWithResponseAsync(Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        final String accept = "application/json";
        return service.postDoubleHeadersFinalAzureHeaderGetDefault(this.client.getHost(), accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object if you support
     * initial Autorest behavior.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostDoubleHeadersFinalAzureHeaderGetDefaultAsync() {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postDoubleHeadersFinalAzureHeaderGetDefaultWithResponseAsync(),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object if you support
     * initial Autorest behavior.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostDoubleHeadersFinalAzureHeaderGetDefaultAsync(Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postDoubleHeadersFinalAzureHeaderGetDefaultWithResponseAsync(context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object if you support
     * initial Autorest behavior.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostDoubleHeadersFinalAzureHeaderGetDefault() {
        return this.beginPostDoubleHeadersFinalAzureHeaderGetDefaultAsync().getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request with both Location and Azure-Async
     * header. Poll Azure-Async and it's success. Should NOT poll Location to get the final object if you support
     * initial Autorest behavior.
     * 
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostDoubleHeadersFinalAzureHeaderGetDefault(Context context) {
        return this.beginPostDoubleHeadersFinalAzureHeaderGetDefaultAsync(context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPostAsyncRetrySucceededHeaders, Product>>
        postAsyncRetrySucceededWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> postAsyncRetrySucceededWithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPostAsyncRetrySucceededHeaders, Product>>
        postAsyncRetrySucceededWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.postAsyncRetrySucceeded(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncRetrySucceededAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.postAsyncRetrySucceededWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncRetrySucceededAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.postAsyncRetrySucceededWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncRetrySucceededAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetrySucceededWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncRetrySucceeded(Product product) {
        return this.beginPostAsyncRetrySucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncRetrySucceeded() {
        final Product product = null;
        return this.beginPostAsyncRetrySucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncRetrySucceeded(Product product, Context context) {
        return this.beginPostAsyncRetrySucceededAsync(product, context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> postAsyncRetrySucceededNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil
            .withContext(context -> postAsyncRetrySucceededNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> postAsyncRetrySucceededNoCustomHeadersWithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.postAsyncRetrySucceededNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncRetrySucceededNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetrySucceededNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncRetrySucceededNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetrySucceededNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncRetrySucceededNoCustomHeadersAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetrySucceededNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncRetrySucceededNoCustomHeaders(Product product) {
        return this.beginPostAsyncRetrySucceededNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncRetrySucceededNoCustomHeaders() {
        final Product product = null;
        return this.beginPostAsyncRetrySucceededNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncRetrySucceededNoCustomHeaders(Product product, Context context) {
        return this.beginPostAsyncRetrySucceededNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPostAsyncNoRetrySucceededHeaders, Product>>
        postAsyncNoRetrySucceededWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> postAsyncNoRetrySucceededWithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPostAsyncNoRetrySucceededHeaders, Product>>
        postAsyncNoRetrySucceededWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.postAsyncNoRetrySucceeded(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncNoRetrySucceededAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.postAsyncNoRetrySucceededWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncNoRetrySucceededAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.postAsyncNoRetrySucceededWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncNoRetrySucceededAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncNoRetrySucceededWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncNoRetrySucceeded(Product product) {
        return this.beginPostAsyncNoRetrySucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncNoRetrySucceeded() {
        final Product product = null;
        return this.beginPostAsyncNoRetrySucceededAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncNoRetrySucceeded(Product product, Context context) {
        return this.beginPostAsyncNoRetrySucceededAsync(product, context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> postAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil
            .withContext(context -> postAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Product>> postAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.postAsyncNoRetrySucceededNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncNoRetrySucceededNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncNoRetrySucceededNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<Product, Product> beginPostAsyncNoRetrySucceededNoCustomHeadersAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncNoRetrySucceededNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(Product.class), TypeReference.createInstance(Product.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncNoRetrySucceededNoCustomHeaders(Product product) {
        return this.beginPostAsyncNoRetrySucceededNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncNoRetrySucceededNoCustomHeaders() {
        final Product product = null;
        return this.beginPostAsyncNoRetrySucceededNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<Product, Product> beginPostAsyncNoRetrySucceededNoCustomHeaders(Product product,
        Context context) {
        return this.beginPostAsyncNoRetrySucceededNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPostAsyncRetryFailedHeaders, Void>>
        postAsyncRetryFailedWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> postAsyncRetryFailedWithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPostAsyncRetryFailedHeaders, Void>>
        postAsyncRetryFailedWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.postAsyncRetryFailed(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetryFailedAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.postAsyncRetryFailedWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetryFailedAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.postAsyncRetryFailedWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetryFailedAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetryFailedWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetryFailed(Product product) {
        return this.beginPostAsyncRetryFailedAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetryFailed() {
        final Product product = null;
        return this.beginPostAsyncRetryFailedAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetryFailed(Product product, Context context) {
        return this.beginPostAsyncRetryFailedAsync(product, context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> postAsyncRetryFailedNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> postAsyncRetryFailedNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> postAsyncRetryFailedNoCustomHeadersWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.postAsyncRetryFailedNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetryFailedNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetryFailedNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetryFailedNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetryFailedNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetryFailedNoCustomHeadersAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetryFailedNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetryFailedNoCustomHeaders(Product product) {
        return this.beginPostAsyncRetryFailedNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetryFailedNoCustomHeaders() {
        final Product product = null;
        return this.beginPostAsyncRetryFailedNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetryFailedNoCustomHeaders(Product product,
        Context context) {
        return this.beginPostAsyncRetryFailedNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPostAsyncRetrycanceledHeaders, Void>>
        postAsyncRetrycanceledWithResponseAsync(Product product) {
        return FluxUtil.withContext(context -> postAsyncRetrycanceledWithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link ResponseBase} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<ResponseBase<LROsPostAsyncRetrycanceledHeaders, Void>>
        postAsyncRetrycanceledWithResponseAsync(Product product, Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.postAsyncRetrycanceled(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetrycanceledAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.postAsyncRetrycanceledWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetrycanceledAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1), () -> this.postAsyncRetrycanceledWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetrycanceledAsync(Product product, Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetrycanceledWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetrycanceled(Product product) {
        return this.beginPostAsyncRetrycanceledAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetrycanceled() {
        final Product product = null;
        return this.beginPostAsyncRetrycanceledAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetrycanceled(Product product, Context context) {
        return this.beginPostAsyncRetrycanceledAsync(product, context).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> postAsyncRetrycanceledNoCustomHeadersWithResponseAsync(Product product) {
        return FluxUtil
            .withContext(context -> postAsyncRetrycanceledNoCustomHeadersWithResponseAsync(product, context));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> postAsyncRetrycanceledNoCustomHeadersWithResponseAsync(Product product,
        Context context) {
        if (this.client.getHost() == null) {
            return Mono
                .error(new IllegalArgumentException("Parameter this.client.getHost() is required and cannot be null."));
        }
        if (product != null) {
            product.validate();
        }
        final String accept = "application/json";
        return service.postAsyncRetrycanceledNoCustomHeaders(this.client.getHost(), product, accept, context);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetrycanceledNoCustomHeadersAsync(Product product) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetrycanceledNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetrycanceledNoCustomHeadersAsync() {
        final Product product = null;
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetrycanceledNoCustomHeadersWithResponseAsync(product),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(Context.NONE)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginPostAsyncRetrycanceledNoCustomHeadersAsync(Product product,
        Context context) {
        return PollerFlux.create(Duration.ofSeconds(1),
            () -> this.postAsyncRetrycanceledNoCustomHeadersWithResponseAsync(product, context),
            new DefaultPollingStrategy<>(new PollingStrategyOptions(this.client.getHttpPipeline())

                .setContext(context)),
            TypeReference.createInstance(BinaryData.class), TypeReference.createInstance(BinaryData.class));
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetrycanceledNoCustomHeaders(Product product) {
        return this.beginPostAsyncRetrycanceledNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetrycanceledNoCustomHeaders() {
        final Product product = null;
        return this.beginPostAsyncRetrycanceledNoCustomHeadersAsync(product).getSyncPoller();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains
     * ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation
     * status.
     * 
     * @param product Product to put.
     * @param context The context to associate with this operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws CloudErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginPostAsyncRetrycanceledNoCustomHeaders(Product product,
        Context context) {
        return this.beginPostAsyncRetrycanceledNoCustomHeadersAsync(product, context).getSyncPoller();
    }

    private static final TypeReference<List<Product>> TYPE_REFERENCE_LIST_PRODUCT = new TypeReference<List<Product>>() {
    };
}
