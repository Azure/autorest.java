/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.url.implementation;

import com.microsoft.rest.v2.Base64Url;
import com.microsoft.rest.v2.CollectionFormat;
import com.microsoft.rest.v2.RestProxy;
import com.microsoft.rest.v2.ServiceCallback;
import com.microsoft.rest.v2.ServiceFuture;
import com.microsoft.rest.v2.Validator;
import com.microsoft.rest.v2.VoidResponse;
import com.microsoft.rest.v2.annotations.ExpectedResponses;
import com.microsoft.rest.v2.annotations.GET;
import com.microsoft.rest.v2.annotations.Host;
import com.microsoft.rest.v2.annotations.PathParam;
import com.microsoft.rest.v2.annotations.UnexpectedResponseExceptionType;
import com.microsoft.rest.v2.util.Base64Util;
import fixtures.url.Paths;
import fixtures.url.models.ErrorException;
import fixtures.url.models.UriColor;
import io.reactivex.Completable;
import io.reactivex.Single;
import io.reactivex.annotations.NonNull;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * An instance of this class provides access to all the operations defined in
 * Paths.
 */
public final class PathsImpl implements Paths {
    /**
     * The proxy service used to perform REST calls.
     */
    private PathsService service;

    /**
     * The service client containing this operation class.
     */
    private AutoRestUrlTestServiceImpl client;

    /**
     * Initializes an instance of PathsImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    public PathsImpl(AutoRestUrlTestServiceImpl client) {
        this.service = RestProxy.create(PathsService.class, client);
        this.client = client;
    }

    /**
     * The interface defining all the services for Paths to be used by the
     * proxy service to perform REST calls.
     */
    @Host("http://localhost:3000")
    private interface PathsService {
        @GET("paths/bool/true/{boolPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getBooleanTrue(@PathParam("boolPath") boolean boolPath);

        @GET("paths/bool/false/{boolPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getBooleanFalse(@PathParam("boolPath") boolean boolPath);

        @GET("paths/int/1000000/{intPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getIntOneMillion(@PathParam("intPath") int intPath);

        @GET("paths/int/-1000000/{intPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getIntNegativeOneMillion(@PathParam("intPath") int intPath);

        @GET("paths/long/10000000000/{longPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getTenBillion(@PathParam("longPath") long longPath);

        @GET("paths/long/-10000000000/{longPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getNegativeTenBillion(@PathParam("longPath") long longPath);

        @GET("paths/float/1.034E+20/{floatPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> floatScientificPositive(@PathParam("floatPath") double floatPath);

        @GET("paths/float/-1.034E-20/{floatPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> floatScientificNegative(@PathParam("floatPath") double floatPath);

        @GET("paths/double/9999999.999/{doublePath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> doubleDecimalPositive(@PathParam("doublePath") double doublePath);

        @GET("paths/double/-9999999.999/{doublePath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> doubleDecimalNegative(@PathParam("doublePath") double doublePath);

        @GET("paths/string/unicode/{stringPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> stringUnicode(@PathParam("stringPath") String stringPath);

        @GET("paths/string/begin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend/{stringPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> stringUrlEncoded(@PathParam("stringPath") String stringPath);

        @GET("paths/string/empty/{stringPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> stringEmpty(@PathParam("stringPath") String stringPath);

        @GET("paths/string/null/{stringPath}")
        @ExpectedResponses({400})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> stringNull(@PathParam("stringPath") String stringPath);

        @GET("paths/enum/green%20color/{enumPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> enumValid(@PathParam("enumPath") UriColor enumPath);

        @GET("paths/string/null/{enumPath}")
        @ExpectedResponses({400})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> enumNull(@PathParam("enumPath") UriColor enumPath);

        @GET("paths/byte/multibyte/{bytePath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> byteMultiByte(@PathParam("bytePath") String bytePath);

        @GET("paths/byte/empty/{bytePath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> byteEmpty(@PathParam("bytePath") String bytePath);

        @GET("paths/byte/null/{bytePath}")
        @ExpectedResponses({400})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> byteNull(@PathParam("bytePath") String bytePath);

        @GET("paths/date/2012-01-01/{datePath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> dateValid(@PathParam("datePath") LocalDate datePath);

        @GET("paths/date/null/{datePath}")
        @ExpectedResponses({400})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> dateNull(@PathParam("datePath") LocalDate datePath);

        @GET("paths/datetime/2012-01-01T01%3A01%3A01Z/{dateTimePath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> dateTimeValid(@PathParam("dateTimePath") OffsetDateTime dateTimePath);

        @GET("paths/datetime/null/{dateTimePath}")
        @ExpectedResponses({400})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> dateTimeNull(@PathParam("dateTimePath") OffsetDateTime dateTimePath);

        @GET("paths/string/bG9yZW0/{base64UrlPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> base64Url(@PathParam("base64UrlPath") Base64Url base64UrlPath);

        @GET("paths/array/ArrayPath1%2cbegin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend%2c%2c/{arrayPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> arrayCsvInPath(@PathParam("arrayPath") String arrayPath);

        @GET("paths/int/1460505600/{unixTimeUrlPath}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> unixTimeUrl(@PathParam("unixTimeUrlPath") long unixTimeUrlPath);
    }

    /**
     * Get true Boolean value on path.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getBooleanTrue() {
        getBooleanTrueAsync().blockingAwait();
    }

    /**
     * Get true Boolean value on path.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getBooleanTrueAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanTrueAsync(), serviceCallback);
    }

    /**
     * Get true Boolean value on path.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getBooleanTrueWithRestResponseAsync() {
        final boolean boolPath = true;
        return service.getBooleanTrue(boolPath);
    }

    /**
     * Get true Boolean value on path.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getBooleanTrueAsync() {
        return getBooleanTrueWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get false Boolean value on path.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getBooleanFalse() {
        getBooleanFalseAsync().blockingAwait();
    }

    /**
     * Get false Boolean value on path.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getBooleanFalseAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanFalseAsync(), serviceCallback);
    }

    /**
     * Get false Boolean value on path.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getBooleanFalseWithRestResponseAsync() {
        final boolean boolPath = false;
        return service.getBooleanFalse(boolPath);
    }

    /**
     * Get false Boolean value on path.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getBooleanFalseAsync() {
        return getBooleanFalseWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '1000000' integer value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getIntOneMillion() {
        getIntOneMillionAsync().blockingAwait();
    }

    /**
     * Get '1000000' integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getIntOneMillionAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getIntOneMillionAsync(), serviceCallback);
    }

    /**
     * Get '1000000' integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getIntOneMillionWithRestResponseAsync() {
        final int intPath = 1000000;
        return service.getIntOneMillion(intPath);
    }

    /**
     * Get '1000000' integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getIntOneMillionAsync() {
        return getIntOneMillionWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '-1000000' integer value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getIntNegativeOneMillion() {
        getIntNegativeOneMillionAsync().blockingAwait();
    }

    /**
     * Get '-1000000' integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getIntNegativeOneMillionAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getIntNegativeOneMillionAsync(), serviceCallback);
    }

    /**
     * Get '-1000000' integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getIntNegativeOneMillionWithRestResponseAsync() {
        final int intPath = -1000000;
        return service.getIntNegativeOneMillion(intPath);
    }

    /**
     * Get '-1000000' integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getIntNegativeOneMillionAsync() {
        return getIntNegativeOneMillionWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getTenBillion() {
        getTenBillionAsync().blockingAwait();
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getTenBillionAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getTenBillionAsync(), serviceCallback);
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getTenBillionWithRestResponseAsync() {
        final long longPath = 10000000000L;
        return service.getTenBillion(longPath);
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getTenBillionAsync() {
        return getTenBillionWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getNegativeTenBillion() {
        getNegativeTenBillionAsync().blockingAwait();
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getNegativeTenBillionAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getNegativeTenBillionAsync(), serviceCallback);
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getNegativeTenBillionWithRestResponseAsync() {
        final long longPath = -10000000000L;
        return service.getNegativeTenBillion(longPath);
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getNegativeTenBillionAsync() {
        return getNegativeTenBillionWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void floatScientificPositive() {
        floatScientificPositiveAsync().blockingAwait();
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> floatScientificPositiveAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(floatScientificPositiveAsync(), serviceCallback);
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> floatScientificPositiveWithRestResponseAsync() {
        final double floatPath = 1.034E+20;
        return service.floatScientificPositive(floatPath);
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable floatScientificPositiveAsync() {
        return floatScientificPositiveWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void floatScientificNegative() {
        floatScientificNegativeAsync().blockingAwait();
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> floatScientificNegativeAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(floatScientificNegativeAsync(), serviceCallback);
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> floatScientificNegativeWithRestResponseAsync() {
        final double floatPath = -1.034E-20;
        return service.floatScientificNegative(floatPath);
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable floatScientificNegativeAsync() {
        return floatScientificNegativeWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void doubleDecimalPositive() {
        doubleDecimalPositiveAsync().blockingAwait();
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> doubleDecimalPositiveAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(doubleDecimalPositiveAsync(), serviceCallback);
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> doubleDecimalPositiveWithRestResponseAsync() {
        final double doublePath = 9999999.999;
        return service.doubleDecimalPositive(doublePath);
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable doubleDecimalPositiveAsync() {
        return doubleDecimalPositiveWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void doubleDecimalNegative() {
        doubleDecimalNegativeAsync().blockingAwait();
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> doubleDecimalNegativeAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(doubleDecimalNegativeAsync(), serviceCallback);
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> doubleDecimalNegativeWithRestResponseAsync() {
        final double doublePath = -9999999.999;
        return service.doubleDecimalNegative(doublePath);
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable doubleDecimalNegativeAsync() {
        return doubleDecimalNegativeWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void stringUnicode() {
        stringUnicodeAsync().blockingAwait();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> stringUnicodeAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(stringUnicodeAsync(), serviceCallback);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> stringUnicodeWithRestResponseAsync() {
        final String stringPath = "啊齄丂狛狜隣郎隣兀﨩";
        return service.stringUnicode(stringPath);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable stringUnicodeAsync() {
        return stringUnicodeWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void stringUrlEncoded() {
        stringUrlEncodedAsync().blockingAwait();
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> stringUrlEncodedAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(stringUrlEncodedAsync(), serviceCallback);
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> stringUrlEncodedWithRestResponseAsync() {
        final String stringPath = "begin!*'();:@ &=+$,/?#[]end";
        return service.stringUrlEncoded(stringPath);
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable stringUrlEncodedAsync() {
        return stringUrlEncodedWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get ''.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void stringEmpty() {
        stringEmptyAsync().blockingAwait();
    }

    /**
     * Get ''.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> stringEmptyAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(stringEmptyAsync(), serviceCallback);
    }

    /**
     * Get ''.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> stringEmptyWithRestResponseAsync() {
        final String stringPath = "";
        return service.stringEmpty(stringPath);
    }

    /**
     * Get ''.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable stringEmptyAsync() {
        return stringEmptyWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null (should throw).
     *
     * @param stringPath null string value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void stringNull(@NonNull String stringPath) {
        stringNullAsync(stringPath).blockingAwait();
    }

    /**
     * Get null (should throw).
     *
     * @param stringPath null string value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> stringNullAsync(@NonNull String stringPath, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(stringNullAsync(stringPath), serviceCallback);
    }

    /**
     * Get null (should throw).
     *
     * @param stringPath null string value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> stringNullWithRestResponseAsync(@NonNull String stringPath) {
        if (stringPath == null) {
            throw new IllegalArgumentException("Parameter stringPath is required and cannot be null.");
        }
        return service.stringNull(stringPath);
    }

    /**
     * Get null (should throw).
     *
     * @param stringPath null string value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable stringNullAsync(@NonNull String stringPath) {
        return stringNullWithRestResponseAsync(stringPath)
            .ignoreElement();
    }

    /**
     * Get using uri with 'green color' in path parameter.
     *
     * @param enumPath send the value green. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void enumValid(@NonNull UriColor enumPath) {
        enumValidAsync(enumPath).blockingAwait();
    }

    /**
     * Get using uri with 'green color' in path parameter.
     *
     * @param enumPath send the value green. Possible values include: 'red color', 'green color', 'blue color'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> enumValidAsync(@NonNull UriColor enumPath, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(enumValidAsync(enumPath), serviceCallback);
    }

    /**
     * Get using uri with 'green color' in path parameter.
     *
     * @param enumPath send the value green. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> enumValidWithRestResponseAsync(@NonNull UriColor enumPath) {
        if (enumPath == null) {
            throw new IllegalArgumentException("Parameter enumPath is required and cannot be null.");
        }
        return service.enumValid(enumPath);
    }

    /**
     * Get using uri with 'green color' in path parameter.
     *
     * @param enumPath send the value green. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable enumValidAsync(@NonNull UriColor enumPath) {
        return enumValidWithRestResponseAsync(enumPath)
            .ignoreElement();
    }

    /**
     * Get null (should throw on the client before the request is sent on wire).
     *
     * @param enumPath send null should throw. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void enumNull(@NonNull UriColor enumPath) {
        enumNullAsync(enumPath).blockingAwait();
    }

    /**
     * Get null (should throw on the client before the request is sent on wire).
     *
     * @param enumPath send null should throw. Possible values include: 'red color', 'green color', 'blue color'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> enumNullAsync(@NonNull UriColor enumPath, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(enumNullAsync(enumPath), serviceCallback);
    }

    /**
     * Get null (should throw on the client before the request is sent on wire).
     *
     * @param enumPath send null should throw. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> enumNullWithRestResponseAsync(@NonNull UriColor enumPath) {
        if (enumPath == null) {
            throw new IllegalArgumentException("Parameter enumPath is required and cannot be null.");
        }
        return service.enumNull(enumPath);
    }

    /**
     * Get null (should throw on the client before the request is sent on wire).
     *
     * @param enumPath send null should throw. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable enumNullAsync(@NonNull UriColor enumPath) {
        return enumNullWithRestResponseAsync(enumPath)
            .ignoreElement();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param bytePath '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void byteMultiByte(@NonNull byte[] bytePath) {
        byteMultiByteAsync(bytePath).blockingAwait();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param bytePath '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> byteMultiByteAsync(@NonNull byte[] bytePath, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(byteMultiByteAsync(bytePath), serviceCallback);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param bytePath '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> byteMultiByteWithRestResponseAsync(@NonNull byte[] bytePath) {
        if (bytePath == null) {
            throw new IllegalArgumentException("Parameter bytePath is required and cannot be null.");
        }
        String bytePathConverted = Base64Util.encodeToString(bytePath);
        return service.byteMultiByte(bytePathConverted);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param bytePath '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable byteMultiByteAsync(@NonNull byte[] bytePath) {
        return byteMultiByteWithRestResponseAsync(bytePath)
            .ignoreElement();
    }

    /**
     * Get '' as byte array.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void byteEmpty() {
        byteEmptyAsync().blockingAwait();
    }

    /**
     * Get '' as byte array.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> byteEmptyAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(byteEmptyAsync(), serviceCallback);
    }

    /**
     * Get '' as byte array.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> byteEmptyWithRestResponseAsync() {
        final byte[] bytePath = "".getBytes();
        String bytePathConverted = Base64Util.encodeToString(bytePath);
        return service.byteEmpty(bytePathConverted);
    }

    /**
     * Get '' as byte array.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable byteEmptyAsync() {
        return byteEmptyWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null as byte array (should throw).
     *
     * @param bytePath null as byte array (should throw).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void byteNull(@NonNull byte[] bytePath) {
        byteNullAsync(bytePath).blockingAwait();
    }

    /**
     * Get null as byte array (should throw).
     *
     * @param bytePath null as byte array (should throw).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> byteNullAsync(@NonNull byte[] bytePath, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(byteNullAsync(bytePath), serviceCallback);
    }

    /**
     * Get null as byte array (should throw).
     *
     * @param bytePath null as byte array (should throw).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> byteNullWithRestResponseAsync(@NonNull byte[] bytePath) {
        if (bytePath == null) {
            throw new IllegalArgumentException("Parameter bytePath is required and cannot be null.");
        }
        String bytePathConverted = Base64Util.encodeToString(bytePath);
        return service.byteNull(bytePathConverted);
    }

    /**
     * Get null as byte array (should throw).
     *
     * @param bytePath null as byte array (should throw).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable byteNullAsync(@NonNull byte[] bytePath) {
        return byteNullWithRestResponseAsync(bytePath)
            .ignoreElement();
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void dateValid() {
        dateValidAsync().blockingAwait();
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> dateValidAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(dateValidAsync(), serviceCallback);
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> dateValidWithRestResponseAsync() {
        final LocalDate datePath = LocalDate.parse("2012-01-01");
        return service.dateValid(datePath);
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable dateValidAsync() {
        return dateValidWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null as date - this should throw or be unusable on the client side, depending on date representation.
     *
     * @param datePath null as date (should throw).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void dateNull(@NonNull LocalDate datePath) {
        dateNullAsync(datePath).blockingAwait();
    }

    /**
     * Get null as date - this should throw or be unusable on the client side, depending on date representation.
     *
     * @param datePath null as date (should throw).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> dateNullAsync(@NonNull LocalDate datePath, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(dateNullAsync(datePath), serviceCallback);
    }

    /**
     * Get null as date - this should throw or be unusable on the client side, depending on date representation.
     *
     * @param datePath null as date (should throw).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> dateNullWithRestResponseAsync(@NonNull LocalDate datePath) {
        if (datePath == null) {
            throw new IllegalArgumentException("Parameter datePath is required and cannot be null.");
        }
        return service.dateNull(datePath);
    }

    /**
     * Get null as date - this should throw or be unusable on the client side, depending on date representation.
     *
     * @param datePath null as date (should throw).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable dateNullAsync(@NonNull LocalDate datePath) {
        return dateNullWithRestResponseAsync(datePath)
            .ignoreElement();
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void dateTimeValid() {
        dateTimeValidAsync().blockingAwait();
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> dateTimeValidAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(dateTimeValidAsync(), serviceCallback);
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> dateTimeValidWithRestResponseAsync() {
        final OffsetDateTime dateTimePath = OffsetDateTime.parse("2012-01-01T01:01:01Z");
        return service.dateTimeValid(dateTimePath);
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable dateTimeValidAsync() {
        return dateTimeValidWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null as date-time, should be disallowed or throw depending on representation of date-time.
     *
     * @param dateTimePath null as date-time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void dateTimeNull(@NonNull OffsetDateTime dateTimePath) {
        dateTimeNullAsync(dateTimePath).blockingAwait();
    }

    /**
     * Get null as date-time, should be disallowed or throw depending on representation of date-time.
     *
     * @param dateTimePath null as date-time.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> dateTimeNullAsync(@NonNull OffsetDateTime dateTimePath, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(dateTimeNullAsync(dateTimePath), serviceCallback);
    }

    /**
     * Get null as date-time, should be disallowed or throw depending on representation of date-time.
     *
     * @param dateTimePath null as date-time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> dateTimeNullWithRestResponseAsync(@NonNull OffsetDateTime dateTimePath) {
        if (dateTimePath == null) {
            throw new IllegalArgumentException("Parameter dateTimePath is required and cannot be null.");
        }
        return service.dateTimeNull(dateTimePath);
    }

    /**
     * Get null as date-time, should be disallowed or throw depending on representation of date-time.
     *
     * @param dateTimePath null as date-time.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable dateTimeNullAsync(@NonNull OffsetDateTime dateTimePath) {
        return dateTimeNullWithRestResponseAsync(dateTimePath)
            .ignoreElement();
    }

    /**
     * Get 'lorem' encoded value as 'bG9yZW0' (base64url).
     *
     * @param base64UrlPath base64url encoded value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void base64Url(@NonNull byte[] base64UrlPath) {
        base64UrlAsync(base64UrlPath).blockingAwait();
    }

    /**
     * Get 'lorem' encoded value as 'bG9yZW0' (base64url).
     *
     * @param base64UrlPath base64url encoded value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> base64UrlAsync(@NonNull byte[] base64UrlPath, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(base64UrlAsync(base64UrlPath), serviceCallback);
    }

    /**
     * Get 'lorem' encoded value as 'bG9yZW0' (base64url).
     *
     * @param base64UrlPath base64url encoded value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> base64UrlWithRestResponseAsync(@NonNull byte[] base64UrlPath) {
        if (base64UrlPath == null) {
            throw new IllegalArgumentException("Parameter base64UrlPath is required and cannot be null.");
        }
        Base64Url base64UrlPathConverted = Base64Url.encode(base64UrlPath);
        return service.base64Url(base64UrlPathConverted);
    }

    /**
     * Get 'lorem' encoded value as 'bG9yZW0' (base64url).
     *
     * @param base64UrlPath base64url encoded value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable base64UrlAsync(@NonNull byte[] base64UrlPath) {
        return base64UrlWithRestResponseAsync(base64UrlPath)
            .ignoreElement();
    }

    /**
     * Get an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayPath an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayCsvInPath(@NonNull List<String> arrayPath) {
        arrayCsvInPathAsync(arrayPath).blockingAwait();
    }

    /**
     * Get an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayPath an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayCsvInPathAsync(@NonNull List<String> arrayPath, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayCsvInPathAsync(arrayPath), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayPath an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayCsvInPathWithRestResponseAsync(@NonNull List<String> arrayPath) {
        if (arrayPath == null) {
            throw new IllegalArgumentException("Parameter arrayPath is required and cannot be null.");
        }
        Validator.validate(arrayPath);
        String arrayPathConverted = this.client.serializerAdapter().serializeList(arrayPath, CollectionFormat.CSV);
        return service.arrayCsvInPath(arrayPathConverted);
    }

    /**
     * Get an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayPath an array of string ['ArrayPath1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayCsvInPathAsync(@NonNull List<String> arrayPath) {
        return arrayCsvInPathWithRestResponseAsync(arrayPath)
            .ignoreElement();
    }

    /**
     * Get the date 2016-04-13 encoded value as '1460505600' (Unix time).
     *
     * @param unixTimeUrlPath Unix time encoded value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void unixTimeUrl(@NonNull OffsetDateTime unixTimeUrlPath) {
        unixTimeUrlAsync(unixTimeUrlPath).blockingAwait();
    }

    /**
     * Get the date 2016-04-13 encoded value as '1460505600' (Unix time).
     *
     * @param unixTimeUrlPath Unix time encoded value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> unixTimeUrlAsync(@NonNull OffsetDateTime unixTimeUrlPath, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(unixTimeUrlAsync(unixTimeUrlPath), serviceCallback);
    }

    /**
     * Get the date 2016-04-13 encoded value as '1460505600' (Unix time).
     *
     * @param unixTimeUrlPath Unix time encoded value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> unixTimeUrlWithRestResponseAsync(@NonNull OffsetDateTime unixTimeUrlPath) {
        long unixTimeUrlPathConverted = unixTimeUrlPath.toEpochSecond();
        return service.unixTimeUrl(unixTimeUrlPathConverted);
    }

    /**
     * Get the date 2016-04-13 encoded value as '1460505600' (Unix time).
     *
     * @param unixTimeUrlPath Unix time encoded value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable unixTimeUrlAsync(@NonNull OffsetDateTime unixTimeUrlPath) {
        return unixTimeUrlWithRestResponseAsync(unixTimeUrlPath)
            .ignoreElement();
    }
}
