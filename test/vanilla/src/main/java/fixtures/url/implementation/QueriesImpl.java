/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.url.implementation;

import com.microsoft.rest.v2.CollectionFormat;
import com.microsoft.rest.v2.RestProxy;
import com.microsoft.rest.v2.ServiceCallback;
import com.microsoft.rest.v2.ServiceFuture;
import com.microsoft.rest.v2.Validator;
import com.microsoft.rest.v2.VoidResponse;
import com.microsoft.rest.v2.annotations.ExpectedResponses;
import com.microsoft.rest.v2.annotations.GET;
import com.microsoft.rest.v2.annotations.Host;
import com.microsoft.rest.v2.annotations.QueryParam;
import com.microsoft.rest.v2.annotations.UnexpectedResponseExceptionType;
import com.microsoft.rest.v2.util.Base64Util;
import fixtures.url.Queries;
import fixtures.url.models.ErrorException;
import fixtures.url.models.UriColor;
import io.reactivex.Completable;
import io.reactivex.Single;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * An instance of this class provides access to all the operations defined in
 * Queries.
 */
public final class QueriesImpl implements Queries {
    /**
     * The proxy service used to perform REST calls.
     */
    private QueriesService service;

    /**
     * The service client containing this operation class.
     */
    private AutoRestUrlTestServiceImpl client;

    /**
     * Initializes an instance of QueriesImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    public QueriesImpl(AutoRestUrlTestServiceImpl client) {
        this.service = RestProxy.create(QueriesService.class, client);
        this.client = client;
    }

    /**
     * The interface defining all the services for Queries to be used by the
     * proxy service to perform REST calls.
     */
    @Host("http://localhost:3000")
    private interface QueriesService {
        @GET("queries/bool/true")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getBooleanTrue(@QueryParam("boolQuery") boolean boolQuery);

        @GET("queries/bool/false")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getBooleanFalse(@QueryParam("boolQuery") boolean boolQuery);

        @GET("queries/bool/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getBooleanNull(@QueryParam("boolQuery") Boolean boolQuery);

        @GET("queries/int/1000000")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getIntOneMillion(@QueryParam("intQuery") int intQuery);

        @GET("queries/int/-1000000")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getIntNegativeOneMillion(@QueryParam("intQuery") int intQuery);

        @GET("queries/int/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getIntNull(@QueryParam("intQuery") Integer intQuery);

        @GET("queries/long/10000000000")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getTenBillion(@QueryParam("longQuery") long longQuery);

        @GET("queries/long/-10000000000")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getNegativeTenBillion(@QueryParam("longQuery") long longQuery);

        @GET("queries/long/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> getLongNull(@QueryParam("longQuery") Long longQuery);

        @GET("queries/float/1.034E+20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> floatScientificPositive(@QueryParam("floatQuery") double floatQuery);

        @GET("queries/float/-1.034E-20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> floatScientificNegative(@QueryParam("floatQuery") double floatQuery);

        @GET("queries/float/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> floatNull(@QueryParam("floatQuery") Double floatQuery);

        @GET("queries/double/9999999.999")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> doubleDecimalPositive(@QueryParam("doubleQuery") double doubleQuery);

        @GET("queries/double/-9999999.999")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> doubleDecimalNegative(@QueryParam("doubleQuery") double doubleQuery);

        @GET("queries/double/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> doubleNull(@QueryParam("doubleQuery") Double doubleQuery);

        @GET("queries/string/unicode/")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> stringUnicode(@QueryParam("stringQuery") String stringQuery);

        @GET("queries/string/begin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> stringUrlEncoded(@QueryParam("stringQuery") String stringQuery);

        @GET("queries/string/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> stringEmpty(@QueryParam("stringQuery") String stringQuery);

        @GET("queries/string/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> stringNull(@QueryParam("stringQuery") String stringQuery);

        @GET("queries/enum/green%20color")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> enumValid(@QueryParam("enumQuery") UriColor enumQuery);

        @GET("queries/enum/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> enumNull(@QueryParam("enumQuery") UriColor enumQuery);

        @GET("queries/byte/multibyte")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> byteMultiByte(@QueryParam("byteQuery") String byteQuery);

        @GET("queries/byte/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> byteEmpty(@QueryParam("byteQuery") String byteQuery);

        @GET("queries/byte/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> byteNull(@QueryParam("byteQuery") String byteQuery);

        @GET("queries/date/2012-01-01")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> dateValid(@QueryParam("dateQuery") LocalDate dateQuery);

        @GET("queries/date/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> dateNull(@QueryParam("dateQuery") LocalDate dateQuery);

        @GET("queries/datetime/2012-01-01T01%3A01%3A01Z")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> dateTimeValid(@QueryParam("dateTimeQuery") OffsetDateTime dateTimeQuery);

        @GET("queries/datetime/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> dateTimeNull(@QueryParam("dateTimeQuery") OffsetDateTime dateTimeQuery);

        @GET("queries/array/csv/string/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> arrayStringCsvValid(@QueryParam("arrayQuery") String arrayQuery);

        @GET("queries/array/csv/string/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> arrayStringCsvNull(@QueryParam("arrayQuery") String arrayQuery);

        @GET("queries/array/csv/string/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> arrayStringCsvEmpty(@QueryParam("arrayQuery") String arrayQuery);

        @GET("queries/array/ssv/string/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> arrayStringSsvValid(@QueryParam("arrayQuery") String arrayQuery);

        @GET("queries/array/tsv/string/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> arrayStringTsvValid(@QueryParam("arrayQuery") String arrayQuery);

        @GET("queries/array/pipes/string/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> arrayStringPipesValid(@QueryParam("arrayQuery") String arrayQuery);
    }

    /**
     * Get true Boolean value on path.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getBooleanTrue() {
        getBooleanTrueAsync().blockingAwait();
    }

    /**
     * Get true Boolean value on path.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getBooleanTrueAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanTrueAsync(), serviceCallback);
    }

    /**
     * Get true Boolean value on path.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getBooleanTrueWithRestResponseAsync() {
        final boolean boolQuery = true;
        return service.getBooleanTrue(boolQuery);
    }

    /**
     * Get true Boolean value on path.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getBooleanTrueAsync() {
        return getBooleanTrueWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get false Boolean value on path.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getBooleanFalse() {
        getBooleanFalseAsync().blockingAwait();
    }

    /**
     * Get false Boolean value on path.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getBooleanFalseAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanFalseAsync(), serviceCallback);
    }

    /**
     * Get false Boolean value on path.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getBooleanFalseWithRestResponseAsync() {
        final boolean boolQuery = false;
        return service.getBooleanFalse(boolQuery);
    }

    /**
     * Get false Boolean value on path.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getBooleanFalseAsync() {
        return getBooleanFalseWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getBooleanNull() {
        getBooleanNullAsync().blockingAwait();
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getBooleanNullAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanNullAsync(), serviceCallback);
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getBooleanNullWithRestResponseAsync() {
        final Boolean boolQuery = null;
        return service.getBooleanNull(boolQuery);
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getBooleanNullAsync() {
        return getBooleanNullWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @param boolQuery null boolean value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getBooleanNull(Boolean boolQuery) {
        getBooleanNullAsync(boolQuery).blockingAwait();
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @param boolQuery null boolean value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getBooleanNullAsync(Boolean boolQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanNullAsync(boolQuery), serviceCallback);
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @param boolQuery null boolean value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getBooleanNullWithRestResponseAsync(Boolean boolQuery) {
        return service.getBooleanNull(boolQuery);
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @param boolQuery null boolean value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getBooleanNullAsync(Boolean boolQuery) {
        return getBooleanNullWithRestResponseAsync(boolQuery)
            .ignoreElement();
    }

    /**
     * Get '1000000' integer value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getIntOneMillion() {
        getIntOneMillionAsync().blockingAwait();
    }

    /**
     * Get '1000000' integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getIntOneMillionAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getIntOneMillionAsync(), serviceCallback);
    }

    /**
     * Get '1000000' integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getIntOneMillionWithRestResponseAsync() {
        final int intQuery = 1000000;
        return service.getIntOneMillion(intQuery);
    }

    /**
     * Get '1000000' integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getIntOneMillionAsync() {
        return getIntOneMillionWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '-1000000' integer value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getIntNegativeOneMillion() {
        getIntNegativeOneMillionAsync().blockingAwait();
    }

    /**
     * Get '-1000000' integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getIntNegativeOneMillionAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getIntNegativeOneMillionAsync(), serviceCallback);
    }

    /**
     * Get '-1000000' integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getIntNegativeOneMillionWithRestResponseAsync() {
        final int intQuery = -1000000;
        return service.getIntNegativeOneMillion(intQuery);
    }

    /**
     * Get '-1000000' integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getIntNegativeOneMillionAsync() {
        return getIntNegativeOneMillionWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getIntNull() {
        getIntNullAsync().blockingAwait();
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getIntNullAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getIntNullAsync(), serviceCallback);
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getIntNullWithRestResponseAsync() {
        final Integer intQuery = null;
        return service.getIntNull(intQuery);
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getIntNullAsync() {
        return getIntNullWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @param intQuery null integer value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getIntNull(Integer intQuery) {
        getIntNullAsync(intQuery).blockingAwait();
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @param intQuery null integer value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getIntNullAsync(Integer intQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getIntNullAsync(intQuery), serviceCallback);
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @param intQuery null integer value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getIntNullWithRestResponseAsync(Integer intQuery) {
        return service.getIntNull(intQuery);
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @param intQuery null integer value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getIntNullAsync(Integer intQuery) {
        return getIntNullWithRestResponseAsync(intQuery)
            .ignoreElement();
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getTenBillion() {
        getTenBillionAsync().blockingAwait();
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getTenBillionAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getTenBillionAsync(), serviceCallback);
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getTenBillionWithRestResponseAsync() {
        final long longQuery = 10000000000L;
        return service.getTenBillion(longQuery);
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getTenBillionAsync() {
        return getTenBillionWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getNegativeTenBillion() {
        getNegativeTenBillionAsync().blockingAwait();
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getNegativeTenBillionAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getNegativeTenBillionAsync(), serviceCallback);
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getNegativeTenBillionWithRestResponseAsync() {
        final long longQuery = -10000000000L;
        return service.getNegativeTenBillion(longQuery);
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getNegativeTenBillionAsync() {
        return getNegativeTenBillionWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getLongNull() {
        getLongNullAsync().blockingAwait();
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getLongNullAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getLongNullAsync(), serviceCallback);
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getLongNullWithRestResponseAsync() {
        final Long longQuery = null;
        return service.getLongNull(longQuery);
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getLongNullAsync() {
        return getLongNullWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @param longQuery null 64 bit integer value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void getLongNull(Long longQuery) {
        getLongNullAsync(longQuery).blockingAwait();
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @param longQuery null 64 bit integer value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> getLongNullAsync(Long longQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(getLongNullAsync(longQuery), serviceCallback);
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @param longQuery null 64 bit integer value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> getLongNullWithRestResponseAsync(Long longQuery) {
        return service.getLongNull(longQuery);
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @param longQuery null 64 bit integer value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable getLongNullAsync(Long longQuery) {
        return getLongNullWithRestResponseAsync(longQuery)
            .ignoreElement();
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void floatScientificPositive() {
        floatScientificPositiveAsync().blockingAwait();
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> floatScientificPositiveAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(floatScientificPositiveAsync(), serviceCallback);
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> floatScientificPositiveWithRestResponseAsync() {
        final double floatQuery = 1.034E+20;
        return service.floatScientificPositive(floatQuery);
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable floatScientificPositiveAsync() {
        return floatScientificPositiveWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void floatScientificNegative() {
        floatScientificNegativeAsync().blockingAwait();
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> floatScientificNegativeAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(floatScientificNegativeAsync(), serviceCallback);
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> floatScientificNegativeWithRestResponseAsync() {
        final double floatQuery = -1.034E-20;
        return service.floatScientificNegative(floatQuery);
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable floatScientificNegativeAsync() {
        return floatScientificNegativeWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void floatNull() {
        floatNullAsync().blockingAwait();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> floatNullAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(floatNullAsync(), serviceCallback);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> floatNullWithRestResponseAsync() {
        final Double floatQuery = null;
        return service.floatNull(floatQuery);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable floatNullAsync() {
        return floatNullWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param floatQuery null numeric value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void floatNull(Double floatQuery) {
        floatNullAsync(floatQuery).blockingAwait();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param floatQuery null numeric value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> floatNullAsync(Double floatQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(floatNullAsync(floatQuery), serviceCallback);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param floatQuery null numeric value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> floatNullWithRestResponseAsync(Double floatQuery) {
        return service.floatNull(floatQuery);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param floatQuery null numeric value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable floatNullAsync(Double floatQuery) {
        return floatNullWithRestResponseAsync(floatQuery)
            .ignoreElement();
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void doubleDecimalPositive() {
        doubleDecimalPositiveAsync().blockingAwait();
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> doubleDecimalPositiveAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(doubleDecimalPositiveAsync(), serviceCallback);
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> doubleDecimalPositiveWithRestResponseAsync() {
        final double doubleQuery = 9999999.999;
        return service.doubleDecimalPositive(doubleQuery);
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable doubleDecimalPositiveAsync() {
        return doubleDecimalPositiveWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void doubleDecimalNegative() {
        doubleDecimalNegativeAsync().blockingAwait();
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> doubleDecimalNegativeAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(doubleDecimalNegativeAsync(), serviceCallback);
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> doubleDecimalNegativeWithRestResponseAsync() {
        final double doubleQuery = -9999999.999;
        return service.doubleDecimalNegative(doubleQuery);
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable doubleDecimalNegativeAsync() {
        return doubleDecimalNegativeWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void doubleNull() {
        doubleNullAsync().blockingAwait();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> doubleNullAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(doubleNullAsync(), serviceCallback);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> doubleNullWithRestResponseAsync() {
        final Double doubleQuery = null;
        return service.doubleNull(doubleQuery);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable doubleNullAsync() {
        return doubleNullWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param doubleQuery null numeric value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void doubleNull(Double doubleQuery) {
        doubleNullAsync(doubleQuery).blockingAwait();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param doubleQuery null numeric value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> doubleNullAsync(Double doubleQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(doubleNullAsync(doubleQuery), serviceCallback);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param doubleQuery null numeric value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> doubleNullWithRestResponseAsync(Double doubleQuery) {
        return service.doubleNull(doubleQuery);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param doubleQuery null numeric value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable doubleNullAsync(Double doubleQuery) {
        return doubleNullWithRestResponseAsync(doubleQuery)
            .ignoreElement();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void stringUnicode() {
        stringUnicodeAsync().blockingAwait();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> stringUnicodeAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(stringUnicodeAsync(), serviceCallback);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> stringUnicodeWithRestResponseAsync() {
        final String stringQuery = "啊齄丂狛狜隣郎隣兀﨩";
        return service.stringUnicode(stringQuery);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable stringUnicodeAsync() {
        return stringUnicodeWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void stringUrlEncoded() {
        stringUrlEncodedAsync().blockingAwait();
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> stringUrlEncodedAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(stringUrlEncodedAsync(), serviceCallback);
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> stringUrlEncodedWithRestResponseAsync() {
        final String stringQuery = "begin!*'();:@ &=+$,/?#[]end";
        return service.stringUrlEncoded(stringQuery);
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable stringUrlEncodedAsync() {
        return stringUrlEncodedWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get ''.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void stringEmpty() {
        stringEmptyAsync().blockingAwait();
    }

    /**
     * Get ''.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> stringEmptyAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(stringEmptyAsync(), serviceCallback);
    }

    /**
     * Get ''.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> stringEmptyWithRestResponseAsync() {
        final String stringQuery = "";
        return service.stringEmpty(stringQuery);
    }

    /**
     * Get ''.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable stringEmptyAsync() {
        return stringEmptyWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void stringNull() {
        stringNullAsync().blockingAwait();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> stringNullAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(stringNullAsync(), serviceCallback);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> stringNullWithRestResponseAsync() {
        final String stringQuery = null;
        return service.stringNull(stringQuery);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable stringNullAsync() {
        return stringNullWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param stringQuery null string value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void stringNull(String stringQuery) {
        stringNullAsync(stringQuery).blockingAwait();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param stringQuery null string value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> stringNullAsync(String stringQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(stringNullAsync(stringQuery), serviceCallback);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param stringQuery null string value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> stringNullWithRestResponseAsync(String stringQuery) {
        return service.stringNull(stringQuery);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param stringQuery null string value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable stringNullAsync(String stringQuery) {
        return stringNullWithRestResponseAsync(stringQuery)
            .ignoreElement();
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void enumValid() {
        enumValidAsync().blockingAwait();
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> enumValidAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(enumValidAsync(), serviceCallback);
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> enumValidWithRestResponseAsync() {
        final UriColor enumQuery = null;
        return service.enumValid(enumQuery);
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable enumValidAsync() {
        return enumValidWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @param enumQuery 'green color' enum value. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void enumValid(UriColor enumQuery) {
        enumValidAsync(enumQuery).blockingAwait();
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @param enumQuery 'green color' enum value. Possible values include: 'red color', 'green color', 'blue color'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> enumValidAsync(UriColor enumQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(enumValidAsync(enumQuery), serviceCallback);
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @param enumQuery 'green color' enum value. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> enumValidWithRestResponseAsync(UriColor enumQuery) {
        return service.enumValid(enumQuery);
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @param enumQuery 'green color' enum value. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable enumValidAsync(UriColor enumQuery) {
        return enumValidWithRestResponseAsync(enumQuery)
            .ignoreElement();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void enumNull() {
        enumNullAsync().blockingAwait();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> enumNullAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(enumNullAsync(), serviceCallback);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> enumNullWithRestResponseAsync() {
        final UriColor enumQuery = null;
        return service.enumNull(enumQuery);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable enumNullAsync() {
        return enumNullWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param enumQuery null string value. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void enumNull(UriColor enumQuery) {
        enumNullAsync(enumQuery).blockingAwait();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param enumQuery null string value. Possible values include: 'red color', 'green color', 'blue color'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> enumNullAsync(UriColor enumQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(enumNullAsync(enumQuery), serviceCallback);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param enumQuery null string value. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> enumNullWithRestResponseAsync(UriColor enumQuery) {
        return service.enumNull(enumQuery);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param enumQuery null string value. Possible values include: 'red color', 'green color', 'blue color'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable enumNullAsync(UriColor enumQuery) {
        return enumNullWithRestResponseAsync(enumQuery)
            .ignoreElement();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void byteMultiByte() {
        byteMultiByteAsync().blockingAwait();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> byteMultiByteAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(byteMultiByteAsync(), serviceCallback);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> byteMultiByteWithRestResponseAsync() {
        final byte[] byteQuery = new byte[0];
        String byteQueryConverted = Base64Util.encodeToString(byteQuery);
        return service.byteMultiByte(byteQueryConverted);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable byteMultiByteAsync() {
        return byteMultiByteWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param byteQuery '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void byteMultiByte(byte[] byteQuery) {
        byteMultiByteAsync(byteQuery).blockingAwait();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param byteQuery '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> byteMultiByteAsync(byte[] byteQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(byteMultiByteAsync(byteQuery), serviceCallback);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param byteQuery '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> byteMultiByteWithRestResponseAsync(byte[] byteQuery) {
        String byteQueryConverted = Base64Util.encodeToString(byteQuery);
        return service.byteMultiByte(byteQueryConverted);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param byteQuery '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable byteMultiByteAsync(byte[] byteQuery) {
        return byteMultiByteWithRestResponseAsync(byteQuery)
            .ignoreElement();
    }

    /**
     * Get '' as byte array.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void byteEmpty() {
        byteEmptyAsync().blockingAwait();
    }

    /**
     * Get '' as byte array.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> byteEmptyAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(byteEmptyAsync(), serviceCallback);
    }

    /**
     * Get '' as byte array.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> byteEmptyWithRestResponseAsync() {
        final byte[] byteQuery = "".getBytes();
        String byteQueryConverted = Base64Util.encodeToString(byteQuery);
        return service.byteEmpty(byteQueryConverted);
    }

    /**
     * Get '' as byte array.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable byteEmptyAsync() {
        return byteEmptyWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void byteNull() {
        byteNullAsync().blockingAwait();
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> byteNullAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(byteNullAsync(), serviceCallback);
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> byteNullWithRestResponseAsync() {
        final byte[] byteQuery = new byte[0];
        String byteQueryConverted = Base64Util.encodeToString(byteQuery);
        return service.byteNull(byteQueryConverted);
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable byteNullAsync() {
        return byteNullWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @param byteQuery null as byte array (no query parameters in uri).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void byteNull(byte[] byteQuery) {
        byteNullAsync(byteQuery).blockingAwait();
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @param byteQuery null as byte array (no query parameters in uri).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> byteNullAsync(byte[] byteQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(byteNullAsync(byteQuery), serviceCallback);
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @param byteQuery null as byte array (no query parameters in uri).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> byteNullWithRestResponseAsync(byte[] byteQuery) {
        String byteQueryConverted = Base64Util.encodeToString(byteQuery);
        return service.byteNull(byteQueryConverted);
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @param byteQuery null as byte array (no query parameters in uri).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable byteNullAsync(byte[] byteQuery) {
        return byteNullWithRestResponseAsync(byteQuery)
            .ignoreElement();
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void dateValid() {
        dateValidAsync().blockingAwait();
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> dateValidAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(dateValidAsync(), serviceCallback);
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> dateValidWithRestResponseAsync() {
        final LocalDate dateQuery = LocalDate.parse("2012-01-01");
        return service.dateValid(dateQuery);
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable dateValidAsync() {
        return dateValidWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void dateNull() {
        dateNullAsync().blockingAwait();
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> dateNullAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(dateNullAsync(), serviceCallback);
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> dateNullWithRestResponseAsync() {
        final LocalDate dateQuery = null;
        return service.dateNull(dateQuery);
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable dateNullAsync() {
        return dateNullWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @param dateQuery null as date (no query parameters in uri).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void dateNull(LocalDate dateQuery) {
        dateNullAsync(dateQuery).blockingAwait();
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @param dateQuery null as date (no query parameters in uri).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> dateNullAsync(LocalDate dateQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(dateNullAsync(dateQuery), serviceCallback);
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @param dateQuery null as date (no query parameters in uri).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> dateNullWithRestResponseAsync(LocalDate dateQuery) {
        return service.dateNull(dateQuery);
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @param dateQuery null as date (no query parameters in uri).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable dateNullAsync(LocalDate dateQuery) {
        return dateNullWithRestResponseAsync(dateQuery)
            .ignoreElement();
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void dateTimeValid() {
        dateTimeValidAsync().blockingAwait();
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> dateTimeValidAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(dateTimeValidAsync(), serviceCallback);
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> dateTimeValidWithRestResponseAsync() {
        final OffsetDateTime dateTimeQuery = OffsetDateTime.parse("2012-01-01T01:01:01Z");
        return service.dateTimeValid(dateTimeQuery);
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable dateTimeValidAsync() {
        return dateTimeValidWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void dateTimeNull() {
        dateTimeNullAsync().blockingAwait();
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> dateTimeNullAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(dateTimeNullAsync(), serviceCallback);
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> dateTimeNullWithRestResponseAsync() {
        final OffsetDateTime dateTimeQuery = null;
        return service.dateTimeNull(dateTimeQuery);
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable dateTimeNullAsync() {
        return dateTimeNullWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @param dateTimeQuery null as date-time (no query parameters).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void dateTimeNull(OffsetDateTime dateTimeQuery) {
        dateTimeNullAsync(dateTimeQuery).blockingAwait();
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @param dateTimeQuery null as date-time (no query parameters).
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> dateTimeNullAsync(OffsetDateTime dateTimeQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(dateTimeNullAsync(dateTimeQuery), serviceCallback);
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @param dateTimeQuery null as date-time (no query parameters).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> dateTimeNullWithRestResponseAsync(OffsetDateTime dateTimeQuery) {
        return service.dateTimeNull(dateTimeQuery);
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @param dateTimeQuery null as date-time (no query parameters).
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable dateTimeNullAsync(OffsetDateTime dateTimeQuery) {
        return dateTimeNullWithRestResponseAsync(dateTimeQuery)
            .ignoreElement();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringCsvValid() {
        arrayStringCsvValidAsync().blockingAwait();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringCsvValidAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringCsvValidAsync(), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringCsvValidWithRestResponseAsync() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvValid(arrayQueryConverted);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringCsvValidAsync() {
        return arrayStringCsvValidWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringCsvValid(List<String> arrayQuery) {
        arrayStringCsvValidAsync(arrayQuery).blockingAwait();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringCsvValidAsync(List<String> arrayQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringCsvValidAsync(arrayQuery), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringCsvValidWithRestResponseAsync(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvValid(arrayQueryConverted);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringCsvValidAsync(List<String> arrayQuery) {
        return arrayStringCsvValidWithRestResponseAsync(arrayQuery)
            .ignoreElement();
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringCsvNull() {
        arrayStringCsvNullAsync().blockingAwait();
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringCsvNullAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringCsvNullAsync(), serviceCallback);
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringCsvNullWithRestResponseAsync() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvNull(arrayQueryConverted);
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringCsvNullAsync() {
        return arrayStringCsvNullWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @param arrayQuery a null array of string using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringCsvNull(List<String> arrayQuery) {
        arrayStringCsvNullAsync(arrayQuery).blockingAwait();
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @param arrayQuery a null array of string using the csv-array format.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringCsvNullAsync(List<String> arrayQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringCsvNullAsync(arrayQuery), serviceCallback);
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @param arrayQuery a null array of string using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringCsvNullWithRestResponseAsync(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvNull(arrayQueryConverted);
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @param arrayQuery a null array of string using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringCsvNullAsync(List<String> arrayQuery) {
        return arrayStringCsvNullWithRestResponseAsync(arrayQuery)
            .ignoreElement();
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringCsvEmpty() {
        arrayStringCsvEmptyAsync().blockingAwait();
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringCsvEmptyAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringCsvEmptyAsync(), serviceCallback);
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringCsvEmptyWithRestResponseAsync() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvEmpty(arrayQueryConverted);
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringCsvEmptyAsync() {
        return arrayStringCsvEmptyWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @param arrayQuery an empty array [] of string using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringCsvEmpty(List<String> arrayQuery) {
        arrayStringCsvEmptyAsync(arrayQuery).blockingAwait();
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @param arrayQuery an empty array [] of string using the csv-array format.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringCsvEmptyAsync(List<String> arrayQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringCsvEmptyAsync(arrayQuery), serviceCallback);
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @param arrayQuery an empty array [] of string using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringCsvEmptyWithRestResponseAsync(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvEmpty(arrayQueryConverted);
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @param arrayQuery an empty array [] of string using the csv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringCsvEmptyAsync(List<String> arrayQuery) {
        return arrayStringCsvEmptyWithRestResponseAsync(arrayQuery)
            .ignoreElement();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringSsvValid() {
        arrayStringSsvValidAsync().blockingAwait();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringSsvValidAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringSsvValidAsync(), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringSsvValidWithRestResponseAsync() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.SSV);
        return service.arrayStringSsvValid(arrayQueryConverted);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringSsvValidAsync() {
        return arrayStringSsvValidWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringSsvValid(List<String> arrayQuery) {
        arrayStringSsvValidAsync(arrayQuery).blockingAwait();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringSsvValidAsync(List<String> arrayQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringSsvValidAsync(arrayQuery), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringSsvValidWithRestResponseAsync(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.SSV);
        return service.arrayStringSsvValid(arrayQueryConverted);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringSsvValidAsync(List<String> arrayQuery) {
        return arrayStringSsvValidWithRestResponseAsync(arrayQuery)
            .ignoreElement();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringTsvValid() {
        arrayStringTsvValidAsync().blockingAwait();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringTsvValidAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringTsvValidAsync(), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringTsvValidWithRestResponseAsync() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.TSV);
        return service.arrayStringTsvValid(arrayQueryConverted);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringTsvValidAsync() {
        return arrayStringTsvValidWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringTsvValid(List<String> arrayQuery) {
        arrayStringTsvValidAsync(arrayQuery).blockingAwait();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringTsvValidAsync(List<String> arrayQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringTsvValidAsync(arrayQuery), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringTsvValidWithRestResponseAsync(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.TSV);
        return service.arrayStringTsvValid(arrayQueryConverted);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringTsvValidAsync(List<String> arrayQuery) {
        return arrayStringTsvValidWithRestResponseAsync(arrayQuery)
            .ignoreElement();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringPipesValid() {
        arrayStringPipesValidAsync().blockingAwait();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringPipesValidAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringPipesValidAsync(), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringPipesValidWithRestResponseAsync() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.PIPES);
        return service.arrayStringPipesValid(arrayQueryConverted);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringPipesValidAsync() {
        return arrayStringPipesValidWithRestResponseAsync()
            .ignoreElement();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void arrayStringPipesValid(List<String> arrayQuery) {
        arrayStringPipesValidAsync(arrayQuery).blockingAwait();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> arrayStringPipesValidAsync(List<String> arrayQuery, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(arrayStringPipesValidAsync(arrayQuery), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> arrayStringPipesValidWithRestResponseAsync(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.serializerAdapter().serializeList(arrayQuery, CollectionFormat.PIPES);
        return service.arrayStringPipesValid(arrayQueryConverted);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable arrayStringPipesValidAsync(List<String> arrayQuery) {
        return arrayStringPipesValidWithRestResponseAsync(arrayQuery)
            .ignoreElement();
    }
}
