/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.bodydictionary.implementation;

import com.microsoft.rest.RestProxy;
import com.microsoft.rest.RestResponse;
import fixtures.bodydictionary.Dictionarys;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.annotations.BodyParam;
import com.microsoft.rest.annotations.ExpectedResponses;
import com.microsoft.rest.annotations.GET;
import com.microsoft.rest.annotations.Headers;
import com.microsoft.rest.annotations.Host;
import com.microsoft.rest.annotations.PUT;
import com.microsoft.rest.annotations.ReturnValueWireType;
import com.microsoft.rest.annotations.UnexpectedResponseExceptionType;
import com.microsoft.rest.Base64Url;
import com.microsoft.rest.DateTimeRfc1123;
import com.microsoft.rest.http.HttpClient;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.Validator;
import fixtures.bodydictionary.models.ErrorException;
import fixtures.bodydictionary.models.Widget;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.joda.time.Period;
import rx.functions.Func1;
import rx.Observable;
import rx.Single;

/**
 * An instance of this class provides access to all the operations defined
 * in Dictionarys.
 */
public class DictionarysImpl implements Dictionarys {
    /** The RestProxy service to perform REST calls. */
    private DictionarysService service;
    /** The service client containing this operation class. */
    private AutoRestSwaggerBATdictionaryServiceImpl client;

    /**
     * Initializes an instance of Dictionarys.
     *
     * @param client the instance of the service client containing this operation class.
     */
    public DictionarysImpl(AutoRestSwaggerBATdictionaryServiceImpl client) {
        this.service = RestProxy.create(DictionarysService.class, client.restClient().baseURL(), client.httpClient(), client.serializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for Dictionarys to be
     * used by RestProxy to perform REST calls.
    */
    @Host("http://localhost")
    interface DictionarysService {
        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getNull" })
        @GET("dictionary/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Integer>>> getNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getEmpty" })
        @GET("dictionary/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Integer>>> getEmpty();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putEmpty" })
        @PUT("dictionary/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putEmpty(@BodyParam("application/json; charset=utf-8") Map<String, String> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getNullValue" })
        @GET("dictionary/nullvalue")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, String>>> getNullValue();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getNullKey" })
        @GET("dictionary/nullkey")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, String>>> getNullKey();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getEmptyStringKey" })
        @GET("dictionary/keyemptystring")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, String>>> getEmptyStringKey();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getInvalid" })
        @GET("dictionary/invalid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, String>>> getInvalid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getBooleanTfft" })
        @GET("dictionary/prim/boolean/tfft")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Boolean>>> getBooleanTfft();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putBooleanTfft" })
        @PUT("dictionary/prim/boolean/tfft")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putBooleanTfft(@BodyParam("application/json; charset=utf-8") Map<String, Boolean> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getBooleanInvalidNull" })
        @GET("dictionary/prim/boolean/true.null.false")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Boolean>>> getBooleanInvalidNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getBooleanInvalidString" })
        @GET("dictionary/prim/boolean/true.boolean.false")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Boolean>>> getBooleanInvalidString();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getIntegerValid" })
        @GET("dictionary/prim/integer/1.-1.3.300")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Integer>>> getIntegerValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putIntegerValid" })
        @PUT("dictionary/prim/integer/1.-1.3.300")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putIntegerValid(@BodyParam("application/json; charset=utf-8") Map<String, Integer> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getIntInvalidNull" })
        @GET("dictionary/prim/integer/1.null.zero")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Integer>>> getIntInvalidNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getIntInvalidString" })
        @GET("dictionary/prim/integer/1.integer.0")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Integer>>> getIntInvalidString();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getLongValid" })
        @GET("dictionary/prim/long/1.-1.3.300")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Long>>> getLongValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putLongValid" })
        @PUT("dictionary/prim/long/1.-1.3.300")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putLongValid(@BodyParam("application/json; charset=utf-8") Map<String, Long> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getLongInvalidNull" })
        @GET("dictionary/prim/long/1.null.zero")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Long>>> getLongInvalidNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getLongInvalidString" })
        @GET("dictionary/prim/long/1.integer.0")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Long>>> getLongInvalidString();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getFloatValid" })
        @GET("dictionary/prim/float/0--0.01-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Double>>> getFloatValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putFloatValid" })
        @PUT("dictionary/prim/float/0--0.01-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putFloatValid(@BodyParam("application/json; charset=utf-8") Map<String, Double> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getFloatInvalidNull" })
        @GET("dictionary/prim/float/0.0-null-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Double>>> getFloatInvalidNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getFloatInvalidString" })
        @GET("dictionary/prim/float/1.number.0")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Double>>> getFloatInvalidString();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDoubleValid" })
        @GET("dictionary/prim/double/0--0.01-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Double>>> getDoubleValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putDoubleValid" })
        @PUT("dictionary/prim/double/0--0.01-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putDoubleValid(@BodyParam("application/json; charset=utf-8") Map<String, Double> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDoubleInvalidNull" })
        @GET("dictionary/prim/double/0.0-null-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Double>>> getDoubleInvalidNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDoubleInvalidString" })
        @GET("dictionary/prim/double/1.number.0")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Double>>> getDoubleInvalidString();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getStringValid" })
        @GET("dictionary/prim/string/foo1.foo2.foo3")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, String>>> getStringValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putStringValid" })
        @PUT("dictionary/prim/string/foo1.foo2.foo3")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putStringValid(@BodyParam("application/json; charset=utf-8") Map<String, String> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getStringWithNull" })
        @GET("dictionary/prim/string/foo.null.foo2")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, String>>> getStringWithNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getStringWithInvalid" })
        @GET("dictionary/prim/string/foo.123.foo2")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, String>>> getStringWithInvalid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDateValid" })
        @GET("dictionary/prim/date/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, LocalDate>>> getDateValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putDateValid" })
        @PUT("dictionary/prim/date/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putDateValid(@BodyParam("application/json; charset=utf-8") Map<String, LocalDate> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDateInvalidNull" })
        @GET("dictionary/prim/date/invalidnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, LocalDate>>> getDateInvalidNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDateInvalidChars" })
        @GET("dictionary/prim/date/invalidchars")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, LocalDate>>> getDateInvalidChars();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDateTimeValid" })
        @GET("dictionary/prim/date-time/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, DateTime>>> getDateTimeValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putDateTimeValid" })
        @PUT("dictionary/prim/date-time/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putDateTimeValid(@BodyParam("application/json; charset=utf-8") Map<String, DateTime> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDateTimeInvalidNull" })
        @GET("dictionary/prim/date-time/invalidnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, DateTime>>> getDateTimeInvalidNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDateTimeInvalidChars" })
        @GET("dictionary/prim/date-time/invalidchars")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, DateTime>>> getDateTimeInvalidChars();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDateTimeRfc1123Valid" })
        @GET("dictionary/prim/date-time-rfc1123/valid")
        @ExpectedResponses({200})
        @ReturnValueWireType(DateTimeRfc1123.class)
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, DateTime>>> getDateTimeRfc1123Valid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putDateTimeRfc1123Valid" })
        @PUT("dictionary/prim/date-time-rfc1123/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putDateTimeRfc1123Valid(@BodyParam("application/json; charset=utf-8") Map<String, DateTimeRfc1123> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDurationValid" })
        @GET("dictionary/prim/duration/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Period>>> getDurationValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putDurationValid" })
        @PUT("dictionary/prim/duration/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putDurationValid(@BodyParam("application/json; charset=utf-8") Map<String, Period> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getByteValid" })
        @GET("dictionary/prim/byte/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, byte[]>>> getByteValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putByteValid" })
        @PUT("dictionary/prim/byte/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putByteValid(@BodyParam("application/json; charset=utf-8") Map<String, byte[]> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getByteInvalidNull" })
        @GET("dictionary/prim/byte/invalidnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, byte[]>>> getByteInvalidNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getBase64Url" })
        @GET("dictionary/prim/base64url/valid")
        @ExpectedResponses({200})
        @ReturnValueWireType(Base64Url.class)
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, byte[]>>> getBase64Url();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getComplexNull" })
        @GET("dictionary/complex/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Widget>>> getComplexNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getComplexEmpty" })
        @GET("dictionary/complex/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Widget>>> getComplexEmpty();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getComplexItemNull" })
        @GET("dictionary/complex/itemnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Widget>>> getComplexItemNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getComplexItemEmpty" })
        @GET("dictionary/complex/itemempty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Widget>>> getComplexItemEmpty();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getComplexValid" })
        @GET("dictionary/complex/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Widget>>> getComplexValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putComplexValid" })
        @PUT("dictionary/complex/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putComplexValid(@BodyParam("application/json; charset=utf-8") Map<String, Widget> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getArrayNull" })
        @GET("dictionary/array/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, List<String>>>> getArrayNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getArrayEmpty" })
        @GET("dictionary/array/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, List<String>>>> getArrayEmpty();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getArrayItemNull" })
        @GET("dictionary/array/itemnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, List<String>>>> getArrayItemNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getArrayItemEmpty" })
        @GET("dictionary/array/itemempty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, List<String>>>> getArrayItemEmpty();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getArrayValid" })
        @GET("dictionary/array/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, List<String>>>> getArrayValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putArrayValid" })
        @PUT("dictionary/array/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putArrayValid(@BodyParam("application/json; charset=utf-8") Map<String, List<String>> arrayBody);

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDictionaryNull" })
        @GET("dictionary/dictionary/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Map<String, String>>>> getDictionaryNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDictionaryEmpty" })
        @GET("dictionary/dictionary/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Map<String, String>>>> getDictionaryEmpty();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDictionaryItemNull" })
        @GET("dictionary/dictionary/itemnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Map<String, String>>>> getDictionaryItemNull();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDictionaryItemEmpty" })
        @GET("dictionary/dictionary/itemempty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Map<String, String>>>> getDictionaryItemEmpty();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys getDictionaryValid" })
        @GET("dictionary/dictionary/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Map<String, Map<String, String>>>> getDictionaryValid();

        @Headers({ "x-ms-logging-context: fixtures.bodydictionary.Dictionarys putDictionaryValid" })
        @PUT("dictionary/dictionary/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<RestResponse<Void, Void>> putDictionaryValid(@BodyParam("application/json; charset=utf-8") Map<String, Map<String, String>> arrayBody);

    }

    /**
     * Get null dictionary value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Integer&gt; object if successful.
     */
    public Map<String, Integer> getNull() {
        return getNullAsync().toBlocking().value();
    }

    /**
     * Get null dictionary value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Integer>> getNullAsync(ServiceCallback<Map<String, Integer>> serviceCallback) {
        return ServiceFuture.fromBody(getNullAsync(), serviceCallback);
    }

    /**
     * Get null dictionary value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Integer>> object
     */
    public Single<RestResponse<Void, Map<String, Integer>>> getNullWithRestResponseAsync() {
        return service.getNull();
    }

    /**
     * Get null dictionary value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Integer>> object
     */
    public Single<Map<String, Integer>> getNullAsync() {
        return getNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Integer>>, Map<String, Integer>>() { public Map<String, Integer> call(RestResponse<Void, Map<String, Integer>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get empty dictionary value {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Integer&gt; object if successful.
     */
    public Map<String, Integer> getEmpty() {
        return getEmptyAsync().toBlocking().value();
    }

    /**
     * Get empty dictionary value {}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Integer>> getEmptyAsync(ServiceCallback<Map<String, Integer>> serviceCallback) {
        return ServiceFuture.fromBody(getEmptyAsync(), serviceCallback);
    }

    /**
     * Get empty dictionary value {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Integer>> object
     */
    public Single<RestResponse<Void, Map<String, Integer>>> getEmptyWithRestResponseAsync() {
        return service.getEmpty();
    }

    /**
     * Get empty dictionary value {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Integer>> object
     */
    public Single<Map<String, Integer>> getEmptyAsync() {
        return getEmptyWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Integer>>, Map<String, Integer>>() { public Map<String, Integer> call(RestResponse<Void, Map<String, Integer>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Set dictionary value empty {}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putEmpty(Map<String, String> arrayBody) {
        putEmptyAsync(arrayBody).toBlocking().value();
    }

    /**
     * Set dictionary value empty {}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putEmptyAsync(Map<String, String> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putEmptyAsync(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value empty {}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putEmptyWithRestResponseAsync(Map<String, String> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putEmpty(arrayBody);
    }

    /**
     * Set dictionary value empty {}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putEmptyAsync(Map<String, String> arrayBody) {
        return putEmptyWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get Dictionary with null value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, String&gt; object if successful.
     */
    public Map<String, String> getNullValue() {
        return getNullValueAsync().toBlocking().value();
    }

    /**
     * Get Dictionary with null value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, String>> getNullValueAsync(ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceFuture.fromBody(getNullValueAsync(), serviceCallback);
    }

    /**
     * Get Dictionary with null value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<RestResponse<Void, Map<String, String>>> getNullValueWithRestResponseAsync() {
        return service.getNullValue();
    }

    /**
     * Get Dictionary with null value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<Map<String, String>> getNullValueAsync() {
        return getNullValueWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, String>>, Map<String, String>>() { public Map<String, String> call(RestResponse<Void, Map<String, String>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get Dictionary with null key.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, String&gt; object if successful.
     */
    public Map<String, String> getNullKey() {
        return getNullKeyAsync().toBlocking().value();
    }

    /**
     * Get Dictionary with null key.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, String>> getNullKeyAsync(ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceFuture.fromBody(getNullKeyAsync(), serviceCallback);
    }

    /**
     * Get Dictionary with null key.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<RestResponse<Void, Map<String, String>>> getNullKeyWithRestResponseAsync() {
        return service.getNullKey();
    }

    /**
     * Get Dictionary with null key.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<Map<String, String>> getNullKeyAsync() {
        return getNullKeyWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, String>>, Map<String, String>>() { public Map<String, String> call(RestResponse<Void, Map<String, String>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get Dictionary with key as empty string.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, String&gt; object if successful.
     */
    public Map<String, String> getEmptyStringKey() {
        return getEmptyStringKeyAsync().toBlocking().value();
    }

    /**
     * Get Dictionary with key as empty string.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, String>> getEmptyStringKeyAsync(ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceFuture.fromBody(getEmptyStringKeyAsync(), serviceCallback);
    }

    /**
     * Get Dictionary with key as empty string.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<RestResponse<Void, Map<String, String>>> getEmptyStringKeyWithRestResponseAsync() {
        return service.getEmptyStringKey();
    }

    /**
     * Get Dictionary with key as empty string.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<Map<String, String>> getEmptyStringKeyAsync() {
        return getEmptyStringKeyWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, String>>, Map<String, String>>() { public Map<String, String> call(RestResponse<Void, Map<String, String>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get invalid Dictionary value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, String&gt; object if successful.
     */
    public Map<String, String> getInvalid() {
        return getInvalidAsync().toBlocking().value();
    }

    /**
     * Get invalid Dictionary value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, String>> getInvalidAsync(ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceFuture.fromBody(getInvalidAsync(), serviceCallback);
    }

    /**
     * Get invalid Dictionary value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<RestResponse<Void, Map<String, String>>> getInvalidWithRestResponseAsync() {
        return service.getInvalid();
    }

    /**
     * Get invalid Dictionary value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<Map<String, String>> getInvalidAsync() {
        return getInvalidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, String>>, Map<String, String>>() { public Map<String, String> call(RestResponse<Void, Map<String, String>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Boolean&gt; object if successful.
     */
    public Map<String, Boolean> getBooleanTfft() {
        return getBooleanTfftAsync().toBlocking().value();
    }

    /**
     * Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Boolean>> getBooleanTfftAsync(ServiceCallback<Map<String, Boolean>> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanTfftAsync(), serviceCallback);
    }

    /**
     * Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Boolean>> object
     */
    public Single<RestResponse<Void, Map<String, Boolean>>> getBooleanTfftWithRestResponseAsync() {
        return service.getBooleanTfft();
    }

    /**
     * Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Boolean>> object
     */
    public Single<Map<String, Boolean>> getBooleanTfftAsync() {
        return getBooleanTfftWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Boolean>>, Map<String, Boolean>>() { public Map<String, Boolean> call(RestResponse<Void, Map<String, Boolean>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }.
     *
     * @param arrayBody the Map&lt;String, Boolean&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putBooleanTfft(Map<String, Boolean> arrayBody) {
        putBooleanTfftAsync(arrayBody).toBlocking().value();
    }

    /**
     * Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }.
     *
     * @param arrayBody the Map&lt;String, Boolean&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putBooleanTfftAsync(Map<String, Boolean> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putBooleanTfftAsync(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }.
     *
     * @param arrayBody the Map&lt;String, Boolean&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putBooleanTfftWithRestResponseAsync(Map<String, Boolean> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putBooleanTfft(arrayBody);
    }

    /**
     * Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }.
     *
     * @param arrayBody the Map&lt;String, Boolean&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putBooleanTfftAsync(Map<String, Boolean> arrayBody) {
        return putBooleanTfftWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get boolean dictionary value {"0": true, "1": null, "2": false }.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Boolean&gt; object if successful.
     */
    public Map<String, Boolean> getBooleanInvalidNull() {
        return getBooleanInvalidNullAsync().toBlocking().value();
    }

    /**
     * Get boolean dictionary value {"0": true, "1": null, "2": false }.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Boolean>> getBooleanInvalidNullAsync(ServiceCallback<Map<String, Boolean>> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get boolean dictionary value {"0": true, "1": null, "2": false }.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Boolean>> object
     */
    public Single<RestResponse<Void, Map<String, Boolean>>> getBooleanInvalidNullWithRestResponseAsync() {
        return service.getBooleanInvalidNull();
    }

    /**
     * Get boolean dictionary value {"0": true, "1": null, "2": false }.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Boolean>> object
     */
    public Single<Map<String, Boolean>> getBooleanInvalidNullAsync() {
        return getBooleanInvalidNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Boolean>>, Map<String, Boolean>>() { public Map<String, Boolean> call(RestResponse<Void, Map<String, Boolean>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Boolean&gt; object if successful.
     */
    public Map<String, Boolean> getBooleanInvalidString() {
        return getBooleanInvalidStringAsync().toBlocking().value();
    }

    /**
     * Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Boolean>> getBooleanInvalidStringAsync(ServiceCallback<Map<String, Boolean>> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanInvalidStringAsync(), serviceCallback);
    }

    /**
     * Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Boolean>> object
     */
    public Single<RestResponse<Void, Map<String, Boolean>>> getBooleanInvalidStringWithRestResponseAsync() {
        return service.getBooleanInvalidString();
    }

    /**
     * Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Boolean>> object
     */
    public Single<Map<String, Boolean>> getBooleanInvalidStringAsync() {
        return getBooleanInvalidStringWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Boolean>>, Map<String, Boolean>>() { public Map<String, Boolean> call(RestResponse<Void, Map<String, Boolean>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Integer&gt; object if successful.
     */
    public Map<String, Integer> getIntegerValid() {
        return getIntegerValidAsync().toBlocking().value();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Integer>> getIntegerValidAsync(ServiceCallback<Map<String, Integer>> serviceCallback) {
        return ServiceFuture.fromBody(getIntegerValidAsync(), serviceCallback);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Integer>> object
     */
    public Single<RestResponse<Void, Map<String, Integer>>> getIntegerValidWithRestResponseAsync() {
        return service.getIntegerValid();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Integer>> object
     */
    public Single<Map<String, Integer>> getIntegerValidAsync() {
        return getIntegerValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Integer>>, Map<String, Integer>>() { public Map<String, Integer> call(RestResponse<Void, Map<String, Integer>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Integer&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putIntegerValid(Map<String, Integer> arrayBody) {
        putIntegerValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Integer&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putIntegerValidAsync(Map<String, Integer> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putIntegerValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Integer&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putIntegerValidWithRestResponseAsync(Map<String, Integer> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putIntegerValid(arrayBody);
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Integer&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putIntegerValidAsync(Map<String, Integer> arrayBody) {
        return putIntegerValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get integer dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Integer&gt; object if successful.
     */
    public Map<String, Integer> getIntInvalidNull() {
        return getIntInvalidNullAsync().toBlocking().value();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Integer>> getIntInvalidNullAsync(ServiceCallback<Map<String, Integer>> serviceCallback) {
        return ServiceFuture.fromBody(getIntInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Integer>> object
     */
    public Single<RestResponse<Void, Map<String, Integer>>> getIntInvalidNullWithRestResponseAsync() {
        return service.getIntInvalidNull();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Integer>> object
     */
    public Single<Map<String, Integer>> getIntInvalidNullAsync() {
        return getIntInvalidNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Integer>>, Map<String, Integer>>() { public Map<String, Integer> call(RestResponse<Void, Map<String, Integer>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get integer dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Integer&gt; object if successful.
     */
    public Map<String, Integer> getIntInvalidString() {
        return getIntInvalidStringAsync().toBlocking().value();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Integer>> getIntInvalidStringAsync(ServiceCallback<Map<String, Integer>> serviceCallback) {
        return ServiceFuture.fromBody(getIntInvalidStringAsync(), serviceCallback);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Integer>> object
     */
    public Single<RestResponse<Void, Map<String, Integer>>> getIntInvalidStringWithRestResponseAsync() {
        return service.getIntInvalidString();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Integer>> object
     */
    public Single<Map<String, Integer>> getIntInvalidStringAsync() {
        return getIntInvalidStringWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Integer>>, Map<String, Integer>>() { public Map<String, Integer> call(RestResponse<Void, Map<String, Integer>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Long&gt; object if successful.
     */
    public Map<String, Long> getLongValid() {
        return getLongValidAsync().toBlocking().value();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Long>> getLongValidAsync(ServiceCallback<Map<String, Long>> serviceCallback) {
        return ServiceFuture.fromBody(getLongValidAsync(), serviceCallback);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Long>> object
     */
    public Single<RestResponse<Void, Map<String, Long>>> getLongValidWithRestResponseAsync() {
        return service.getLongValid();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Long>> object
     */
    public Single<Map<String, Long>> getLongValidAsync() {
        return getLongValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Long>>, Map<String, Long>>() { public Map<String, Long> call(RestResponse<Void, Map<String, Long>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Long&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putLongValid(Map<String, Long> arrayBody) {
        putLongValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Long&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putLongValidAsync(Map<String, Long> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putLongValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Long&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putLongValidWithRestResponseAsync(Map<String, Long> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putLongValid(arrayBody);
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Long&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putLongValidAsync(Map<String, Long> arrayBody) {
        return putLongValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get long dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Long&gt; object if successful.
     */
    public Map<String, Long> getLongInvalidNull() {
        return getLongInvalidNullAsync().toBlocking().value();
    }

    /**
     * Get long dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Long>> getLongInvalidNullAsync(ServiceCallback<Map<String, Long>> serviceCallback) {
        return ServiceFuture.fromBody(getLongInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get long dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Long>> object
     */
    public Single<RestResponse<Void, Map<String, Long>>> getLongInvalidNullWithRestResponseAsync() {
        return service.getLongInvalidNull();
    }

    /**
     * Get long dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Long>> object
     */
    public Single<Map<String, Long>> getLongInvalidNullAsync() {
        return getLongInvalidNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Long>>, Map<String, Long>>() { public Map<String, Long> call(RestResponse<Void, Map<String, Long>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get long dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Long&gt; object if successful.
     */
    public Map<String, Long> getLongInvalidString() {
        return getLongInvalidStringAsync().toBlocking().value();
    }

    /**
     * Get long dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Long>> getLongInvalidStringAsync(ServiceCallback<Map<String, Long>> serviceCallback) {
        return ServiceFuture.fromBody(getLongInvalidStringAsync(), serviceCallback);
    }

    /**
     * Get long dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Long>> object
     */
    public Single<RestResponse<Void, Map<String, Long>>> getLongInvalidStringWithRestResponseAsync() {
        return service.getLongInvalidString();
    }

    /**
     * Get long dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Long>> object
     */
    public Single<Map<String, Long>> getLongInvalidStringAsync() {
        return getLongInvalidStringWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Long>>, Map<String, Long>>() { public Map<String, Long> call(RestResponse<Void, Map<String, Long>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Double&gt; object if successful.
     */
    public Map<String, Double> getFloatValid() {
        return getFloatValidAsync().toBlocking().value();
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Double>> getFloatValidAsync(ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceFuture.fromBody(getFloatValidAsync(), serviceCallback);
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<RestResponse<Void, Map<String, Double>>> getFloatValidWithRestResponseAsync() {
        return service.getFloatValid();
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<Map<String, Double>> getFloatValidAsync() {
        return getFloatValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Double>>, Map<String, Double>>() { public Map<String, Double> call(RestResponse<Void, Map<String, Double>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putFloatValid(Map<String, Double> arrayBody) {
        putFloatValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putFloatValidAsync(Map<String, Double> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putFloatValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putFloatValidWithRestResponseAsync(Map<String, Double> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putFloatValid(arrayBody);
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putFloatValidAsync(Map<String, Double> arrayBody) {
        return putFloatValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Double&gt; object if successful.
     */
    public Map<String, Double> getFloatInvalidNull() {
        return getFloatInvalidNullAsync().toBlocking().value();
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Double>> getFloatInvalidNullAsync(ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceFuture.fromBody(getFloatInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<RestResponse<Void, Map<String, Double>>> getFloatInvalidNullWithRestResponseAsync() {
        return service.getFloatInvalidNull();
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<Map<String, Double>> getFloatInvalidNullAsync() {
        return getFloatInvalidNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Double>>, Map<String, Double>>() { public Map<String, Double> call(RestResponse<Void, Map<String, Double>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Double&gt; object if successful.
     */
    public Map<String, Double> getFloatInvalidString() {
        return getFloatInvalidStringAsync().toBlocking().value();
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Double>> getFloatInvalidStringAsync(ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceFuture.fromBody(getFloatInvalidStringAsync(), serviceCallback);
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<RestResponse<Void, Map<String, Double>>> getFloatInvalidStringWithRestResponseAsync() {
        return service.getFloatInvalidString();
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<Map<String, Double>> getFloatInvalidStringAsync() {
        return getFloatInvalidStringWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Double>>, Map<String, Double>>() { public Map<String, Double> call(RestResponse<Void, Map<String, Double>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Double&gt; object if successful.
     */
    public Map<String, Double> getDoubleValid() {
        return getDoubleValidAsync().toBlocking().value();
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Double>> getDoubleValidAsync(ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceFuture.fromBody(getDoubleValidAsync(), serviceCallback);
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<RestResponse<Void, Map<String, Double>>> getDoubleValidWithRestResponseAsync() {
        return service.getDoubleValid();
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<Map<String, Double>> getDoubleValidAsync() {
        return getDoubleValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Double>>, Map<String, Double>>() { public Map<String, Double> call(RestResponse<Void, Map<String, Double>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putDoubleValid(Map<String, Double> arrayBody) {
        putDoubleValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDoubleValidAsync(Map<String, Double> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDoubleValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putDoubleValidWithRestResponseAsync(Map<String, Double> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDoubleValid(arrayBody);
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putDoubleValidAsync(Map<String, Double> arrayBody) {
        return putDoubleValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Double&gt; object if successful.
     */
    public Map<String, Double> getDoubleInvalidNull() {
        return getDoubleInvalidNullAsync().toBlocking().value();
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Double>> getDoubleInvalidNullAsync(ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceFuture.fromBody(getDoubleInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<RestResponse<Void, Map<String, Double>>> getDoubleInvalidNullWithRestResponseAsync() {
        return service.getDoubleInvalidNull();
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<Map<String, Double>> getDoubleInvalidNullAsync() {
        return getDoubleInvalidNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Double>>, Map<String, Double>>() { public Map<String, Double> call(RestResponse<Void, Map<String, Double>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Double&gt; object if successful.
     */
    public Map<String, Double> getDoubleInvalidString() {
        return getDoubleInvalidStringAsync().toBlocking().value();
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Double>> getDoubleInvalidStringAsync(ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceFuture.fromBody(getDoubleInvalidStringAsync(), serviceCallback);
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<RestResponse<Void, Map<String, Double>>> getDoubleInvalidStringWithRestResponseAsync() {
        return service.getDoubleInvalidString();
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Double>> object
     */
    public Single<Map<String, Double>> getDoubleInvalidStringAsync() {
        return getDoubleInvalidStringWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Double>>, Map<String, Double>>() { public Map<String, Double> call(RestResponse<Void, Map<String, Double>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, String&gt; object if successful.
     */
    public Map<String, String> getStringValid() {
        return getStringValidAsync().toBlocking().value();
    }

    /**
     * Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, String>> getStringValidAsync(ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceFuture.fromBody(getStringValidAsync(), serviceCallback);
    }

    /**
     * Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<RestResponse<Void, Map<String, String>>> getStringValidWithRestResponseAsync() {
        return service.getStringValid();
    }

    /**
     * Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<Map<String, String>> getStringValidAsync() {
        return getStringValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, String>>, Map<String, String>>() { public Map<String, String> call(RestResponse<Void, Map<String, String>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putStringValid(Map<String, String> arrayBody) {
        putStringValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putStringValidAsync(Map<String, String> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putStringValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putStringValidWithRestResponseAsync(Map<String, String> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putStringValid(arrayBody);
    }

    /**
     * Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putStringValidAsync(Map<String, String> arrayBody) {
        return putStringValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, String&gt; object if successful.
     */
    public Map<String, String> getStringWithNull() {
        return getStringWithNullAsync().toBlocking().value();
    }

    /**
     * Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, String>> getStringWithNullAsync(ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceFuture.fromBody(getStringWithNullAsync(), serviceCallback);
    }

    /**
     * Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<RestResponse<Void, Map<String, String>>> getStringWithNullWithRestResponseAsync() {
        return service.getStringWithNull();
    }

    /**
     * Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<Map<String, String>> getStringWithNullAsync() {
        return getStringWithNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, String>>, Map<String, String>>() { public Map<String, String> call(RestResponse<Void, Map<String, String>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, String&gt; object if successful.
     */
    public Map<String, String> getStringWithInvalid() {
        return getStringWithInvalidAsync().toBlocking().value();
    }

    /**
     * Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, String>> getStringWithInvalidAsync(ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceFuture.fromBody(getStringWithInvalidAsync(), serviceCallback);
    }

    /**
     * Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<RestResponse<Void, Map<String, String>>> getStringWithInvalidWithRestResponseAsync() {
        return service.getStringWithInvalid();
    }

    /**
     * Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, String>> object
     */
    public Single<Map<String, String>> getStringWithInvalidAsync() {
        return getStringWithInvalidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, String>>, Map<String, String>>() { public Map<String, String> call(RestResponse<Void, Map<String, String>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, LocalDate&gt; object if successful.
     */
    public Map<String, LocalDate> getDateValid() {
        return getDateValidAsync().toBlocking().value();
    }

    /**
     * Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, LocalDate>> getDateValidAsync(ServiceCallback<Map<String, LocalDate>> serviceCallback) {
        return ServiceFuture.fromBody(getDateValidAsync(), serviceCallback);
    }

    /**
     * Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, LocalDate>> object
     */
    public Single<RestResponse<Void, Map<String, LocalDate>>> getDateValidWithRestResponseAsync() {
        return service.getDateValid();
    }

    /**
     * Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, LocalDate>> object
     */
    public Single<Map<String, LocalDate>> getDateValidAsync() {
        return getDateValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, LocalDate>>, Map<String, LocalDate>>() { public Map<String, LocalDate> call(RestResponse<Void, Map<String, LocalDate>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Set dictionary value  {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @param arrayBody the Map&lt;String, LocalDate&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putDateValid(Map<String, LocalDate> arrayBody) {
        putDateValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Set dictionary value  {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @param arrayBody the Map&lt;String, LocalDate&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDateValidAsync(Map<String, LocalDate> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDateValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value  {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @param arrayBody the Map&lt;String, LocalDate&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putDateValidWithRestResponseAsync(Map<String, LocalDate> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDateValid(arrayBody);
    }

    /**
     * Set dictionary value  {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @param arrayBody the Map&lt;String, LocalDate&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putDateValidAsync(Map<String, LocalDate> arrayBody) {
        return putDateValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, LocalDate&gt; object if successful.
     */
    public Map<String, LocalDate> getDateInvalidNull() {
        return getDateInvalidNullAsync().toBlocking().value();
    }

    /**
     * Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, LocalDate>> getDateInvalidNullAsync(ServiceCallback<Map<String, LocalDate>> serviceCallback) {
        return ServiceFuture.fromBody(getDateInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, LocalDate>> object
     */
    public Single<RestResponse<Void, Map<String, LocalDate>>> getDateInvalidNullWithRestResponseAsync() {
        return service.getDateInvalidNull();
    }

    /**
     * Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, LocalDate>> object
     */
    public Single<Map<String, LocalDate>> getDateInvalidNullAsync() {
        return getDateInvalidNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, LocalDate>>, Map<String, LocalDate>>() { public Map<String, LocalDate> call(RestResponse<Void, Map<String, LocalDate>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get date dictionary value {"0": "2011-03-22", "1": "date"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, LocalDate&gt; object if successful.
     */
    public Map<String, LocalDate> getDateInvalidChars() {
        return getDateInvalidCharsAsync().toBlocking().value();
    }

    /**
     * Get date dictionary value {"0": "2011-03-22", "1": "date"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, LocalDate>> getDateInvalidCharsAsync(ServiceCallback<Map<String, LocalDate>> serviceCallback) {
        return ServiceFuture.fromBody(getDateInvalidCharsAsync(), serviceCallback);
    }

    /**
     * Get date dictionary value {"0": "2011-03-22", "1": "date"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, LocalDate>> object
     */
    public Single<RestResponse<Void, Map<String, LocalDate>>> getDateInvalidCharsWithRestResponseAsync() {
        return service.getDateInvalidChars();
    }

    /**
     * Get date dictionary value {"0": "2011-03-22", "1": "date"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, LocalDate>> object
     */
    public Single<Map<String, LocalDate>> getDateInvalidCharsAsync() {
        return getDateInvalidCharsWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, LocalDate>>, Map<String, LocalDate>>() { public Map<String, LocalDate> call(RestResponse<Void, Map<String, LocalDate>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, DateTime&gt; object if successful.
     */
    public Map<String, DateTime> getDateTimeValid() {
        return getDateTimeValidAsync().toBlocking().value();
    }

    /**
     * Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, DateTime>> getDateTimeValidAsync(ServiceCallback<Map<String, DateTime>> serviceCallback) {
        return ServiceFuture.fromBody(getDateTimeValidAsync(), serviceCallback);
    }

    /**
     * Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, DateTime>> object
     */
    public Single<RestResponse<Void, Map<String, DateTime>>> getDateTimeValidWithRestResponseAsync() {
        return service.getDateTimeValid();
    }

    /**
     * Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, DateTime>> object
     */
    public Single<Map<String, DateTime>> getDateTimeValidAsync() {
        return getDateTimeValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, DateTime>>, Map<String, DateTime>>() { public Map<String, DateTime> call(RestResponse<Void, Map<String, DateTime>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Set dictionary value  {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @param arrayBody the Map&lt;String, DateTime&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putDateTimeValid(Map<String, DateTime> arrayBody) {
        putDateTimeValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Set dictionary value  {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @param arrayBody the Map&lt;String, DateTime&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDateTimeValidAsync(Map<String, DateTime> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDateTimeValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value  {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @param arrayBody the Map&lt;String, DateTime&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putDateTimeValidWithRestResponseAsync(Map<String, DateTime> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDateTimeValid(arrayBody);
    }

    /**
     * Set dictionary value  {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @param arrayBody the Map&lt;String, DateTime&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putDateTimeValidAsync(Map<String, DateTime> arrayBody) {
        return putDateTimeValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, DateTime&gt; object if successful.
     */
    public Map<String, DateTime> getDateTimeInvalidNull() {
        return getDateTimeInvalidNullAsync().toBlocking().value();
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, DateTime>> getDateTimeInvalidNullAsync(ServiceCallback<Map<String, DateTime>> serviceCallback) {
        return ServiceFuture.fromBody(getDateTimeInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, DateTime>> object
     */
    public Single<RestResponse<Void, Map<String, DateTime>>> getDateTimeInvalidNullWithRestResponseAsync() {
        return service.getDateTimeInvalidNull();
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, DateTime>> object
     */
    public Single<Map<String, DateTime>> getDateTimeInvalidNullAsync() {
        return getDateTimeInvalidNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, DateTime>>, Map<String, DateTime>>() { public Map<String, DateTime> call(RestResponse<Void, Map<String, DateTime>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, DateTime&gt; object if successful.
     */
    public Map<String, DateTime> getDateTimeInvalidChars() {
        return getDateTimeInvalidCharsAsync().toBlocking().value();
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, DateTime>> getDateTimeInvalidCharsAsync(ServiceCallback<Map<String, DateTime>> serviceCallback) {
        return ServiceFuture.fromBody(getDateTimeInvalidCharsAsync(), serviceCallback);
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, DateTime>> object
     */
    public Single<RestResponse<Void, Map<String, DateTime>>> getDateTimeInvalidCharsWithRestResponseAsync() {
        return service.getDateTimeInvalidChars();
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, DateTime>> object
     */
    public Single<Map<String, DateTime>> getDateTimeInvalidCharsAsync() {
        return getDateTimeInvalidCharsWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, DateTime>>, Map<String, DateTime>>() { public Map<String, DateTime> call(RestResponse<Void, Map<String, DateTime>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get date-time-rfc1123 dictionary value {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, DateTime&gt; object if successful.
     */
    public Map<String, DateTime> getDateTimeRfc1123Valid() {
        return getDateTimeRfc1123ValidAsync().toBlocking().value();
    }

    /**
     * Get date-time-rfc1123 dictionary value {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, DateTime>> getDateTimeRfc1123ValidAsync(ServiceCallback<Map<String, DateTime>> serviceCallback) {
        return ServiceFuture.fromBody(getDateTimeRfc1123ValidAsync(), serviceCallback);
    }

    /**
     * Get date-time-rfc1123 dictionary value {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, DateTime>> object
     */
    public Single<RestResponse<Void, Map<String, DateTime>>> getDateTimeRfc1123ValidWithRestResponseAsync() {
        return service.getDateTimeRfc1123Valid();
    }

    /**
     * Get date-time-rfc1123 dictionary value {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, DateTime>> object
     */
    public Single<Map<String, DateTime>> getDateTimeRfc1123ValidAsync() {
        return getDateTimeRfc1123ValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, DateTime>>, Map<String, DateTime>>() { public Map<String, DateTime> call(RestResponse<Void, Map<String, DateTime>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Set dictionary value empty {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @param arrayBody the Map&lt;String, DateTimeRfc1123&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putDateTimeRfc1123Valid(Map<String, DateTime> arrayBody) {
        putDateTimeRfc1123ValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Set dictionary value empty {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @param arrayBody the Map&lt;String, DateTimeRfc1123&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDateTimeRfc1123ValidAsync(Map<String, DateTime> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDateTimeRfc1123ValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value empty {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @param arrayBody the Map&lt;String, DateTimeRfc1123&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putDateTimeRfc1123ValidWithRestResponseAsync(Map<String, DateTime> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
    Map<String, DateTimeRfc1123> arrayBodyConverted = new HashMap<String, DateTimeRfc1123>();
    for (Map.Entry<String, DateTime> entry : arrayBody.entrySet()) {
        DateTimeRfc1123 value = new DateTimeRfc1123(entry.getValue());
        arrayBodyConverted.put(entry.getKey(), value);
    }
        return service.putDateTimeRfc1123Valid(arrayBodyConverted);
    }

    /**
     * Set dictionary value empty {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @param arrayBody the Map&lt;String, DateTimeRfc1123&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putDateTimeRfc1123ValidAsync(Map<String, DateTime> arrayBody) {
        return putDateTimeRfc1123ValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get duration dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Period&gt; object if successful.
     */
    public Map<String, Period> getDurationValid() {
        return getDurationValidAsync().toBlocking().value();
    }

    /**
     * Get duration dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Period>> getDurationValidAsync(ServiceCallback<Map<String, Period>> serviceCallback) {
        return ServiceFuture.fromBody(getDurationValidAsync(), serviceCallback);
    }

    /**
     * Get duration dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Period>> object
     */
    public Single<RestResponse<Void, Map<String, Period>>> getDurationValidWithRestResponseAsync() {
        return service.getDurationValid();
    }

    /**
     * Get duration dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Period>> object
     */
    public Single<Map<String, Period>> getDurationValidAsync() {
        return getDurationValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Period>>, Map<String, Period>>() { public Map<String, Period> call(RestResponse<Void, Map<String, Period>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Set dictionary value  {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @param arrayBody the Map&lt;String, Period&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putDurationValid(Map<String, Period> arrayBody) {
        putDurationValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Set dictionary value  {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @param arrayBody the Map&lt;String, Period&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDurationValidAsync(Map<String, Period> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDurationValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value  {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @param arrayBody the Map&lt;String, Period&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putDurationValidWithRestResponseAsync(Map<String, Period> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDurationValid(arrayBody);
    }

    /**
     * Set dictionary value  {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @param arrayBody the Map&lt;String, Period&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putDurationValidAsync(Map<String, Period> arrayBody) {
        return putDurationValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, byte[]&gt; object if successful.
     */
    public Map<String, byte[]> getByteValid() {
        return getByteValidAsync().toBlocking().value();
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, byte[]>> getByteValidAsync(ServiceCallback<Map<String, byte[]>> serviceCallback) {
        return ServiceFuture.fromBody(getByteValidAsync(), serviceCallback);
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, byte[]>> object
     */
    public Single<RestResponse<Void, Map<String, byte[]>>> getByteValidWithRestResponseAsync() {
        return service.getByteValid();
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, byte[]>> object
     */
    public Single<Map<String, byte[]>> getByteValidAsync() {
        return getByteValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, byte[]>>, Map<String, byte[]>>() { public Map<String, byte[]> call(RestResponse<Void, Map<String, byte[]>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64.
     *
     * @param arrayBody the Map&lt;String, byte[]&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putByteValid(Map<String, byte[]> arrayBody) {
        putByteValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64.
     *
     * @param arrayBody the Map&lt;String, byte[]&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putByteValidAsync(Map<String, byte[]> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putByteValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64.
     *
     * @param arrayBody the Map&lt;String, byte[]&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putByteValidWithRestResponseAsync(Map<String, byte[]> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putByteValid(arrayBody);
    }

    /**
     * Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64.
     *
     * @param arrayBody the Map&lt;String, byte[]&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putByteValidAsync(Map<String, byte[]> arrayBody) {
        return putByteValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, byte[]&gt; object if successful.
     */
    public Map<String, byte[]> getByteInvalidNull() {
        return getByteInvalidNullAsync().toBlocking().value();
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, byte[]>> getByteInvalidNullAsync(ServiceCallback<Map<String, byte[]>> serviceCallback) {
        return ServiceFuture.fromBody(getByteInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, byte[]>> object
     */
    public Single<RestResponse<Void, Map<String, byte[]>>> getByteInvalidNullWithRestResponseAsync() {
        return service.getByteInvalidNull();
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, byte[]>> object
     */
    public Single<Map<String, byte[]>> getByteInvalidNullAsync() {
        return getByteInvalidNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, byte[]>>, Map<String, byte[]>>() { public Map<String, byte[]> call(RestResponse<Void, Map<String, byte[]>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get base64url dictionary value {"0": "a string that gets encoded with base64url", "1": "test string", "2": "Lorem ipsum"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, byte[]&gt; object if successful.
     */
    public Map<String, byte[]> getBase64Url() {
        return getBase64UrlAsync().toBlocking().value();
    }

    /**
     * Get base64url dictionary value {"0": "a string that gets encoded with base64url", "1": "test string", "2": "Lorem ipsum"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, byte[]>> getBase64UrlAsync(ServiceCallback<Map<String, byte[]>> serviceCallback) {
        return ServiceFuture.fromBody(getBase64UrlAsync(), serviceCallback);
    }

    /**
     * Get base64url dictionary value {"0": "a string that gets encoded with base64url", "1": "test string", "2": "Lorem ipsum"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, byte[]>> object
     */
    public Single<RestResponse<Void, Map<String, byte[]>>> getBase64UrlWithRestResponseAsync() {
        return service.getBase64Url();
    }

    /**
     * Get base64url dictionary value {"0": "a string that gets encoded with base64url", "1": "test string", "2": "Lorem ipsum"}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, byte[]>> object
     */
    public Single<Map<String, byte[]>> getBase64UrlAsync() {
        return getBase64UrlWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, byte[]>>, Map<String, byte[]>>() { public Map<String, byte[]> call(RestResponse<Void, Map<String, byte[]>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get dictionary of complex type null value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Widget&gt; object if successful.
     */
    public Map<String, Widget> getComplexNull() {
        return getComplexNullAsync().toBlocking().value();
    }

    /**
     * Get dictionary of complex type null value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Widget>> getComplexNullAsync(ServiceCallback<Map<String, Widget>> serviceCallback) {
        return ServiceFuture.fromBody(getComplexNullAsync(), serviceCallback);
    }

    /**
     * Get dictionary of complex type null value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Widget>> object
     */
    public Single<RestResponse<Void, Map<String, Widget>>> getComplexNullWithRestResponseAsync() {
        return service.getComplexNull();
    }

    /**
     * Get dictionary of complex type null value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Widget>> object
     */
    public Single<Map<String, Widget>> getComplexNullAsync() {
        return getComplexNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Widget>>, Map<String, Widget>>() { public Map<String, Widget> call(RestResponse<Void, Map<String, Widget>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get empty dictionary of complex type {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Widget&gt; object if successful.
     */
    public Map<String, Widget> getComplexEmpty() {
        return getComplexEmptyAsync().toBlocking().value();
    }

    /**
     * Get empty dictionary of complex type {}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Widget>> getComplexEmptyAsync(ServiceCallback<Map<String, Widget>> serviceCallback) {
        return ServiceFuture.fromBody(getComplexEmptyAsync(), serviceCallback);
    }

    /**
     * Get empty dictionary of complex type {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Widget>> object
     */
    public Single<RestResponse<Void, Map<String, Widget>>> getComplexEmptyWithRestResponseAsync() {
        return service.getComplexEmpty();
    }

    /**
     * Get empty dictionary of complex type {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Widget>> object
     */
    public Single<Map<String, Widget>> getComplexEmptyAsync() {
        return getComplexEmptyWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Widget>>, Map<String, Widget>>() { public Map<String, Widget> call(RestResponse<Void, Map<String, Widget>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Widget&gt; object if successful.
     */
    public Map<String, Widget> getComplexItemNull() {
        return getComplexItemNullAsync().toBlocking().value();
    }

    /**
     * Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Widget>> getComplexItemNullAsync(ServiceCallback<Map<String, Widget>> serviceCallback) {
        return ServiceFuture.fromBody(getComplexItemNullAsync(), serviceCallback);
    }

    /**
     * Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Widget>> object
     */
    public Single<RestResponse<Void, Map<String, Widget>>> getComplexItemNullWithRestResponseAsync() {
        return service.getComplexItemNull();
    }

    /**
     * Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Widget>> object
     */
    public Single<Map<String, Widget>> getComplexItemNullAsync() {
        return getComplexItemNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Widget>>, Map<String, Widget>>() { public Map<String, Widget> call(RestResponse<Void, Map<String, Widget>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Widget&gt; object if successful.
     */
    public Map<String, Widget> getComplexItemEmpty() {
        return getComplexItemEmptyAsync().toBlocking().value();
    }

    /**
     * Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Widget>> getComplexItemEmptyAsync(ServiceCallback<Map<String, Widget>> serviceCallback) {
        return ServiceFuture.fromBody(getComplexItemEmptyAsync(), serviceCallback);
    }

    /**
     * Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Widget>> object
     */
    public Single<RestResponse<Void, Map<String, Widget>>> getComplexItemEmptyWithRestResponseAsync() {
        return service.getComplexItemEmpty();
    }

    /**
     * Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Widget>> object
     */
    public Single<Map<String, Widget>> getComplexItemEmptyAsync() {
        return getComplexItemEmptyWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Widget>>, Map<String, Widget>>() { public Map<String, Widget> call(RestResponse<Void, Map<String, Widget>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Widget&gt; object if successful.
     */
    public Map<String, Widget> getComplexValid() {
        return getComplexValidAsync().toBlocking().value();
    }

    /**
     * Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Widget>> getComplexValidAsync(ServiceCallback<Map<String, Widget>> serviceCallback) {
        return ServiceFuture.fromBody(getComplexValidAsync(), serviceCallback);
    }

    /**
     * Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Widget>> object
     */
    public Single<RestResponse<Void, Map<String, Widget>>> getComplexValidWithRestResponseAsync() {
        return service.getComplexValid();
    }

    /**
     * Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Widget>> object
     */
    public Single<Map<String, Widget>> getComplexValidAsync() {
        return getComplexValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Widget>>, Map<String, Widget>>() { public Map<String, Widget> call(RestResponse<Void, Map<String, Widget>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param arrayBody the Map&lt;String, Widget&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putComplexValid(Map<String, Widget> arrayBody) {
        putComplexValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param arrayBody the Map&lt;String, Widget&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putComplexValidAsync(Map<String, Widget> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putComplexValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param arrayBody the Map&lt;String, Widget&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putComplexValidWithRestResponseAsync(Map<String, Widget> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putComplexValid(arrayBody);
    }

    /**
     * Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param arrayBody the Map&lt;String, Widget&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putComplexValidAsync(Map<String, Widget> arrayBody) {
        return putComplexValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get a null array.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     */
    public Map<String, List<String>> getArrayNull() {
        return getArrayNullAsync().toBlocking().value();
    }

    /**
     * Get a null array.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, List<String>>> getArrayNullAsync(ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceFuture.fromBody(getArrayNullAsync(), serviceCallback);
    }

    /**
     * Get a null array.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, List<String>>> object
     */
    public Single<RestResponse<Void, Map<String, List<String>>>> getArrayNullWithRestResponseAsync() {
        return service.getArrayNull();
    }

    /**
     * Get a null array.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, List<String>>> object
     */
    public Single<Map<String, List<String>>> getArrayNullAsync() {
        return getArrayNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, List<String>>>, Map<String, List<String>>>() { public Map<String, List<String>> call(RestResponse<Void, Map<String, List<String>>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get an empty dictionary {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     */
    public Map<String, List<String>> getArrayEmpty() {
        return getArrayEmptyAsync().toBlocking().value();
    }

    /**
     * Get an empty dictionary {}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, List<String>>> getArrayEmptyAsync(ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceFuture.fromBody(getArrayEmptyAsync(), serviceCallback);
    }

    /**
     * Get an empty dictionary {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, List<String>>> object
     */
    public Single<RestResponse<Void, Map<String, List<String>>>> getArrayEmptyWithRestResponseAsync() {
        return service.getArrayEmpty();
    }

    /**
     * Get an empty dictionary {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, List<String>>> object
     */
    public Single<Map<String, List<String>>> getArrayEmptyAsync() {
        return getArrayEmptyWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, List<String>>>, Map<String, List<String>>>() { public Map<String, List<String>> call(RestResponse<Void, Map<String, List<String>>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     */
    public Map<String, List<String>> getArrayItemNull() {
        return getArrayItemNullAsync().toBlocking().value();
    }

    /**
     * Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, List<String>>> getArrayItemNullAsync(ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceFuture.fromBody(getArrayItemNullAsync(), serviceCallback);
    }

    /**
     * Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, List<String>>> object
     */
    public Single<RestResponse<Void, Map<String, List<String>>>> getArrayItemNullWithRestResponseAsync() {
        return service.getArrayItemNull();
    }

    /**
     * Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, List<String>>> object
     */
    public Single<Map<String, List<String>>> getArrayItemNullAsync() {
        return getArrayItemNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, List<String>>>, Map<String, List<String>>>() { public Map<String, List<String>> call(RestResponse<Void, Map<String, List<String>>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     */
    public Map<String, List<String>> getArrayItemEmpty() {
        return getArrayItemEmptyAsync().toBlocking().value();
    }

    /**
     * Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, List<String>>> getArrayItemEmptyAsync(ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceFuture.fromBody(getArrayItemEmptyAsync(), serviceCallback);
    }

    /**
     * Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, List<String>>> object
     */
    public Single<RestResponse<Void, Map<String, List<String>>>> getArrayItemEmptyWithRestResponseAsync() {
        return service.getArrayItemEmpty();
    }

    /**
     * Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, List<String>>> object
     */
    public Single<Map<String, List<String>>> getArrayItemEmptyAsync() {
        return getArrayItemEmptyWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, List<String>>>, Map<String, List<String>>>() { public Map<String, List<String>> call(RestResponse<Void, Map<String, List<String>>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     */
    public Map<String, List<String>> getArrayValid() {
        return getArrayValidAsync().toBlocking().value();
    }

    /**
     * Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, List<String>>> getArrayValidAsync(ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceFuture.fromBody(getArrayValidAsync(), serviceCallback);
    }

    /**
     * Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, List<String>>> object
     */
    public Single<RestResponse<Void, Map<String, List<String>>>> getArrayValidWithRestResponseAsync() {
        return service.getArrayValid();
    }

    /**
     * Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, List<String>>> object
     */
    public Single<Map<String, List<String>>> getArrayValidAsync() {
        return getArrayValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, List<String>>>, Map<String, List<String>>>() { public Map<String, List<String>> call(RestResponse<Void, Map<String, List<String>>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @param arrayBody the Map&lt;String, List&lt;String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putArrayValid(Map<String, List<String>> arrayBody) {
        putArrayValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @param arrayBody the Map&lt;String, List&lt;String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putArrayValidAsync(Map<String, List<String>> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putArrayValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @param arrayBody the Map&lt;String, List&lt;String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putArrayValidWithRestResponseAsync(Map<String, List<String>> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putArrayValid(arrayBody);
    }

    /**
     * Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @param arrayBody the Map&lt;String, List&lt;String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putArrayValidAsync(Map<String, List<String>> arrayBody) {
        return putArrayValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get an dictionaries of dictionaries with value null.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object if successful.
     */
    public Map<String, Map<String, String>> getDictionaryNull() {
        return getDictionaryNullAsync().toBlocking().value();
    }

    /**
     * Get an dictionaries of dictionaries with value null.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Map<String, String>>> getDictionaryNullAsync(ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromBody(getDictionaryNullAsync(), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries with value null.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Map<String, String>>> object
     */
    public Single<RestResponse<Void, Map<String, Map<String, String>>>> getDictionaryNullWithRestResponseAsync() {
        return service.getDictionaryNull();
    }

    /**
     * Get an dictionaries of dictionaries with value null.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Map<String, String>>> object
     */
    public Single<Map<String, Map<String, String>>> getDictionaryNullAsync() {
        return getDictionaryNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Map<String, String>>>, Map<String, Map<String, String>>>() { public Map<String, Map<String, String>> call(RestResponse<Void, Map<String, Map<String, String>>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object if successful.
     */
    public Map<String, Map<String, String>> getDictionaryEmpty() {
        return getDictionaryEmptyAsync().toBlocking().value();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Map<String, String>>> getDictionaryEmptyAsync(ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromBody(getDictionaryEmptyAsync(), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Map<String, String>>> object
     */
    public Single<RestResponse<Void, Map<String, Map<String, String>>>> getDictionaryEmptyWithRestResponseAsync() {
        return service.getDictionaryEmpty();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Map<String, String>>> object
     */
    public Single<Map<String, Map<String, String>>> getDictionaryEmptyAsync() {
        return getDictionaryEmptyWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Map<String, String>>>, Map<String, Map<String, String>>>() { public Map<String, Map<String, String>> call(RestResponse<Void, Map<String, Map<String, String>>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object if successful.
     */
    public Map<String, Map<String, String>> getDictionaryItemNull() {
        return getDictionaryItemNullAsync().toBlocking().value();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Map<String, String>>> getDictionaryItemNullAsync(ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromBody(getDictionaryItemNullAsync(), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Map<String, String>>> object
     */
    public Single<RestResponse<Void, Map<String, Map<String, String>>>> getDictionaryItemNullWithRestResponseAsync() {
        return service.getDictionaryItemNull();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Map<String, String>>> object
     */
    public Single<Map<String, Map<String, String>>> getDictionaryItemNullAsync() {
        return getDictionaryItemNullWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Map<String, String>>>, Map<String, Map<String, String>>>() { public Map<String, Map<String, String>> call(RestResponse<Void, Map<String, Map<String, String>>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object if successful.
     */
    public Map<String, Map<String, String>> getDictionaryItemEmpty() {
        return getDictionaryItemEmptyAsync().toBlocking().value();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Map<String, String>>> getDictionaryItemEmptyAsync(ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromBody(getDictionaryItemEmptyAsync(), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Map<String, String>>> object
     */
    public Single<RestResponse<Void, Map<String, Map<String, String>>>> getDictionaryItemEmptyWithRestResponseAsync() {
        return service.getDictionaryItemEmpty();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Map<String, String>>> object
     */
    public Single<Map<String, Map<String, String>>> getDictionaryItemEmptyAsync() {
        return getDictionaryItemEmptyWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Map<String, String>>>, Map<String, Map<String, String>>>() { public Map<String, Map<String, String>> call(RestResponse<Void, Map<String, Map<String, String>>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object if successful.
     */
    public Map<String, Map<String, String>> getDictionaryValid() {
        return getDictionaryValidAsync().toBlocking().value();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Map<String, Map<String, String>>> getDictionaryValidAsync(ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromBody(getDictionaryValidAsync(), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Map<String, String>>> object
     */
    public Single<RestResponse<Void, Map<String, Map<String, String>>>> getDictionaryValidWithRestResponseAsync() {
        return service.getDictionaryValid();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Map<String, Map<String, String>>> object
     */
    public Single<Map<String, Map<String, String>>> getDictionaryValidAsync() {
        return getDictionaryValidWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Map<String, Map<String, String>>>, Map<String, Map<String, String>>>() { public Map<String, Map<String, String>> call(RestResponse<Void, Map<String, Map<String, String>>> restResponse) { return restResponse.body(); } });
        }


    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param arrayBody the Map&lt;String, Map&lt;String, String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void putDictionaryValid(Map<String, Map<String, String>> arrayBody) {
        putDictionaryValidAsync(arrayBody).toBlocking().value();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param arrayBody the Map&lt;String, Map&lt;String, String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDictionaryValidAsync(Map<String, Map<String, String>> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDictionaryValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param arrayBody the Map&lt;String, Map&lt;String, String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> putDictionaryValidWithRestResponseAsync(Map<String, Map<String, String>> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDictionaryValid(arrayBody);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param arrayBody the Map&lt;String, Map&lt;String, String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> putDictionaryValidAsync(Map<String, Map<String, String>> arrayBody) {
        return putDictionaryValidWithRestResponseAsync(arrayBody)
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


}
