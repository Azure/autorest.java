/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.bodyarray.implementation;

import retrofit2.Retrofit;
import fixtures.bodyarray.Arrays;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.Base64Url;
import com.microsoft.rest.DateTimeRfc1123;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.Validator;
import fixtures.bodyarray.models.ErrorException;
import fixtures.bodyarray.models.Product;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.joda.time.Period;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.PUT;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Arrays.
 */
public class ArraysImpl implements Arrays {
    /** The Retrofit service to perform REST calls. */
    private ArraysService service;
    /** The service client containing this operation class. */
    private AutoRestSwaggerBATArrayServiceImpl client;

    /**
     * Initializes an instance of Arrays.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ArraysImpl(Retrofit retrofit, AutoRestSwaggerBATArrayServiceImpl client) {
        this.service = retrofit.create(ArraysService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Arrays to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ArraysService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getNull" })
        @GET("array/null")
        Observable<Response<ResponseBody>> getNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getInvalid" })
        @GET("array/invalid")
        Observable<Response<ResponseBody>> getInvalid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getEmpty" })
        @GET("array/empty")
        Observable<Response<ResponseBody>> getEmpty();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putEmpty" })
        @PUT("array/empty")
        Observable<Response<ResponseBody>> putEmpty(@Body List<String> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getBooleanTfft" })
        @GET("array/prim/boolean/tfft")
        Observable<Response<ResponseBody>> getBooleanTfft();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putBooleanTfft" })
        @PUT("array/prim/boolean/tfft")
        Observable<Response<ResponseBody>> putBooleanTfft(@Body List<Boolean> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getBooleanInvalidNull" })
        @GET("array/prim/boolean/true.null.false")
        Observable<Response<ResponseBody>> getBooleanInvalidNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getBooleanInvalidString" })
        @GET("array/prim/boolean/true.boolean.false")
        Observable<Response<ResponseBody>> getBooleanInvalidString();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getIntegerValid" })
        @GET("array/prim/integer/1.-1.3.300")
        Observable<Response<ResponseBody>> getIntegerValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putIntegerValid" })
        @PUT("array/prim/integer/1.-1.3.300")
        Observable<Response<ResponseBody>> putIntegerValid(@Body List<Integer> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getIntInvalidNull" })
        @GET("array/prim/integer/1.null.zero")
        Observable<Response<ResponseBody>> getIntInvalidNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getIntInvalidString" })
        @GET("array/prim/integer/1.integer.0")
        Observable<Response<ResponseBody>> getIntInvalidString();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getLongValid" })
        @GET("array/prim/long/1.-1.3.300")
        Observable<Response<ResponseBody>> getLongValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putLongValid" })
        @PUT("array/prim/long/1.-1.3.300")
        Observable<Response<ResponseBody>> putLongValid(@Body List<Long> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getLongInvalidNull" })
        @GET("array/prim/long/1.null.zero")
        Observable<Response<ResponseBody>> getLongInvalidNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getLongInvalidString" })
        @GET("array/prim/long/1.integer.0")
        Observable<Response<ResponseBody>> getLongInvalidString();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getFloatValid" })
        @GET("array/prim/float/0--0.01-1.2e20")
        Observable<Response<ResponseBody>> getFloatValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putFloatValid" })
        @PUT("array/prim/float/0--0.01-1.2e20")
        Observable<Response<ResponseBody>> putFloatValid(@Body List<Double> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getFloatInvalidNull" })
        @GET("array/prim/float/0.0-null-1.2e20")
        Observable<Response<ResponseBody>> getFloatInvalidNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getFloatInvalidString" })
        @GET("array/prim/float/1.number.0")
        Observable<Response<ResponseBody>> getFloatInvalidString();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDoubleValid" })
        @GET("array/prim/double/0--0.01-1.2e20")
        Observable<Response<ResponseBody>> getDoubleValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putDoubleValid" })
        @PUT("array/prim/double/0--0.01-1.2e20")
        Observable<Response<ResponseBody>> putDoubleValid(@Body List<Double> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDoubleInvalidNull" })
        @GET("array/prim/double/0.0-null-1.2e20")
        Observable<Response<ResponseBody>> getDoubleInvalidNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDoubleInvalidString" })
        @GET("array/prim/double/1.number.0")
        Observable<Response<ResponseBody>> getDoubleInvalidString();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getStringValid" })
        @GET("array/prim/string/foo1.foo2.foo3")
        Observable<Response<ResponseBody>> getStringValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putStringValid" })
        @PUT("array/prim/string/foo1.foo2.foo3")
        Observable<Response<ResponseBody>> putStringValid(@Body List<String> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getStringWithNull" })
        @GET("array/prim/string/foo.null.foo2")
        Observable<Response<ResponseBody>> getStringWithNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getStringWithInvalid" })
        @GET("array/prim/string/foo.123.foo2")
        Observable<Response<ResponseBody>> getStringWithInvalid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getUuidValid" })
        @GET("array/prim/uuid/valid")
        Observable<Response<ResponseBody>> getUuidValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putUuidValid" })
        @PUT("array/prim/uuid/valid")
        Observable<Response<ResponseBody>> putUuidValid(@Body List<UUID> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getUuidInvalidChars" })
        @GET("array/prim/uuid/invalidchars")
        Observable<Response<ResponseBody>> getUuidInvalidChars();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDateValid" })
        @GET("array/prim/date/valid")
        Observable<Response<ResponseBody>> getDateValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putDateValid" })
        @PUT("array/prim/date/valid")
        Observable<Response<ResponseBody>> putDateValid(@Body List<LocalDate> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDateInvalidNull" })
        @GET("array/prim/date/invalidnull")
        Observable<Response<ResponseBody>> getDateInvalidNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDateInvalidChars" })
        @GET("array/prim/date/invalidchars")
        Observable<Response<ResponseBody>> getDateInvalidChars();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDateTimeValid" })
        @GET("array/prim/date-time/valid")
        Observable<Response<ResponseBody>> getDateTimeValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putDateTimeValid" })
        @PUT("array/prim/date-time/valid")
        Observable<Response<ResponseBody>> putDateTimeValid(@Body List<DateTime> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDateTimeInvalidNull" })
        @GET("array/prim/date-time/invalidnull")
        Observable<Response<ResponseBody>> getDateTimeInvalidNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDateTimeInvalidChars" })
        @GET("array/prim/date-time/invalidchars")
        Observable<Response<ResponseBody>> getDateTimeInvalidChars();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDateTimeRfc1123Valid" })
        @GET("array/prim/date-time-rfc1123/valid")
        Observable<Response<ResponseBody>> getDateTimeRfc1123Valid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putDateTimeRfc1123Valid" })
        @PUT("array/prim/date-time-rfc1123/valid")
        Observable<Response<ResponseBody>> putDateTimeRfc1123Valid(@Body List<DateTimeRfc1123> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDurationValid" })
        @GET("array/prim/duration/valid")
        Observable<Response<ResponseBody>> getDurationValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putDurationValid" })
        @PUT("array/prim/duration/valid")
        Observable<Response<ResponseBody>> putDurationValid(@Body List<Period> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getByteValid" })
        @GET("array/prim/byte/valid")
        Observable<Response<ResponseBody>> getByteValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putByteValid" })
        @PUT("array/prim/byte/valid")
        Observable<Response<ResponseBody>> putByteValid(@Body List<byte[]> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getByteInvalidNull" })
        @GET("array/prim/byte/invalidnull")
        Observable<Response<ResponseBody>> getByteInvalidNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getBase64Url" })
        @GET("array/prim/base64url/valid")
        Observable<Response<ResponseBody>> getBase64Url();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getComplexNull" })
        @GET("array/complex/null")
        Observable<Response<ResponseBody>> getComplexNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getComplexEmpty" })
        @GET("array/complex/empty")
        Observable<Response<ResponseBody>> getComplexEmpty();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getComplexItemNull" })
        @GET("array/complex/itemnull")
        Observable<Response<ResponseBody>> getComplexItemNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getComplexItemEmpty" })
        @GET("array/complex/itemempty")
        Observable<Response<ResponseBody>> getComplexItemEmpty();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getComplexValid" })
        @GET("array/complex/valid")
        Observable<Response<ResponseBody>> getComplexValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putComplexValid" })
        @PUT("array/complex/valid")
        Observable<Response<ResponseBody>> putComplexValid(@Body List<Product> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getArrayNull" })
        @GET("array/array/null")
        Observable<Response<ResponseBody>> getArrayNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getArrayEmpty" })
        @GET("array/array/empty")
        Observable<Response<ResponseBody>> getArrayEmpty();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getArrayItemNull" })
        @GET("array/array/itemnull")
        Observable<Response<ResponseBody>> getArrayItemNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getArrayItemEmpty" })
        @GET("array/array/itemempty")
        Observable<Response<ResponseBody>> getArrayItemEmpty();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getArrayValid" })
        @GET("array/array/valid")
        Observable<Response<ResponseBody>> getArrayValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putArrayValid" })
        @PUT("array/array/valid")
        Observable<Response<ResponseBody>> putArrayValid(@Body List<List<String>> arrayBody);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDictionaryNull" })
        @GET("array/dictionary/null")
        Observable<Response<ResponseBody>> getDictionaryNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDictionaryEmpty" })
        @GET("array/dictionary/empty")
        Observable<Response<ResponseBody>> getDictionaryEmpty();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDictionaryItemNull" })
        @GET("array/dictionary/itemnull")
        Observable<Response<ResponseBody>> getDictionaryItemNull();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDictionaryItemEmpty" })
        @GET("array/dictionary/itemempty")
        Observable<Response<ResponseBody>> getDictionaryItemEmpty();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays getDictionaryValid" })
        @GET("array/dictionary/valid")
        Observable<Response<ResponseBody>> getDictionaryValid();

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: fixtures.bodyarray.Arrays putDictionaryValid" })
        @PUT("array/dictionary/valid")
        Observable<Response<ResponseBody>> putDictionaryValid(@Body List<Map<String, String>> arrayBody);

    }

    /**
     * Get null array value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getNull() {
        return getNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get null array value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Integer>> getNullAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromResponse(getNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get null array value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<List<Integer>> getNullAsync() {
        return getNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Integer>>, List<Integer>>() {
            @Override
            public List<Integer> call(ServiceResponse<List<Integer>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get null array value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<ServiceResponse<List<Integer>>> getNullWithServiceResponseAsync() {
        return service.getNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Integer>>>>() {
                @Override
                public Observable<ServiceResponse<List<Integer>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Integer>> clientResponse = getNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Integer>> getNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Integer>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get invalid array [1, 2, 3.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getInvalid() {
        return getInvalidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get invalid array [1, 2, 3.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Integer>> getInvalidAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromResponse(getInvalidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get invalid array [1, 2, 3.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<List<Integer>> getInvalidAsync() {
        return getInvalidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Integer>>, List<Integer>>() {
            @Override
            public List<Integer> call(ServiceResponse<List<Integer>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get invalid array [1, 2, 3.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<ServiceResponse<List<Integer>>> getInvalidWithServiceResponseAsync() {
        return service.getInvalid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Integer>>>>() {
                @Override
                public Observable<ServiceResponse<List<Integer>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Integer>> clientResponse = getInvalidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Integer>> getInvalidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Integer>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get empty array value [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getEmpty() {
        return getEmptyWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get empty array value [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Integer>> getEmptyAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromResponse(getEmptyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get empty array value [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<List<Integer>> getEmptyAsync() {
        return getEmptyWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Integer>>, List<Integer>>() {
            @Override
            public List<Integer> call(ServiceResponse<List<Integer>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get empty array value [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<ServiceResponse<List<Integer>>> getEmptyWithServiceResponseAsync() {
        return service.getEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Integer>>>>() {
                @Override
                public Observable<ServiceResponse<List<Integer>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Integer>> clientResponse = getEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Integer>> getEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Integer>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value empty [].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putEmpty(List<String> arrayBody) {
        putEmptyWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value empty [].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putEmptyAsync(List<String> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putEmptyWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value empty [].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putEmptyAsync(List<String> arrayBody) {
        return putEmptyWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value empty [].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putEmptyWithServiceResponseAsync(List<String> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putEmpty(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean array value [true, false, false, true].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Boolean&gt; object if successful.
     */
    public List<Boolean> getBooleanTfft() {
        return getBooleanTfftWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get boolean array value [true, false, false, true].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Boolean>> getBooleanTfftAsync(final ServiceCallback<List<Boolean>> serviceCallback) {
        return ServiceFuture.fromResponse(getBooleanTfftWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get boolean array value [true, false, false, true].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Boolean&gt; object
     */
    public Observable<List<Boolean>> getBooleanTfftAsync() {
        return getBooleanTfftWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Boolean>>, List<Boolean>>() {
            @Override
            public List<Boolean> call(ServiceResponse<List<Boolean>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get boolean array value [true, false, false, true].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Boolean&gt; object
     */
    public Observable<ServiceResponse<List<Boolean>>> getBooleanTfftWithServiceResponseAsync() {
        return service.getBooleanTfft()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Boolean>>>>() {
                @Override
                public Observable<ServiceResponse<List<Boolean>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Boolean>> clientResponse = getBooleanTfftDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Boolean>> getBooleanTfftDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Boolean>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Boolean>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value empty [true, false, false, true].
     *
     * @param arrayBody the List&lt;Boolean&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putBooleanTfft(List<Boolean> arrayBody) {
        putBooleanTfftWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value empty [true, false, false, true].
     *
     * @param arrayBody the List&lt;Boolean&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putBooleanTfftAsync(List<Boolean> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putBooleanTfftWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value empty [true, false, false, true].
     *
     * @param arrayBody the List&lt;Boolean&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putBooleanTfftAsync(List<Boolean> arrayBody) {
        return putBooleanTfftWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value empty [true, false, false, true].
     *
     * @param arrayBody the List&lt;Boolean&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putBooleanTfftWithServiceResponseAsync(List<Boolean> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putBooleanTfft(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putBooleanTfftDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putBooleanTfftDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean array value [true, null, false].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Boolean&gt; object if successful.
     */
    public List<Boolean> getBooleanInvalidNull() {
        return getBooleanInvalidNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get boolean array value [true, null, false].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Boolean>> getBooleanInvalidNullAsync(final ServiceCallback<List<Boolean>> serviceCallback) {
        return ServiceFuture.fromResponse(getBooleanInvalidNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get boolean array value [true, null, false].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Boolean&gt; object
     */
    public Observable<List<Boolean>> getBooleanInvalidNullAsync() {
        return getBooleanInvalidNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Boolean>>, List<Boolean>>() {
            @Override
            public List<Boolean> call(ServiceResponse<List<Boolean>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get boolean array value [true, null, false].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Boolean&gt; object
     */
    public Observable<ServiceResponse<List<Boolean>>> getBooleanInvalidNullWithServiceResponseAsync() {
        return service.getBooleanInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Boolean>>>>() {
                @Override
                public Observable<ServiceResponse<List<Boolean>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Boolean>> clientResponse = getBooleanInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Boolean>> getBooleanInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Boolean>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Boolean>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean array value [true, 'boolean', false].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Boolean&gt; object if successful.
     */
    public List<Boolean> getBooleanInvalidString() {
        return getBooleanInvalidStringWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get boolean array value [true, 'boolean', false].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Boolean>> getBooleanInvalidStringAsync(final ServiceCallback<List<Boolean>> serviceCallback) {
        return ServiceFuture.fromResponse(getBooleanInvalidStringWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get boolean array value [true, 'boolean', false].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Boolean&gt; object
     */
    public Observable<List<Boolean>> getBooleanInvalidStringAsync() {
        return getBooleanInvalidStringWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Boolean>>, List<Boolean>>() {
            @Override
            public List<Boolean> call(ServiceResponse<List<Boolean>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get boolean array value [true, 'boolean', false].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Boolean&gt; object
     */
    public Observable<ServiceResponse<List<Boolean>>> getBooleanInvalidStringWithServiceResponseAsync() {
        return service.getBooleanInvalidString()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Boolean>>>>() {
                @Override
                public Observable<ServiceResponse<List<Boolean>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Boolean>> clientResponse = getBooleanInvalidStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Boolean>> getBooleanInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Boolean>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Boolean>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getIntegerValid() {
        return getIntegerValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Integer>> getIntegerValidAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromResponse(getIntegerValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<List<Integer>> getIntegerValidAsync() {
        return getIntegerValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Integer>>, List<Integer>>() {
            @Override
            public List<Integer> call(ServiceResponse<List<Integer>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<ServiceResponse<List<Integer>>> getIntegerValidWithServiceResponseAsync() {
        return service.getIntegerValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Integer>>>>() {
                @Override
                public Observable<ServiceResponse<List<Integer>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Integer>> clientResponse = getIntegerValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Integer>> getIntegerValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Integer>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Integer&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putIntegerValid(List<Integer> arrayBody) {
        putIntegerValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Integer&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putIntegerValidAsync(List<Integer> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putIntegerValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Integer&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putIntegerValidAsync(List<Integer> arrayBody) {
        return putIntegerValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Integer&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putIntegerValidWithServiceResponseAsync(List<Integer> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putIntegerValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putIntegerValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putIntegerValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer array value [1, null, 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getIntInvalidNull() {
        return getIntInvalidNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get integer array value [1, null, 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Integer>> getIntInvalidNullAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromResponse(getIntInvalidNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get integer array value [1, null, 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<List<Integer>> getIntInvalidNullAsync() {
        return getIntInvalidNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Integer>>, List<Integer>>() {
            @Override
            public List<Integer> call(ServiceResponse<List<Integer>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get integer array value [1, null, 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<ServiceResponse<List<Integer>>> getIntInvalidNullWithServiceResponseAsync() {
        return service.getIntInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Integer>>>>() {
                @Override
                public Observable<ServiceResponse<List<Integer>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Integer>> clientResponse = getIntInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Integer>> getIntInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Integer>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer array value [1, 'integer', 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getIntInvalidString() {
        return getIntInvalidStringWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get integer array value [1, 'integer', 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Integer>> getIntInvalidStringAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromResponse(getIntInvalidStringWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get integer array value [1, 'integer', 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<List<Integer>> getIntInvalidStringAsync() {
        return getIntInvalidStringWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Integer>>, List<Integer>>() {
            @Override
            public List<Integer> call(ServiceResponse<List<Integer>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get integer array value [1, 'integer', 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Integer&gt; object
     */
    public Observable<ServiceResponse<List<Integer>>> getIntInvalidStringWithServiceResponseAsync() {
        return service.getIntInvalidString()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Integer>>>>() {
                @Override
                public Observable<ServiceResponse<List<Integer>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Integer>> clientResponse = getIntInvalidStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Integer>> getIntInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Integer>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Long&gt; object if successful.
     */
    public List<Long> getLongValid() {
        return getLongValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Long>> getLongValidAsync(final ServiceCallback<List<Long>> serviceCallback) {
        return ServiceFuture.fromResponse(getLongValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Long&gt; object
     */
    public Observable<List<Long>> getLongValidAsync() {
        return getLongValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Long>>, List<Long>>() {
            @Override
            public List<Long> call(ServiceResponse<List<Long>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Long&gt; object
     */
    public Observable<ServiceResponse<List<Long>>> getLongValidWithServiceResponseAsync() {
        return service.getLongValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Long>>>>() {
                @Override
                public Observable<ServiceResponse<List<Long>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Long>> clientResponse = getLongValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Long>> getLongValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Long>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Long>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Long&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putLongValid(List<Long> arrayBody) {
        putLongValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Long&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putLongValidAsync(List<Long> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putLongValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Long&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putLongValidAsync(List<Long> arrayBody) {
        return putLongValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Long&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putLongValidWithServiceResponseAsync(List<Long> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putLongValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putLongValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putLongValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get long array value [1, null, 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Long&gt; object if successful.
     */
    public List<Long> getLongInvalidNull() {
        return getLongInvalidNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get long array value [1, null, 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Long>> getLongInvalidNullAsync(final ServiceCallback<List<Long>> serviceCallback) {
        return ServiceFuture.fromResponse(getLongInvalidNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get long array value [1, null, 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Long&gt; object
     */
    public Observable<List<Long>> getLongInvalidNullAsync() {
        return getLongInvalidNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Long>>, List<Long>>() {
            @Override
            public List<Long> call(ServiceResponse<List<Long>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get long array value [1, null, 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Long&gt; object
     */
    public Observable<ServiceResponse<List<Long>>> getLongInvalidNullWithServiceResponseAsync() {
        return service.getLongInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Long>>>>() {
                @Override
                public Observable<ServiceResponse<List<Long>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Long>> clientResponse = getLongInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Long>> getLongInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Long>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Long>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get long array value [1, 'integer', 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Long&gt; object if successful.
     */
    public List<Long> getLongInvalidString() {
        return getLongInvalidStringWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get long array value [1, 'integer', 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Long>> getLongInvalidStringAsync(final ServiceCallback<List<Long>> serviceCallback) {
        return ServiceFuture.fromResponse(getLongInvalidStringWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get long array value [1, 'integer', 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Long&gt; object
     */
    public Observable<List<Long>> getLongInvalidStringAsync() {
        return getLongInvalidStringWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Long>>, List<Long>>() {
            @Override
            public List<Long> call(ServiceResponse<List<Long>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get long array value [1, 'integer', 0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Long&gt; object
     */
    public Observable<ServiceResponse<List<Long>>> getLongInvalidStringWithServiceResponseAsync() {
        return service.getLongInvalidString()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Long>>>>() {
                @Override
                public Observable<ServiceResponse<List<Long>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Long>> clientResponse = getLongInvalidStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Long>> getLongInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Long>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Long>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getFloatValid() {
        return getFloatValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Double>> getFloatValidAsync(final ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromResponse(getFloatValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<List<Double>> getFloatValidAsync() {
        return getFloatValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Double>>, List<Double>>() {
            @Override
            public List<Double> call(ServiceResponse<List<Double>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<ServiceResponse<List<Double>>> getFloatValidWithServiceResponseAsync() {
        return service.getFloatValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Double>>>>() {
                @Override
                public Observable<ServiceResponse<List<Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Double>> clientResponse = getFloatValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Double>> getFloatValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Double>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putFloatValid(List<Double> arrayBody) {
        putFloatValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putFloatValidAsync(List<Double> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putFloatValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putFloatValidAsync(List<Double> arrayBody) {
        return putFloatValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putFloatValidWithServiceResponseAsync(List<Double> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putFloatValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putFloatValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putFloatValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getFloatInvalidNull() {
        return getFloatInvalidNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Double>> getFloatInvalidNullAsync(final ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromResponse(getFloatInvalidNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<List<Double>> getFloatInvalidNullAsync() {
        return getFloatInvalidNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Double>>, List<Double>>() {
            @Override
            public List<Double> call(ServiceResponse<List<Double>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<ServiceResponse<List<Double>>> getFloatInvalidNullWithServiceResponseAsync() {
        return service.getFloatInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Double>>>>() {
                @Override
                public Observable<ServiceResponse<List<Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Double>> clientResponse = getFloatInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Double>> getFloatInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Double>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getFloatInvalidString() {
        return getFloatInvalidStringWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Double>> getFloatInvalidStringAsync(final ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromResponse(getFloatInvalidStringWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<List<Double>> getFloatInvalidStringAsync() {
        return getFloatInvalidStringWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Double>>, List<Double>>() {
            @Override
            public List<Double> call(ServiceResponse<List<Double>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<ServiceResponse<List<Double>>> getFloatInvalidStringWithServiceResponseAsync() {
        return service.getFloatInvalidString()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Double>>>>() {
                @Override
                public Observable<ServiceResponse<List<Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Double>> clientResponse = getFloatInvalidStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Double>> getFloatInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Double>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getDoubleValid() {
        return getDoubleValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Double>> getDoubleValidAsync(final ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromResponse(getDoubleValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<List<Double>> getDoubleValidAsync() {
        return getDoubleValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Double>>, List<Double>>() {
            @Override
            public List<Double> call(ServiceResponse<List<Double>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<ServiceResponse<List<Double>>> getDoubleValidWithServiceResponseAsync() {
        return service.getDoubleValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Double>>>>() {
                @Override
                public Observable<ServiceResponse<List<Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Double>> clientResponse = getDoubleValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Double>> getDoubleValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Double>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putDoubleValid(List<Double> arrayBody) {
        putDoubleValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDoubleValidAsync(List<Double> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putDoubleValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDoubleValidAsync(List<Double> arrayBody) {
        return putDoubleValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDoubleValidWithServiceResponseAsync(List<Double> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDoubleValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDoubleValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDoubleValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getDoubleInvalidNull() {
        return getDoubleInvalidNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Double>> getDoubleInvalidNullAsync(final ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromResponse(getDoubleInvalidNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<List<Double>> getDoubleInvalidNullAsync() {
        return getDoubleInvalidNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Double>>, List<Double>>() {
            @Override
            public List<Double> call(ServiceResponse<List<Double>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<ServiceResponse<List<Double>>> getDoubleInvalidNullWithServiceResponseAsync() {
        return service.getDoubleInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Double>>>>() {
                @Override
                public Observable<ServiceResponse<List<Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Double>> clientResponse = getDoubleInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Double>> getDoubleInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Double>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getDoubleInvalidString() {
        return getDoubleInvalidStringWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Double>> getDoubleInvalidStringAsync(final ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromResponse(getDoubleInvalidStringWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<List<Double>> getDoubleInvalidStringAsync() {
        return getDoubleInvalidStringWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Double>>, List<Double>>() {
            @Override
            public List<Double> call(ServiceResponse<List<Double>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Double&gt; object
     */
    public Observable<ServiceResponse<List<Double>>> getDoubleInvalidStringWithServiceResponseAsync() {
        return service.getDoubleInvalidString()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Double>>>>() {
                @Override
                public Observable<ServiceResponse<List<Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Double>> clientResponse = getDoubleInvalidStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Double>> getDoubleInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Double>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;String&gt; object if successful.
     */
    public List<String> getStringValid() {
        return getStringValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<String>> getStringValidAsync(final ServiceCallback<List<String>> serviceCallback) {
        return ServiceFuture.fromResponse(getStringValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;String&gt; object
     */
    public Observable<List<String>> getStringValidAsync() {
        return getStringValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<String>>, List<String>>() {
            @Override
            public List<String> call(ServiceResponse<List<String>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;String&gt; object
     */
    public Observable<ServiceResponse<List<String>>> getStringValidWithServiceResponseAsync() {
        return service.getStringValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<String>>>>() {
                @Override
                public Observable<ServiceResponse<List<String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<String>> clientResponse = getStringValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<String>> getStringValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<String>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3'].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putStringValid(List<String> arrayBody) {
        putStringValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3'].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putStringValidAsync(List<String> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putStringValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3'].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putStringValidAsync(List<String> arrayBody) {
        return putStringValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3'].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putStringValidWithServiceResponseAsync(List<String> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putStringValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putStringValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putStringValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get string array value ['foo', null, 'foo2'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;String&gt; object if successful.
     */
    public List<String> getStringWithNull() {
        return getStringWithNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get string array value ['foo', null, 'foo2'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<String>> getStringWithNullAsync(final ServiceCallback<List<String>> serviceCallback) {
        return ServiceFuture.fromResponse(getStringWithNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get string array value ['foo', null, 'foo2'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;String&gt; object
     */
    public Observable<List<String>> getStringWithNullAsync() {
        return getStringWithNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<String>>, List<String>>() {
            @Override
            public List<String> call(ServiceResponse<List<String>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get string array value ['foo', null, 'foo2'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;String&gt; object
     */
    public Observable<ServiceResponse<List<String>>> getStringWithNullWithServiceResponseAsync() {
        return service.getStringWithNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<String>>>>() {
                @Override
                public Observable<ServiceResponse<List<String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<String>> clientResponse = getStringWithNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<String>> getStringWithNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<String>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get string array value ['foo', 123, 'foo2'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;String&gt; object if successful.
     */
    public List<String> getStringWithInvalid() {
        return getStringWithInvalidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get string array value ['foo', 123, 'foo2'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<String>> getStringWithInvalidAsync(final ServiceCallback<List<String>> serviceCallback) {
        return ServiceFuture.fromResponse(getStringWithInvalidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get string array value ['foo', 123, 'foo2'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;String&gt; object
     */
    public Observable<List<String>> getStringWithInvalidAsync() {
        return getStringWithInvalidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<String>>, List<String>>() {
            @Override
            public List<String> call(ServiceResponse<List<String>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get string array value ['foo', 123, 'foo2'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;String&gt; object
     */
    public Observable<ServiceResponse<List<String>>> getStringWithInvalidWithServiceResponseAsync() {
        return service.getStringWithInvalid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<String>>>>() {
                @Override
                public Observable<ServiceResponse<List<String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<String>> clientResponse = getStringWithInvalidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<String>> getStringWithInvalidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<String>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UUID&gt; object if successful.
     */
    public List<UUID> getUuidValid() {
        return getUuidValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UUID>> getUuidValidAsync(final ServiceCallback<List<UUID>> serviceCallback) {
        return ServiceFuture.fromResponse(getUuidValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UUID&gt; object
     */
    public Observable<List<UUID>> getUuidValidAsync() {
        return getUuidValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<UUID>>, List<UUID>>() {
            @Override
            public List<UUID> call(ServiceResponse<List<UUID>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UUID&gt; object
     */
    public Observable<ServiceResponse<List<UUID>>> getUuidValidWithServiceResponseAsync() {
        return service.getUuidValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UUID>>>>() {
                @Override
                public Observable<ServiceResponse<List<UUID>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UUID>> clientResponse = getUuidValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UUID>> getUuidValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<UUID>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<UUID>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param arrayBody the List&lt;UUID&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putUuidValid(List<UUID> arrayBody) {
        putUuidValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param arrayBody the List&lt;UUID&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putUuidValidAsync(List<UUID> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putUuidValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param arrayBody the List&lt;UUID&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putUuidValidAsync(List<UUID> arrayBody) {
        return putUuidValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param arrayBody the List&lt;UUID&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putUuidValidWithServiceResponseAsync(List<UUID> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putUuidValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putUuidValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putUuidValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;UUID&gt; object if successful.
     */
    public List<UUID> getUuidInvalidChars() {
        return getUuidInvalidCharsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<UUID>> getUuidInvalidCharsAsync(final ServiceCallback<List<UUID>> serviceCallback) {
        return ServiceFuture.fromResponse(getUuidInvalidCharsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UUID&gt; object
     */
    public Observable<List<UUID>> getUuidInvalidCharsAsync() {
        return getUuidInvalidCharsWithServiceResponseAsync().map(new Func1<ServiceResponse<List<UUID>>, List<UUID>>() {
            @Override
            public List<UUID> call(ServiceResponse<List<UUID>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;UUID&gt; object
     */
    public Observable<ServiceResponse<List<UUID>>> getUuidInvalidCharsWithServiceResponseAsync() {
        return service.getUuidInvalidChars()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<UUID>>>>() {
                @Override
                public Observable<ServiceResponse<List<UUID>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<UUID>> clientResponse = getUuidInvalidCharsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<UUID>> getUuidInvalidCharsDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<UUID>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<UUID>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;LocalDate&gt; object if successful.
     */
    public List<LocalDate> getDateValid() {
        return getDateValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<LocalDate>> getDateValidAsync(final ServiceCallback<List<LocalDate>> serviceCallback) {
        return ServiceFuture.fromResponse(getDateValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LocalDate&gt; object
     */
    public Observable<List<LocalDate>> getDateValidAsync() {
        return getDateValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<LocalDate>>, List<LocalDate>>() {
            @Override
            public List<LocalDate> call(ServiceResponse<List<LocalDate>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LocalDate&gt; object
     */
    public Observable<ServiceResponse<List<LocalDate>>> getDateValidWithServiceResponseAsync() {
        return service.getDateValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<LocalDate>>>>() {
                @Override
                public Observable<ServiceResponse<List<LocalDate>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<LocalDate>> clientResponse = getDateValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<LocalDate>> getDateValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<LocalDate>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<LocalDate>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param arrayBody the List&lt;LocalDate&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putDateValid(List<LocalDate> arrayBody) {
        putDateValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param arrayBody the List&lt;LocalDate&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDateValidAsync(List<LocalDate> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putDateValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param arrayBody the List&lt;LocalDate&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDateValidAsync(List<LocalDate> arrayBody) {
        return putDateValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param arrayBody the List&lt;LocalDate&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDateValidWithServiceResponseAsync(List<LocalDate> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDateValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDateValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDateValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;LocalDate&gt; object if successful.
     */
    public List<LocalDate> getDateInvalidNull() {
        return getDateInvalidNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<LocalDate>> getDateInvalidNullAsync(final ServiceCallback<List<LocalDate>> serviceCallback) {
        return ServiceFuture.fromResponse(getDateInvalidNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LocalDate&gt; object
     */
    public Observable<List<LocalDate>> getDateInvalidNullAsync() {
        return getDateInvalidNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<LocalDate>>, List<LocalDate>>() {
            @Override
            public List<LocalDate> call(ServiceResponse<List<LocalDate>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LocalDate&gt; object
     */
    public Observable<ServiceResponse<List<LocalDate>>> getDateInvalidNullWithServiceResponseAsync() {
        return service.getDateInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<LocalDate>>>>() {
                @Override
                public Observable<ServiceResponse<List<LocalDate>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<LocalDate>> clientResponse = getDateInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<LocalDate>> getDateInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<LocalDate>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<LocalDate>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date array value ['2011-03-22', 'date'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;LocalDate&gt; object if successful.
     */
    public List<LocalDate> getDateInvalidChars() {
        return getDateInvalidCharsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get date array value ['2011-03-22', 'date'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<LocalDate>> getDateInvalidCharsAsync(final ServiceCallback<List<LocalDate>> serviceCallback) {
        return ServiceFuture.fromResponse(getDateInvalidCharsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get date array value ['2011-03-22', 'date'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LocalDate&gt; object
     */
    public Observable<List<LocalDate>> getDateInvalidCharsAsync() {
        return getDateInvalidCharsWithServiceResponseAsync().map(new Func1<ServiceResponse<List<LocalDate>>, List<LocalDate>>() {
            @Override
            public List<LocalDate> call(ServiceResponse<List<LocalDate>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get date array value ['2011-03-22', 'date'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;LocalDate&gt; object
     */
    public Observable<ServiceResponse<List<LocalDate>>> getDateInvalidCharsWithServiceResponseAsync() {
        return service.getDateInvalidChars()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<LocalDate>>>>() {
                @Override
                public Observable<ServiceResponse<List<LocalDate>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<LocalDate>> clientResponse = getDateInvalidCharsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<LocalDate>> getDateInvalidCharsDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<LocalDate>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<LocalDate>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DateTime&gt; object if successful.
     */
    public List<DateTime> getDateTimeValid() {
        return getDateTimeValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DateTime>> getDateTimeValidAsync(final ServiceCallback<List<DateTime>> serviceCallback) {
        return ServiceFuture.fromResponse(getDateTimeValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DateTime&gt; object
     */
    public Observable<List<DateTime>> getDateTimeValidAsync() {
        return getDateTimeValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<DateTime>>, List<DateTime>>() {
            @Override
            public List<DateTime> call(ServiceResponse<List<DateTime>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DateTime&gt; object
     */
    public Observable<ServiceResponse<List<DateTime>>> getDateTimeValidWithServiceResponseAsync() {
        return service.getDateTimeValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DateTime>>>>() {
                @Override
                public Observable<ServiceResponse<List<DateTime>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DateTime>> clientResponse = getDateTimeValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DateTime>> getDateTimeValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<DateTime>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<DateTime>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param arrayBody the List&lt;DateTime&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putDateTimeValid(List<DateTime> arrayBody) {
        putDateTimeValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param arrayBody the List&lt;DateTime&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDateTimeValidAsync(List<DateTime> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putDateTimeValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param arrayBody the List&lt;DateTime&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDateTimeValidAsync(List<DateTime> arrayBody) {
        return putDateTimeValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param arrayBody the List&lt;DateTime&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDateTimeValidWithServiceResponseAsync(List<DateTime> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDateTimeValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDateTimeValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDateTimeValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DateTime&gt; object if successful.
     */
    public List<DateTime> getDateTimeInvalidNull() {
        return getDateTimeInvalidNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DateTime>> getDateTimeInvalidNullAsync(final ServiceCallback<List<DateTime>> serviceCallback) {
        return ServiceFuture.fromResponse(getDateTimeInvalidNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DateTime&gt; object
     */
    public Observable<List<DateTime>> getDateTimeInvalidNullAsync() {
        return getDateTimeInvalidNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<DateTime>>, List<DateTime>>() {
            @Override
            public List<DateTime> call(ServiceResponse<List<DateTime>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DateTime&gt; object
     */
    public Observable<ServiceResponse<List<DateTime>>> getDateTimeInvalidNullWithServiceResponseAsync() {
        return service.getDateTimeInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DateTime>>>>() {
                @Override
                public Observable<ServiceResponse<List<DateTime>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DateTime>> clientResponse = getDateTimeInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DateTime>> getDateTimeInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<DateTime>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<DateTime>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DateTime&gt; object if successful.
     */
    public List<DateTime> getDateTimeInvalidChars() {
        return getDateTimeInvalidCharsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DateTime>> getDateTimeInvalidCharsAsync(final ServiceCallback<List<DateTime>> serviceCallback) {
        return ServiceFuture.fromResponse(getDateTimeInvalidCharsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DateTime&gt; object
     */
    public Observable<List<DateTime>> getDateTimeInvalidCharsAsync() {
        return getDateTimeInvalidCharsWithServiceResponseAsync().map(new Func1<ServiceResponse<List<DateTime>>, List<DateTime>>() {
            @Override
            public List<DateTime> call(ServiceResponse<List<DateTime>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DateTime&gt; object
     */
    public Observable<ServiceResponse<List<DateTime>>> getDateTimeInvalidCharsWithServiceResponseAsync() {
        return service.getDateTimeInvalidChars()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DateTime>>>>() {
                @Override
                public Observable<ServiceResponse<List<DateTime>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DateTime>> clientResponse = getDateTimeInvalidCharsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DateTime>> getDateTimeInvalidCharsDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<DateTime>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<DateTime>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;DateTime&gt; object if successful.
     */
    public List<DateTime> getDateTimeRfc1123Valid() {
        return getDateTimeRfc1123ValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<DateTime>> getDateTimeRfc1123ValidAsync(final ServiceCallback<List<DateTime>> serviceCallback) {
        return ServiceFuture.fromResponse(getDateTimeRfc1123ValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DateTime&gt; object
     */
    public Observable<List<DateTime>> getDateTimeRfc1123ValidAsync() {
        return getDateTimeRfc1123ValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<DateTime>>, List<DateTime>>() {
            @Override
            public List<DateTime> call(ServiceResponse<List<DateTime>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;DateTime&gt; object
     */
    public Observable<ServiceResponse<List<DateTime>>> getDateTimeRfc1123ValidWithServiceResponseAsync() {
        return service.getDateTimeRfc1123Valid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<DateTime>>>>() {
                @Override
                public Observable<ServiceResponse<List<DateTime>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<DateTimeRfc1123>> result = getDateTimeRfc1123ValidDelegate(response);
                        List<DateTime> body = null;
                        if (result.body() != null) {
                            body = new ArrayList<DateTime>();
                            for (DateTimeRfc1123 item : result.body()) {
                                DateTime value;
                                value = item.dateTime();
                                body.add(value);
                            }
                        }
                        ServiceResponse<List<DateTime>> clientResponse = new ServiceResponse<List<DateTime>>(body, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<DateTimeRfc1123>> getDateTimeRfc1123ValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<DateTimeRfc1123>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<DateTimeRfc1123>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param arrayBody the List&lt;DateTimeRfc1123&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putDateTimeRfc1123Valid(List<DateTime> arrayBody) {
        putDateTimeRfc1123ValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param arrayBody the List&lt;DateTimeRfc1123&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDateTimeRfc1123ValidAsync(List<DateTime> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putDateTimeRfc1123ValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param arrayBody the List&lt;DateTimeRfc1123&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDateTimeRfc1123ValidAsync(List<DateTime> arrayBody) {
        return putDateTimeRfc1123ValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param arrayBody the List&lt;DateTimeRfc1123&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDateTimeRfc1123ValidWithServiceResponseAsync(List<DateTime> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        List<DateTimeRfc1123> arrayBodyConverted = new ArrayList<DateTimeRfc1123>();
        for (DateTime item : arrayBody) {
            DateTimeRfc1123 value = new DateTimeRfc1123(item);
            arrayBodyConverted.add(value);
        }
        return service.putDateTimeRfc1123Valid(arrayBodyConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDateTimeRfc1123ValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDateTimeRfc1123ValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Period&gt; object if successful.
     */
    public List<Period> getDurationValid() {
        return getDurationValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Period>> getDurationValidAsync(final ServiceCallback<List<Period>> serviceCallback) {
        return ServiceFuture.fromResponse(getDurationValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Period&gt; object
     */
    public Observable<List<Period>> getDurationValidAsync() {
        return getDurationValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Period>>, List<Period>>() {
            @Override
            public List<Period> call(ServiceResponse<List<Period>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Period&gt; object
     */
    public Observable<ServiceResponse<List<Period>>> getDurationValidWithServiceResponseAsync() {
        return service.getDurationValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Period>>>>() {
                @Override
                public Observable<ServiceResponse<List<Period>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Period>> clientResponse = getDurationValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Period>> getDurationValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Period>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Period>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param arrayBody the List&lt;Period&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putDurationValid(List<Period> arrayBody) {
        putDurationValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param arrayBody the List&lt;Period&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDurationValidAsync(List<Period> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putDurationValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param arrayBody the List&lt;Period&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDurationValidAsync(List<Period> arrayBody) {
        return putDurationValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param arrayBody the List&lt;Period&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDurationValidWithServiceResponseAsync(List<Period> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDurationValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDurationValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDurationValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;byte[]&gt; object if successful.
     */
    public List<byte[]> getByteValid() {
        return getByteValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<byte[]>> getByteValidAsync(final ServiceCallback<List<byte[]>> serviceCallback) {
        return ServiceFuture.fromResponse(getByteValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;byte[]&gt; object
     */
    public Observable<List<byte[]>> getByteValidAsync() {
        return getByteValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<byte[]>>, List<byte[]>>() {
            @Override
            public List<byte[]> call(ServiceResponse<List<byte[]>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;byte[]&gt; object
     */
    public Observable<ServiceResponse<List<byte[]>>> getByteValidWithServiceResponseAsync() {
        return service.getByteValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<byte[]>>>>() {
                @Override
                public Observable<ServiceResponse<List<byte[]>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<byte[]>> clientResponse = getByteValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<byte[]>> getByteValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<byte[]>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<byte[]>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.
     *
     * @param arrayBody the List&lt;byte[]&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putByteValid(List<byte[]> arrayBody) {
        putByteValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.
     *
     * @param arrayBody the List&lt;byte[]&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putByteValidAsync(List<byte[]> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putByteValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.
     *
     * @param arrayBody the List&lt;byte[]&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putByteValidAsync(List<byte[]> arrayBody) {
        return putByteValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.
     *
     * @param arrayBody the List&lt;byte[]&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putByteValidWithServiceResponseAsync(List<byte[]> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putByteValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putByteValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putByteValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;byte[]&gt; object if successful.
     */
    public List<byte[]> getByteInvalidNull() {
        return getByteInvalidNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<byte[]>> getByteInvalidNullAsync(final ServiceCallback<List<byte[]>> serviceCallback) {
        return ServiceFuture.fromResponse(getByteInvalidNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;byte[]&gt; object
     */
    public Observable<List<byte[]>> getByteInvalidNullAsync() {
        return getByteInvalidNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<byte[]>>, List<byte[]>>() {
            @Override
            public List<byte[]> call(ServiceResponse<List<byte[]>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;byte[]&gt; object
     */
    public Observable<ServiceResponse<List<byte[]>>> getByteInvalidNullWithServiceResponseAsync() {
        return service.getByteInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<byte[]>>>>() {
                @Override
                public Observable<ServiceResponse<List<byte[]>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<byte[]>> clientResponse = getByteInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<byte[]>> getByteInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<byte[]>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<byte[]>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;byte[]&gt; object if successful.
     */
    public List<byte[]> getBase64Url() {
        return getBase64UrlWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<byte[]>> getBase64UrlAsync(final ServiceCallback<List<byte[]>> serviceCallback) {
        return ServiceFuture.fromResponse(getBase64UrlWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;byte[]&gt; object
     */
    public Observable<List<byte[]>> getBase64UrlAsync() {
        return getBase64UrlWithServiceResponseAsync().map(new Func1<ServiceResponse<List<byte[]>>, List<byte[]>>() {
            @Override
            public List<byte[]> call(ServiceResponse<List<byte[]>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;byte[]&gt; object
     */
    public Observable<ServiceResponse<List<byte[]>>> getBase64UrlWithServiceResponseAsync() {
        return service.getBase64Url()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<byte[]>>>>() {
                @Override
                public Observable<ServiceResponse<List<byte[]>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Base64Url>> result = getBase64UrlDelegate(response);
                        List<byte[]> body = null;
                        if (result.body() != null) {
                            body = new ArrayList<byte[]>();
                            for (Base64Url item : result.body()) {
                                byte[] value;
                                value = item.decodedBytes();
                                body.add(value);
                            }
                        }
                        ServiceResponse<List<byte[]>> clientResponse = new ServiceResponse<List<byte[]>>(body, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Base64Url>> getBase64UrlDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Base64Url>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Base64Url>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get array of complex type null value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Product&gt; object if successful.
     */
    public List<Product> getComplexNull() {
        return getComplexNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get array of complex type null value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Product>> getComplexNullAsync(final ServiceCallback<List<Product>> serviceCallback) {
        return ServiceFuture.fromResponse(getComplexNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get array of complex type null value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Product&gt; object
     */
    public Observable<List<Product>> getComplexNullAsync() {
        return getComplexNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Product>>, List<Product>>() {
            @Override
            public List<Product> call(ServiceResponse<List<Product>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get array of complex type null value.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Product&gt; object
     */
    public Observable<ServiceResponse<List<Product>>> getComplexNullWithServiceResponseAsync() {
        return service.getComplexNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Product>>>>() {
                @Override
                public Observable<ServiceResponse<List<Product>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Product>> clientResponse = getComplexNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Product>> getComplexNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Product>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Product>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get empty array of complex type [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Product&gt; object if successful.
     */
    public List<Product> getComplexEmpty() {
        return getComplexEmptyWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get empty array of complex type [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Product>> getComplexEmptyAsync(final ServiceCallback<List<Product>> serviceCallback) {
        return ServiceFuture.fromResponse(getComplexEmptyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get empty array of complex type [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Product&gt; object
     */
    public Observable<List<Product>> getComplexEmptyAsync() {
        return getComplexEmptyWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Product>>, List<Product>>() {
            @Override
            public List<Product> call(ServiceResponse<List<Product>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get empty array of complex type [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Product&gt; object
     */
    public Observable<ServiceResponse<List<Product>>> getComplexEmptyWithServiceResponseAsync() {
        return service.getComplexEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Product>>>>() {
                @Override
                public Observable<ServiceResponse<List<Product>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Product>> clientResponse = getComplexEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Product>> getComplexEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Product>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Product>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Product&gt; object if successful.
     */
    public List<Product> getComplexItemNull() {
        return getComplexItemNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Product>> getComplexItemNullAsync(final ServiceCallback<List<Product>> serviceCallback) {
        return ServiceFuture.fromResponse(getComplexItemNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Product&gt; object
     */
    public Observable<List<Product>> getComplexItemNullAsync() {
        return getComplexItemNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Product>>, List<Product>>() {
            @Override
            public List<Product> call(ServiceResponse<List<Product>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Product&gt; object
     */
    public Observable<ServiceResponse<List<Product>>> getComplexItemNullWithServiceResponseAsync() {
        return service.getComplexItemNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Product>>>>() {
                @Override
                public Observable<ServiceResponse<List<Product>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Product>> clientResponse = getComplexItemNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Product>> getComplexItemNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Product>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Product>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Product&gt; object if successful.
     */
    public List<Product> getComplexItemEmpty() {
        return getComplexItemEmptyWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Product>> getComplexItemEmptyAsync(final ServiceCallback<List<Product>> serviceCallback) {
        return ServiceFuture.fromResponse(getComplexItemEmptyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Product&gt; object
     */
    public Observable<List<Product>> getComplexItemEmptyAsync() {
        return getComplexItemEmptyWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Product>>, List<Product>>() {
            @Override
            public List<Product> call(ServiceResponse<List<Product>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Product&gt; object
     */
    public Observable<ServiceResponse<List<Product>>> getComplexItemEmptyWithServiceResponseAsync() {
        return service.getComplexItemEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Product>>>>() {
                @Override
                public Observable<ServiceResponse<List<Product>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Product>> clientResponse = getComplexItemEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Product>> getComplexItemEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Product>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Product>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Product&gt; object if successful.
     */
    public List<Product> getComplexValid() {
        return getComplexValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Product>> getComplexValidAsync(final ServiceCallback<List<Product>> serviceCallback) {
        return ServiceFuture.fromResponse(getComplexValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Product&gt; object
     */
    public Observable<List<Product>> getComplexValidAsync() {
        return getComplexValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Product>>, List<Product>>() {
            @Override
            public List<Product> call(ServiceResponse<List<Product>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Product&gt; object
     */
    public Observable<ServiceResponse<List<Product>>> getComplexValidWithServiceResponseAsync() {
        return service.getComplexValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Product>>>>() {
                @Override
                public Observable<ServiceResponse<List<Product>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Product>> clientResponse = getComplexValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Product>> getComplexValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Product>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Product>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param arrayBody the List&lt;Product&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putComplexValid(List<Product> arrayBody) {
        putComplexValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param arrayBody the List&lt;Product&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putComplexValidAsync(List<Product> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putComplexValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param arrayBody the List&lt;Product&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putComplexValidAsync(List<Product> arrayBody) {
        return putComplexValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param arrayBody the List&lt;Product&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putComplexValidWithServiceResponseAsync(List<Product> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putComplexValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putComplexValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putComplexValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get a null array.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     */
    public List<List<String>> getArrayNull() {
        return getArrayNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get a null array.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<List<String>>> getArrayNullAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        return ServiceFuture.fromResponse(getArrayNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get a null array.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;List&lt;String&gt;&gt; object
     */
    public Observable<List<List<String>>> getArrayNullAsync() {
        return getArrayNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<List<String>>>, List<List<String>>>() {
            @Override
            public List<List<String>> call(ServiceResponse<List<List<String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get a null array.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<List<List<String>>>> getArrayNullWithServiceResponseAsync() {
        return service.getArrayNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<List<List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<List<String>>> clientResponse = getArrayNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<List<String>>> getArrayNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<List<String>>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an empty array [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     */
    public List<List<String>> getArrayEmpty() {
        return getArrayEmptyWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get an empty array [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<List<String>>> getArrayEmptyAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        return ServiceFuture.fromResponse(getArrayEmptyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get an empty array [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;List&lt;String&gt;&gt; object
     */
    public Observable<List<List<String>>> getArrayEmptyAsync() {
        return getArrayEmptyWithServiceResponseAsync().map(new Func1<ServiceResponse<List<List<String>>>, List<List<String>>>() {
            @Override
            public List<List<String>> call(ServiceResponse<List<List<String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get an empty array [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<List<List<String>>>> getArrayEmptyWithServiceResponseAsync() {
        return service.getArrayEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<List<List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<List<String>>> clientResponse = getArrayEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<List<String>>> getArrayEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<List<String>>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     */
    public List<List<String>> getArrayItemNull() {
        return getArrayItemNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<List<String>>> getArrayItemNullAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        return ServiceFuture.fromResponse(getArrayItemNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;List&lt;String&gt;&gt; object
     */
    public Observable<List<List<String>>> getArrayItemNullAsync() {
        return getArrayItemNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<List<String>>>, List<List<String>>>() {
            @Override
            public List<List<String>> call(ServiceResponse<List<List<String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<List<List<String>>>> getArrayItemNullWithServiceResponseAsync() {
        return service.getArrayItemNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<List<List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<List<String>>> clientResponse = getArrayItemNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<List<String>>> getArrayItemNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<List<String>>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     */
    public List<List<String>> getArrayItemEmpty() {
        return getArrayItemEmptyWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<List<String>>> getArrayItemEmptyAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        return ServiceFuture.fromResponse(getArrayItemEmptyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;List&lt;String&gt;&gt; object
     */
    public Observable<List<List<String>>> getArrayItemEmptyAsync() {
        return getArrayItemEmptyWithServiceResponseAsync().map(new Func1<ServiceResponse<List<List<String>>>, List<List<String>>>() {
            @Override
            public List<List<String>> call(ServiceResponse<List<List<String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<List<List<String>>>> getArrayItemEmptyWithServiceResponseAsync() {
        return service.getArrayItemEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<List<List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<List<String>>> clientResponse = getArrayItemEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<List<String>>> getArrayItemEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<List<String>>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     */
    public List<List<String>> getArrayValid() {
        return getArrayValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<List<String>>> getArrayValidAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        return ServiceFuture.fromResponse(getArrayValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;List&lt;String&gt;&gt; object
     */
    public Observable<List<List<String>>> getArrayValidAsync() {
        return getArrayValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<List<String>>>, List<List<String>>>() {
            @Override
            public List<List<String>> call(ServiceResponse<List<List<String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<List<List<String>>>> getArrayValidWithServiceResponseAsync() {
        return service.getArrayValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<List<List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<List<String>>> clientResponse = getArrayValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<List<String>>> getArrayValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<List<String>>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putArrayValid(List<List<String>> arrayBody) {
        putArrayValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putArrayValidAsync(List<List<String>> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putArrayValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putArrayValidAsync(List<List<String>> arrayBody) {
        return putArrayValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putArrayValidWithServiceResponseAsync(List<List<String>> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putArrayValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putArrayValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putArrayValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries with value null.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     */
    public List<Map<String, String>> getDictionaryNull() {
        return getDictionaryNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get an array of Dictionaries with value null.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Map<String, String>>> getDictionaryNullAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromResponse(getDictionaryNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get an array of Dictionaries with value null.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Map&lt;String, String&gt;&gt; object
     */
    public Observable<List<Map<String, String>>> getDictionaryNullAsync() {
        return getDictionaryNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Map<String, String>>>, List<Map<String, String>>>() {
            @Override
            public List<Map<String, String>> call(ServiceResponse<List<Map<String, String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get an array of Dictionaries with value null.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Map&lt;String, String&gt;&gt; object
     */
    public Observable<ServiceResponse<List<Map<String, String>>>> getDictionaryNullWithServiceResponseAsync() {
        return service.getDictionaryNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Map<String, String>>>>>() {
                @Override
                public Observable<ServiceResponse<List<Map<String, String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Map<String, String>>> clientResponse = getDictionaryNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Map<String, String>>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     */
    public List<Map<String, String>> getDictionaryEmpty() {
        return getDictionaryEmptyWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Map<String, String>>> getDictionaryEmptyAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromResponse(getDictionaryEmptyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Map&lt;String, String&gt;&gt; object
     */
    public Observable<List<Map<String, String>>> getDictionaryEmptyAsync() {
        return getDictionaryEmptyWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Map<String, String>>>, List<Map<String, String>>>() {
            @Override
            public List<Map<String, String>> call(ServiceResponse<List<Map<String, String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Map&lt;String, String&gt;&gt; object
     */
    public Observable<ServiceResponse<List<Map<String, String>>>> getDictionaryEmptyWithServiceResponseAsync() {
        return service.getDictionaryEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Map<String, String>>>>>() {
                @Override
                public Observable<ServiceResponse<List<Map<String, String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Map<String, String>>> clientResponse = getDictionaryEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Map<String, String>>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     */
    public List<Map<String, String>> getDictionaryItemNull() {
        return getDictionaryItemNullWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Map<String, String>>> getDictionaryItemNullAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromResponse(getDictionaryItemNullWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Map&lt;String, String&gt;&gt; object
     */
    public Observable<List<Map<String, String>>> getDictionaryItemNullAsync() {
        return getDictionaryItemNullWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Map<String, String>>>, List<Map<String, String>>>() {
            @Override
            public List<Map<String, String>> call(ServiceResponse<List<Map<String, String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Map&lt;String, String&gt;&gt; object
     */
    public Observable<ServiceResponse<List<Map<String, String>>>> getDictionaryItemNullWithServiceResponseAsync() {
        return service.getDictionaryItemNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Map<String, String>>>>>() {
                @Override
                public Observable<ServiceResponse<List<Map<String, String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Map<String, String>>> clientResponse = getDictionaryItemNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryItemNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Map<String, String>>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     */
    public List<Map<String, String>> getDictionaryItemEmpty() {
        return getDictionaryItemEmptyWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Map<String, String>>> getDictionaryItemEmptyAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromResponse(getDictionaryItemEmptyWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Map&lt;String, String&gt;&gt; object
     */
    public Observable<List<Map<String, String>>> getDictionaryItemEmptyAsync() {
        return getDictionaryItemEmptyWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Map<String, String>>>, List<Map<String, String>>>() {
            @Override
            public List<Map<String, String>> call(ServiceResponse<List<Map<String, String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Map&lt;String, String&gt;&gt; object
     */
    public Observable<ServiceResponse<List<Map<String, String>>>> getDictionaryItemEmptyWithServiceResponseAsync() {
        return service.getDictionaryItemEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Map<String, String>>>>>() {
                @Override
                public Observable<ServiceResponse<List<Map<String, String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Map<String, String>>> clientResponse = getDictionaryItemEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryItemEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Map<String, String>>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     */
    public List<Map<String, String>> getDictionaryValid() {
        return getDictionaryValidWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<Map<String, String>>> getDictionaryValidAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromResponse(getDictionaryValidWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Map&lt;String, String&gt;&gt; object
     */
    public Observable<List<Map<String, String>>> getDictionaryValidAsync() {
        return getDictionaryValidWithServiceResponseAsync().map(new Func1<ServiceResponse<List<Map<String, String>>>, List<Map<String, String>>>() {
            @Override
            public List<Map<String, String>> call(ServiceResponse<List<Map<String, String>>> response) {
                return response.body();
            }
        });
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;Map&lt;String, String&gt;&gt; object
     */
    public Observable<ServiceResponse<List<Map<String, String>>>> getDictionaryValidWithServiceResponseAsync() {
        return service.getDictionaryValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<Map<String, String>>>>>() {
                @Override
                public Observable<ServiceResponse<List<Map<String, String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<Map<String, String>>> clientResponse = getDictionaryValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return this.client.restClient().responseBuilderFactory().<List<Map<String, String>>, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<List<Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws ErrorException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void putDictionaryValid(List<Map<String, String>> arrayBody) {
        putDictionaryValidWithServiceResponseAsync(arrayBody).toBlocking().single().body();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> putDictionaryValidAsync(List<Map<String, String>> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromResponse(putDictionaryValidWithServiceResponseAsync(arrayBody), serviceCallback);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDictionaryValidAsync(List<Map<String, String>> arrayBody) {
        return putDictionaryValidWithServiceResponseAsync(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDictionaryValidWithServiceResponseAsync(List<Map<String, String>> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDictionaryValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDictionaryValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDictionaryValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Void, ErrorException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

}
