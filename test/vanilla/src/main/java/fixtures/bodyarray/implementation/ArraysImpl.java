/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.bodyarray.implementation;

import com.microsoft.rest.v2.Base64Url;
import com.microsoft.rest.v2.BodyResponse;
import com.microsoft.rest.v2.DateTimeRfc1123;
import com.microsoft.rest.v2.RestProxy;
import com.microsoft.rest.v2.ServiceCallback;
import com.microsoft.rest.v2.ServiceFuture;
import com.microsoft.rest.v2.Validator;
import com.microsoft.rest.v2.VoidResponse;
import com.microsoft.rest.v2.annotations.BodyParam;
import com.microsoft.rest.v2.annotations.ExpectedResponses;
import com.microsoft.rest.v2.annotations.GET;
import com.microsoft.rest.v2.annotations.Host;
import com.microsoft.rest.v2.annotations.PUT;
import com.microsoft.rest.v2.annotations.ReturnValueWireType;
import com.microsoft.rest.v2.annotations.UnexpectedResponseExceptionType;
import fixtures.bodyarray.Arrays;
import fixtures.bodyarray.models.ErrorException;
import fixtures.bodyarray.models.Product;
import io.reactivex.Completable;
import io.reactivex.Maybe;
import io.reactivex.Single;
import io.reactivex.annotations.NonNull;
import java.time.Duration;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * An instance of this class provides access to all the operations defined in
 * Arrays.
 */
public final class ArraysImpl implements Arrays {
    /**
     * The proxy service used to perform REST calls.
     */
    private ArraysService service;

    /**
     * The service client containing this operation class.
     */
    private AutoRestSwaggerBATArrayServiceImpl client;

    /**
     * Initializes an instance of ArraysImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    public ArraysImpl(AutoRestSwaggerBATArrayServiceImpl client) {
        this.service = RestProxy.create(ArraysService.class, client);
        this.client = client;
    }

    /**
     * The interface defining all the services for Arrays to be used by the
     * proxy service to perform REST calls.
     */
    @Host("http://localhost:3000")
    private interface ArraysService {
        @GET("array/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Integer>>> getNull();

        @GET("array/invalid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Integer>>> getInvalid();

        @GET("array/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Integer>>> getEmpty();

        @PUT("array/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putEmpty(@BodyParam("application/json; charset=utf-8") List<String> arrayBody);

        @GET("array/prim/boolean/tfft")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Boolean>>> getBooleanTfft();

        @PUT("array/prim/boolean/tfft")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putBooleanTfft(@BodyParam("application/json; charset=utf-8") List<Boolean> arrayBody);

        @GET("array/prim/boolean/true.null.false")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Boolean>>> getBooleanInvalidNull();

        @GET("array/prim/boolean/true.boolean.false")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Boolean>>> getBooleanInvalidString();

        @GET("array/prim/integer/1.-1.3.300")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Integer>>> getIntegerValid();

        @PUT("array/prim/integer/1.-1.3.300")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putIntegerValid(@BodyParam("application/json; charset=utf-8") List<Integer> arrayBody);

        @GET("array/prim/integer/1.null.zero")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Integer>>> getIntInvalidNull();

        @GET("array/prim/integer/1.integer.0")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Integer>>> getIntInvalidString();

        @GET("array/prim/long/1.-1.3.300")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Long>>> getLongValid();

        @PUT("array/prim/long/1.-1.3.300")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putLongValid(@BodyParam("application/json; charset=utf-8") List<Long> arrayBody);

        @GET("array/prim/long/1.null.zero")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Long>>> getLongInvalidNull();

        @GET("array/prim/long/1.integer.0")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Long>>> getLongInvalidString();

        @GET("array/prim/float/0--0.01-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Double>>> getFloatValid();

        @PUT("array/prim/float/0--0.01-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putFloatValid(@BodyParam("application/json; charset=utf-8") List<Double> arrayBody);

        @GET("array/prim/float/0.0-null-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Double>>> getFloatInvalidNull();

        @GET("array/prim/float/1.number.0")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Double>>> getFloatInvalidString();

        @GET("array/prim/double/0--0.01-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Double>>> getDoubleValid();

        @PUT("array/prim/double/0--0.01-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putDoubleValid(@BodyParam("application/json; charset=utf-8") List<Double> arrayBody);

        @GET("array/prim/double/0.0-null-1.2e20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Double>>> getDoubleInvalidNull();

        @GET("array/prim/double/1.number.0")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Double>>> getDoubleInvalidString();

        @GET("array/prim/string/foo1.foo2.foo3")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<String>>> getStringValid();

        @PUT("array/prim/string/foo1.foo2.foo3")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putStringValid(@BodyParam("application/json; charset=utf-8") List<String> arrayBody);

        @GET("array/prim/string/foo.null.foo2")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<String>>> getStringWithNull();

        @GET("array/prim/string/foo.123.foo2")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<String>>> getStringWithInvalid();

        @GET("array/prim/uuid/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<UUID>>> getUuidValid();

        @PUT("array/prim/uuid/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putUuidValid(@BodyParam("application/json; charset=utf-8") List<UUID> arrayBody);

        @GET("array/prim/uuid/invalidchars")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<UUID>>> getUuidInvalidChars();

        @GET("array/prim/date/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<LocalDate>>> getDateValid();

        @PUT("array/prim/date/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putDateValid(@BodyParam("application/json; charset=utf-8") List<LocalDate> arrayBody);

        @GET("array/prim/date/invalidnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<LocalDate>>> getDateInvalidNull();

        @GET("array/prim/date/invalidchars")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<LocalDate>>> getDateInvalidChars();

        @GET("array/prim/date-time/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<OffsetDateTime>>> getDateTimeValid();

        @PUT("array/prim/date-time/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putDateTimeValid(@BodyParam("application/json; charset=utf-8") List<OffsetDateTime> arrayBody);

        @GET("array/prim/date-time/invalidnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<OffsetDateTime>>> getDateTimeInvalidNull();

        @GET("array/prim/date-time/invalidchars")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<OffsetDateTime>>> getDateTimeInvalidChars();

        @GET("array/prim/date-time-rfc1123/valid")
        @ExpectedResponses({200})
        @ReturnValueWireType(DateTimeRfc1123.class)
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<OffsetDateTime>>> getDateTimeRfc1123Valid();

        @PUT("array/prim/date-time-rfc1123/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putDateTimeRfc1123Valid(@BodyParam("application/json; charset=utf-8") List<DateTimeRfc1123> arrayBody);

        @GET("array/prim/duration/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Duration>>> getDurationValid();

        @PUT("array/prim/duration/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putDurationValid(@BodyParam("application/json; charset=utf-8") List<Duration> arrayBody);

        @GET("array/prim/byte/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<byte[]>>> getByteValid();

        @PUT("array/prim/byte/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putByteValid(@BodyParam("application/json; charset=utf-8") List<byte[]> arrayBody);

        @GET("array/prim/byte/invalidnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<byte[]>>> getByteInvalidNull();

        @GET("array/prim/base64url/valid")
        @ExpectedResponses({200})
        @ReturnValueWireType(Base64Url.class)
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<byte[]>>> getBase64Url();

        @GET("array/complex/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Product>>> getComplexNull();

        @GET("array/complex/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Product>>> getComplexEmpty();

        @GET("array/complex/itemnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Product>>> getComplexItemNull();

        @GET("array/complex/itemempty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Product>>> getComplexItemEmpty();

        @GET("array/complex/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Product>>> getComplexValid();

        @PUT("array/complex/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putComplexValid(@BodyParam("application/json; charset=utf-8") List<Product> arrayBody);

        @GET("array/array/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<List<String>>>> getArrayNull();

        @GET("array/array/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<List<String>>>> getArrayEmpty();

        @GET("array/array/itemnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<List<String>>>> getArrayItemNull();

        @GET("array/array/itemempty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<List<String>>>> getArrayItemEmpty();

        @GET("array/array/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<List<String>>>> getArrayValid();

        @PUT("array/array/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putArrayValid(@BodyParam("application/json; charset=utf-8") List<List<String>> arrayBody);

        @GET("array/dictionary/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Map<String, String>>>> getDictionaryNull();

        @GET("array/dictionary/empty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Map<String, String>>>> getDictionaryEmpty();

        @GET("array/dictionary/itemnull")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Map<String, String>>>> getDictionaryItemNull();

        @GET("array/dictionary/itemempty")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Map<String, String>>>> getDictionaryItemEmpty();

        @GET("array/dictionary/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<List<Map<String, String>>>> getDictionaryValid();

        @PUT("array/dictionary/valid")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putDictionaryValid(@BodyParam("application/json; charset=utf-8") List<Map<String, String>> arrayBody);
    }

    /**
     * Get null array value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getNull() {
        return getNullAsync().blockingGet();
    }

    /**
     * Get null array value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Integer>> getNullAsync(ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromBody(getNullAsync(), serviceCallback);
    }

    /**
     * Get null array value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Integer>>> getNullWithRestResponseAsync() {
        return service.getNull();
    }

    /**
     * Get null array value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Integer>> getNullAsync() {
        return getNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Integer>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get invalid array [1, 2, 3.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getInvalid() {
        return getInvalidAsync().blockingGet();
    }

    /**
     * Get invalid array [1, 2, 3.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Integer>> getInvalidAsync(ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromBody(getInvalidAsync(), serviceCallback);
    }

    /**
     * Get invalid array [1, 2, 3.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Integer>>> getInvalidWithRestResponseAsync() {
        return service.getInvalid();
    }

    /**
     * Get invalid array [1, 2, 3.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Integer>> getInvalidAsync() {
        return getInvalidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Integer>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get empty array value [].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getEmpty() {
        return getEmptyAsync().blockingGet();
    }

    /**
     * Get empty array value [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Integer>> getEmptyAsync(ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromBody(getEmptyAsync(), serviceCallback);
    }

    /**
     * Get empty array value [].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Integer>>> getEmptyWithRestResponseAsync() {
        return service.getEmpty();
    }

    /**
     * Get empty array value [].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Integer>> getEmptyAsync() {
        return getEmptyWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Integer>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value empty [].
     *
     * @param arrayBody the List&lt;String&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putEmpty(@NonNull List<String> arrayBody) {
        putEmptyAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value empty [].
     *
     * @param arrayBody the List&lt;String&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putEmptyAsync(@NonNull List<String> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putEmptyAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value empty [].
     *
     * @param arrayBody the List&lt;String&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putEmptyWithRestResponseAsync(@NonNull List<String> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putEmpty(arrayBody);
    }

    /**
     * Set array value empty [].
     *
     * @param arrayBody the List&lt;String&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putEmptyAsync(@NonNull List<String> arrayBody) {
        return putEmptyWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get boolean array value [true, false, false, true].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Boolean&gt; object if successful.
     */
    public List<Boolean> getBooleanTfft() {
        return getBooleanTfftAsync().blockingGet();
    }

    /**
     * Get boolean array value [true, false, false, true].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Boolean>> getBooleanTfftAsync(ServiceCallback<List<Boolean>> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanTfftAsync(), serviceCallback);
    }

    /**
     * Get boolean array value [true, false, false, true].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Boolean>>> getBooleanTfftWithRestResponseAsync() {
        return service.getBooleanTfft();
    }

    /**
     * Get boolean array value [true, false, false, true].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Boolean>> getBooleanTfftAsync() {
        return getBooleanTfftWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Boolean>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value empty [true, false, false, true].
     *
     * @param arrayBody the List&lt;Boolean&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putBooleanTfft(@NonNull List<Boolean> arrayBody) {
        putBooleanTfftAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value empty [true, false, false, true].
     *
     * @param arrayBody the List&lt;Boolean&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putBooleanTfftAsync(@NonNull List<Boolean> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putBooleanTfftAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value empty [true, false, false, true].
     *
     * @param arrayBody the List&lt;Boolean&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putBooleanTfftWithRestResponseAsync(@NonNull List<Boolean> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putBooleanTfft(arrayBody);
    }

    /**
     * Set array value empty [true, false, false, true].
     *
     * @param arrayBody the List&lt;Boolean&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putBooleanTfftAsync(@NonNull List<Boolean> arrayBody) {
        return putBooleanTfftWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get boolean array value [true, null, false].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Boolean&gt; object if successful.
     */
    public List<Boolean> getBooleanInvalidNull() {
        return getBooleanInvalidNullAsync().blockingGet();
    }

    /**
     * Get boolean array value [true, null, false].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Boolean>> getBooleanInvalidNullAsync(ServiceCallback<List<Boolean>> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get boolean array value [true, null, false].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Boolean>>> getBooleanInvalidNullWithRestResponseAsync() {
        return service.getBooleanInvalidNull();
    }

    /**
     * Get boolean array value [true, null, false].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Boolean>> getBooleanInvalidNullAsync() {
        return getBooleanInvalidNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Boolean>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get boolean array value [true, 'boolean', false].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Boolean&gt; object if successful.
     */
    public List<Boolean> getBooleanInvalidString() {
        return getBooleanInvalidStringAsync().blockingGet();
    }

    /**
     * Get boolean array value [true, 'boolean', false].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Boolean>> getBooleanInvalidStringAsync(ServiceCallback<List<Boolean>> serviceCallback) {
        return ServiceFuture.fromBody(getBooleanInvalidStringAsync(), serviceCallback);
    }

    /**
     * Get boolean array value [true, 'boolean', false].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Boolean>>> getBooleanInvalidStringWithRestResponseAsync() {
        return service.getBooleanInvalidString();
    }

    /**
     * Get boolean array value [true, 'boolean', false].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Boolean>> getBooleanInvalidStringAsync() {
        return getBooleanInvalidStringWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Boolean>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getIntegerValid() {
        return getIntegerValidAsync().blockingGet();
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Integer>> getIntegerValidAsync(ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromBody(getIntegerValidAsync(), serviceCallback);
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Integer>>> getIntegerValidWithRestResponseAsync() {
        return service.getIntegerValid();
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Integer>> getIntegerValidAsync() {
        return getIntegerValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Integer>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Integer&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putIntegerValid(@NonNull List<Integer> arrayBody) {
        putIntegerValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Integer&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putIntegerValidAsync(@NonNull List<Integer> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putIntegerValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Integer&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putIntegerValidWithRestResponseAsync(@NonNull List<Integer> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putIntegerValid(arrayBody);
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Integer&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putIntegerValidAsync(@NonNull List<Integer> arrayBody) {
        return putIntegerValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get integer array value [1, null, 0].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getIntInvalidNull() {
        return getIntInvalidNullAsync().blockingGet();
    }

    /**
     * Get integer array value [1, null, 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Integer>> getIntInvalidNullAsync(ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromBody(getIntInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get integer array value [1, null, 0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Integer>>> getIntInvalidNullWithRestResponseAsync() {
        return service.getIntInvalidNull();
    }

    /**
     * Get integer array value [1, null, 0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Integer>> getIntInvalidNullAsync() {
        return getIntInvalidNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Integer>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get integer array value [1, 'integer', 0].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Integer&gt; object if successful.
     */
    public List<Integer> getIntInvalidString() {
        return getIntInvalidStringAsync().blockingGet();
    }

    /**
     * Get integer array value [1, 'integer', 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Integer>> getIntInvalidStringAsync(ServiceCallback<List<Integer>> serviceCallback) {
        return ServiceFuture.fromBody(getIntInvalidStringAsync(), serviceCallback);
    }

    /**
     * Get integer array value [1, 'integer', 0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Integer>>> getIntInvalidStringWithRestResponseAsync() {
        return service.getIntInvalidString();
    }

    /**
     * Get integer array value [1, 'integer', 0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Integer>> getIntInvalidStringAsync() {
        return getIntInvalidStringWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Integer>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Long&gt; object if successful.
     */
    public List<Long> getLongValid() {
        return getLongValidAsync().blockingGet();
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Long>> getLongValidAsync(ServiceCallback<List<Long>> serviceCallback) {
        return ServiceFuture.fromBody(getLongValidAsync(), serviceCallback);
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Long>>> getLongValidWithRestResponseAsync() {
        return service.getLongValid();
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Long>> getLongValidAsync() {
        return getLongValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Long>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Long&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putLongValid(@NonNull List<Long> arrayBody) {
        putLongValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Long&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putLongValidAsync(@NonNull List<Long> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putLongValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Long&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putLongValidWithRestResponseAsync(@NonNull List<Long> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putLongValid(arrayBody);
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Long&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putLongValidAsync(@NonNull List<Long> arrayBody) {
        return putLongValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get long array value [1, null, 0].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Long&gt; object if successful.
     */
    public List<Long> getLongInvalidNull() {
        return getLongInvalidNullAsync().blockingGet();
    }

    /**
     * Get long array value [1, null, 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Long>> getLongInvalidNullAsync(ServiceCallback<List<Long>> serviceCallback) {
        return ServiceFuture.fromBody(getLongInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get long array value [1, null, 0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Long>>> getLongInvalidNullWithRestResponseAsync() {
        return service.getLongInvalidNull();
    }

    /**
     * Get long array value [1, null, 0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Long>> getLongInvalidNullAsync() {
        return getLongInvalidNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Long>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get long array value [1, 'integer', 0].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Long&gt; object if successful.
     */
    public List<Long> getLongInvalidString() {
        return getLongInvalidStringAsync().blockingGet();
    }

    /**
     * Get long array value [1, 'integer', 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Long>> getLongInvalidStringAsync(ServiceCallback<List<Long>> serviceCallback) {
        return ServiceFuture.fromBody(getLongInvalidStringAsync(), serviceCallback);
    }

    /**
     * Get long array value [1, 'integer', 0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Long>>> getLongInvalidStringWithRestResponseAsync() {
        return service.getLongInvalidString();
    }

    /**
     * Get long array value [1, 'integer', 0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Long>> getLongInvalidStringAsync() {
        return getLongInvalidStringWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Long>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getFloatValid() {
        return getFloatValidAsync().blockingGet();
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Double>> getFloatValidAsync(ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromBody(getFloatValidAsync(), serviceCallback);
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Double>>> getFloatValidWithRestResponseAsync() {
        return service.getFloatValid();
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Double>> getFloatValidAsync() {
        return getFloatValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Double>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putFloatValid(@NonNull List<Double> arrayBody) {
        putFloatValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putFloatValidAsync(@NonNull List<Double> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putFloatValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putFloatValidWithRestResponseAsync(@NonNull List<Double> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putFloatValid(arrayBody);
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putFloatValidAsync(@NonNull List<Double> arrayBody) {
        return putFloatValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getFloatInvalidNull() {
        return getFloatInvalidNullAsync().blockingGet();
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Double>> getFloatInvalidNullAsync(ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromBody(getFloatInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Double>>> getFloatInvalidNullWithRestResponseAsync() {
        return service.getFloatInvalidNull();
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Double>> getFloatInvalidNullAsync() {
        return getFloatInvalidNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Double>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getFloatInvalidString() {
        return getFloatInvalidStringAsync().blockingGet();
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Double>> getFloatInvalidStringAsync(ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromBody(getFloatInvalidStringAsync(), serviceCallback);
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Double>>> getFloatInvalidStringWithRestResponseAsync() {
        return service.getFloatInvalidString();
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Double>> getFloatInvalidStringAsync() {
        return getFloatInvalidStringWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Double>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getDoubleValid() {
        return getDoubleValidAsync().blockingGet();
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Double>> getDoubleValidAsync(ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromBody(getDoubleValidAsync(), serviceCallback);
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Double>>> getDoubleValidWithRestResponseAsync() {
        return service.getDoubleValid();
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Double>> getDoubleValidAsync() {
        return getDoubleValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Double>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putDoubleValid(@NonNull List<Double> arrayBody) {
        putDoubleValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putDoubleValidAsync(@NonNull List<Double> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDoubleValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putDoubleValidWithRestResponseAsync(@NonNull List<Double> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDoubleValid(arrayBody);
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putDoubleValidAsync(@NonNull List<Double> arrayBody) {
        return putDoubleValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getDoubleInvalidNull() {
        return getDoubleInvalidNullAsync().blockingGet();
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Double>> getDoubleInvalidNullAsync(ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromBody(getDoubleInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Double>>> getDoubleInvalidNullWithRestResponseAsync() {
        return service.getDoubleInvalidNull();
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Double>> getDoubleInvalidNullAsync() {
        return getDoubleInvalidNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Double>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Double&gt; object if successful.
     */
    public List<Double> getDoubleInvalidString() {
        return getDoubleInvalidStringAsync().blockingGet();
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Double>> getDoubleInvalidStringAsync(ServiceCallback<List<Double>> serviceCallback) {
        return ServiceFuture.fromBody(getDoubleInvalidStringAsync(), serviceCallback);
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Double>>> getDoubleInvalidStringWithRestResponseAsync() {
        return service.getDoubleInvalidString();
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Double>> getDoubleInvalidStringAsync() {
        return getDoubleInvalidStringWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Double>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;String&gt; object if successful.
     */
    public List<String> getStringValid() {
        return getStringValidAsync().blockingGet();
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<String>> getStringValidAsync(ServiceCallback<List<String>> serviceCallback) {
        return ServiceFuture.fromBody(getStringValidAsync(), serviceCallback);
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<String>>> getStringValidWithRestResponseAsync() {
        return service.getStringValid();
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<String>> getStringValidAsync() {
        return getStringValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<String>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3'].
     *
     * @param arrayBody the List&lt;String&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putStringValid(@NonNull List<String> arrayBody) {
        putStringValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3'].
     *
     * @param arrayBody the List&lt;String&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putStringValidAsync(@NonNull List<String> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putStringValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3'].
     *
     * @param arrayBody the List&lt;String&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putStringValidWithRestResponseAsync(@NonNull List<String> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putStringValid(arrayBody);
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3'].
     *
     * @param arrayBody the List&lt;String&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putStringValidAsync(@NonNull List<String> arrayBody) {
        return putStringValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get string array value ['foo', null, 'foo2'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;String&gt; object if successful.
     */
    public List<String> getStringWithNull() {
        return getStringWithNullAsync().blockingGet();
    }

    /**
     * Get string array value ['foo', null, 'foo2'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<String>> getStringWithNullAsync(ServiceCallback<List<String>> serviceCallback) {
        return ServiceFuture.fromBody(getStringWithNullAsync(), serviceCallback);
    }

    /**
     * Get string array value ['foo', null, 'foo2'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<String>>> getStringWithNullWithRestResponseAsync() {
        return service.getStringWithNull();
    }

    /**
     * Get string array value ['foo', null, 'foo2'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<String>> getStringWithNullAsync() {
        return getStringWithNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<String>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get string array value ['foo', 123, 'foo2'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;String&gt; object if successful.
     */
    public List<String> getStringWithInvalid() {
        return getStringWithInvalidAsync().blockingGet();
    }

    /**
     * Get string array value ['foo', 123, 'foo2'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<String>> getStringWithInvalidAsync(ServiceCallback<List<String>> serviceCallback) {
        return ServiceFuture.fromBody(getStringWithInvalidAsync(), serviceCallback);
    }

    /**
     * Get string array value ['foo', 123, 'foo2'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<String>>> getStringWithInvalidWithRestResponseAsync() {
        return service.getStringWithInvalid();
    }

    /**
     * Get string array value ['foo', 123, 'foo2'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<String>> getStringWithInvalidAsync() {
        return getStringWithInvalidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<String>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;UUID&gt; object if successful.
     */
    public List<UUID> getUuidValid() {
        return getUuidValidAsync().blockingGet();
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<UUID>> getUuidValidAsync(ServiceCallback<List<UUID>> serviceCallback) {
        return ServiceFuture.fromBody(getUuidValidAsync(), serviceCallback);
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<UUID>>> getUuidValidWithRestResponseAsync() {
        return service.getUuidValid();
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<UUID>> getUuidValidAsync() {
        return getUuidValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<UUID>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param arrayBody the List&lt;UUID&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putUuidValid(@NonNull List<UUID> arrayBody) {
        putUuidValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param arrayBody the List&lt;UUID&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putUuidValidAsync(@NonNull List<UUID> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putUuidValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param arrayBody the List&lt;UUID&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putUuidValidWithRestResponseAsync(@NonNull List<UUID> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putUuidValid(arrayBody);
    }

    /**
     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param arrayBody the List&lt;UUID&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putUuidValidAsync(@NonNull List<UUID> arrayBody) {
        return putUuidValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;UUID&gt; object if successful.
     */
    public List<UUID> getUuidInvalidChars() {
        return getUuidInvalidCharsAsync().blockingGet();
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<UUID>> getUuidInvalidCharsAsync(ServiceCallback<List<UUID>> serviceCallback) {
        return ServiceFuture.fromBody(getUuidInvalidCharsAsync(), serviceCallback);
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<UUID>>> getUuidInvalidCharsWithRestResponseAsync() {
        return service.getUuidInvalidChars();
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<UUID>> getUuidInvalidCharsAsync() {
        return getUuidInvalidCharsWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<UUID>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;LocalDate&gt; object if successful.
     */
    public List<LocalDate> getDateValid() {
        return getDateValidAsync().blockingGet();
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<LocalDate>> getDateValidAsync(ServiceCallback<List<LocalDate>> serviceCallback) {
        return ServiceFuture.fromBody(getDateValidAsync(), serviceCallback);
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<LocalDate>>> getDateValidWithRestResponseAsync() {
        return service.getDateValid();
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<LocalDate>> getDateValidAsync() {
        return getDateValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<LocalDate>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param arrayBody the List&lt;LocalDate&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putDateValid(@NonNull List<LocalDate> arrayBody) {
        putDateValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param arrayBody the List&lt;LocalDate&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putDateValidAsync(@NonNull List<LocalDate> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDateValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param arrayBody the List&lt;LocalDate&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putDateValidWithRestResponseAsync(@NonNull List<LocalDate> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDateValid(arrayBody);
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param arrayBody the List&lt;LocalDate&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putDateValidAsync(@NonNull List<LocalDate> arrayBody) {
        return putDateValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;LocalDate&gt; object if successful.
     */
    public List<LocalDate> getDateInvalidNull() {
        return getDateInvalidNullAsync().blockingGet();
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<LocalDate>> getDateInvalidNullAsync(ServiceCallback<List<LocalDate>> serviceCallback) {
        return ServiceFuture.fromBody(getDateInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<LocalDate>>> getDateInvalidNullWithRestResponseAsync() {
        return service.getDateInvalidNull();
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<LocalDate>> getDateInvalidNullAsync() {
        return getDateInvalidNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<LocalDate>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get date array value ['2011-03-22', 'date'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;LocalDate&gt; object if successful.
     */
    public List<LocalDate> getDateInvalidChars() {
        return getDateInvalidCharsAsync().blockingGet();
    }

    /**
     * Get date array value ['2011-03-22', 'date'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<LocalDate>> getDateInvalidCharsAsync(ServiceCallback<List<LocalDate>> serviceCallback) {
        return ServiceFuture.fromBody(getDateInvalidCharsAsync(), serviceCallback);
    }

    /**
     * Get date array value ['2011-03-22', 'date'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<LocalDate>>> getDateInvalidCharsWithRestResponseAsync() {
        return service.getDateInvalidChars();
    }

    /**
     * Get date array value ['2011-03-22', 'date'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<LocalDate>> getDateInvalidCharsAsync() {
        return getDateInvalidCharsWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<LocalDate>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;OffsetDateTime&gt; object if successful.
     */
    public List<OffsetDateTime> getDateTimeValid() {
        return getDateTimeValidAsync().blockingGet();
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<OffsetDateTime>> getDateTimeValidAsync(ServiceCallback<List<OffsetDateTime>> serviceCallback) {
        return ServiceFuture.fromBody(getDateTimeValidAsync(), serviceCallback);
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<OffsetDateTime>>> getDateTimeValidWithRestResponseAsync() {
        return service.getDateTimeValid();
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<OffsetDateTime>> getDateTimeValidAsync() {
        return getDateTimeValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<OffsetDateTime>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param arrayBody the List&lt;OffsetDateTime&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putDateTimeValid(@NonNull List<OffsetDateTime> arrayBody) {
        putDateTimeValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param arrayBody the List&lt;OffsetDateTime&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putDateTimeValidAsync(@NonNull List<OffsetDateTime> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDateTimeValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param arrayBody the List&lt;OffsetDateTime&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putDateTimeValidWithRestResponseAsync(@NonNull List<OffsetDateTime> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDateTimeValid(arrayBody);
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param arrayBody the List&lt;OffsetDateTime&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putDateTimeValidAsync(@NonNull List<OffsetDateTime> arrayBody) {
        return putDateTimeValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;OffsetDateTime&gt; object if successful.
     */
    public List<OffsetDateTime> getDateTimeInvalidNull() {
        return getDateTimeInvalidNullAsync().blockingGet();
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<OffsetDateTime>> getDateTimeInvalidNullAsync(ServiceCallback<List<OffsetDateTime>> serviceCallback) {
        return ServiceFuture.fromBody(getDateTimeInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<OffsetDateTime>>> getDateTimeInvalidNullWithRestResponseAsync() {
        return service.getDateTimeInvalidNull();
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<OffsetDateTime>> getDateTimeInvalidNullAsync() {
        return getDateTimeInvalidNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<OffsetDateTime>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;OffsetDateTime&gt; object if successful.
     */
    public List<OffsetDateTime> getDateTimeInvalidChars() {
        return getDateTimeInvalidCharsAsync().blockingGet();
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<OffsetDateTime>> getDateTimeInvalidCharsAsync(ServiceCallback<List<OffsetDateTime>> serviceCallback) {
        return ServiceFuture.fromBody(getDateTimeInvalidCharsAsync(), serviceCallback);
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<OffsetDateTime>>> getDateTimeInvalidCharsWithRestResponseAsync() {
        return service.getDateTimeInvalidChars();
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<OffsetDateTime>> getDateTimeInvalidCharsAsync() {
        return getDateTimeInvalidCharsWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<OffsetDateTime>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;OffsetDateTime&gt; object if successful.
     */
    public List<OffsetDateTime> getDateTimeRfc1123Valid() {
        return getDateTimeRfc1123ValidAsync().blockingGet();
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<OffsetDateTime>> getDateTimeRfc1123ValidAsync(ServiceCallback<List<OffsetDateTime>> serviceCallback) {
        return ServiceFuture.fromBody(getDateTimeRfc1123ValidAsync(), serviceCallback);
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<OffsetDateTime>>> getDateTimeRfc1123ValidWithRestResponseAsync() {
        return service.getDateTimeRfc1123Valid();
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<OffsetDateTime>> getDateTimeRfc1123ValidAsync() {
        return getDateTimeRfc1123ValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<OffsetDateTime>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param arrayBody the List&lt;OffsetDateTime&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putDateTimeRfc1123Valid(@NonNull List<OffsetDateTime> arrayBody) {
        putDateTimeRfc1123ValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param arrayBody the List&lt;OffsetDateTime&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putDateTimeRfc1123ValidAsync(@NonNull List<OffsetDateTime> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDateTimeRfc1123ValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param arrayBody the List&lt;OffsetDateTime&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putDateTimeRfc1123ValidWithRestResponseAsync(@NonNull List<OffsetDateTime> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        List<DateTimeRfc1123> arrayBodyConverted = new ArrayList<DateTimeRfc1123>();
        for (OffsetDateTime item : arrayBody) {
            DateTimeRfc1123 value = new DateTimeRfc1123(item);
            arrayBodyConverted.add(value);
        }
        return service.putDateTimeRfc1123Valid(arrayBodyConverted);
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param arrayBody the List&lt;OffsetDateTime&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putDateTimeRfc1123ValidAsync(@NonNull List<OffsetDateTime> arrayBody) {
        return putDateTimeRfc1123ValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Duration&gt; object if successful.
     */
    public List<Duration> getDurationValid() {
        return getDurationValidAsync().blockingGet();
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Duration>> getDurationValidAsync(ServiceCallback<List<Duration>> serviceCallback) {
        return ServiceFuture.fromBody(getDurationValidAsync(), serviceCallback);
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Duration>>> getDurationValidWithRestResponseAsync() {
        return service.getDurationValid();
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Duration>> getDurationValidAsync() {
        return getDurationValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Duration>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param arrayBody the List&lt;Duration&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putDurationValid(@NonNull List<Duration> arrayBody) {
        putDurationValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param arrayBody the List&lt;Duration&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putDurationValidAsync(@NonNull List<Duration> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDurationValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param arrayBody the List&lt;Duration&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putDurationValidWithRestResponseAsync(@NonNull List<Duration> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDurationValid(arrayBody);
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param arrayBody the List&lt;Duration&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putDurationValidAsync(@NonNull List<Duration> arrayBody) {
        return putDurationValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;byte[]&gt; object if successful.
     */
    public List<byte[]> getByteValid() {
        return getByteValidAsync().blockingGet();
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<byte[]>> getByteValidAsync(ServiceCallback<List<byte[]>> serviceCallback) {
        return ServiceFuture.fromBody(getByteValidAsync(), serviceCallback);
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<byte[]>>> getByteValidWithRestResponseAsync() {
        return service.getByteValid();
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<byte[]>> getByteValidAsync() {
        return getByteValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<byte[]>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.
     *
     * @param arrayBody the List&lt;byte[]&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putByteValid(@NonNull List<byte[]> arrayBody) {
        putByteValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.
     *
     * @param arrayBody the List&lt;byte[]&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putByteValidAsync(@NonNull List<byte[]> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putByteValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.
     *
     * @param arrayBody the List&lt;byte[]&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putByteValidWithRestResponseAsync(@NonNull List<byte[]> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putByteValid(arrayBody);
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.
     *
     * @param arrayBody the List&lt;byte[]&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putByteValidAsync(@NonNull List<byte[]> arrayBody) {
        return putByteValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;byte[]&gt; object if successful.
     */
    public List<byte[]> getByteInvalidNull() {
        return getByteInvalidNullAsync().blockingGet();
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<byte[]>> getByteInvalidNullAsync(ServiceCallback<List<byte[]>> serviceCallback) {
        return ServiceFuture.fromBody(getByteInvalidNullAsync(), serviceCallback);
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<byte[]>>> getByteInvalidNullWithRestResponseAsync() {
        return service.getByteInvalidNull();
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<byte[]>> getByteInvalidNullAsync() {
        return getByteInvalidNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<byte[]>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;byte[]&gt; object if successful.
     */
    public List<byte[]> getBase64Url() {
        return getBase64UrlAsync().blockingGet();
    }

    /**
     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<byte[]>> getBase64UrlAsync(ServiceCallback<List<byte[]>> serviceCallback) {
        return ServiceFuture.fromBody(getBase64UrlAsync(), serviceCallback);
    }

    /**
     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<byte[]>>> getBase64UrlWithRestResponseAsync() {
        return service.getBase64Url();
    }

    /**
     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<byte[]>> getBase64UrlAsync() {
        return getBase64UrlWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<byte[]>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get array of complex type null value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Product&gt; object if successful.
     */
    public List<Product> getComplexNull() {
        return getComplexNullAsync().blockingGet();
    }

    /**
     * Get array of complex type null value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Product>> getComplexNullAsync(ServiceCallback<List<Product>> serviceCallback) {
        return ServiceFuture.fromBody(getComplexNullAsync(), serviceCallback);
    }

    /**
     * Get array of complex type null value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Product>>> getComplexNullWithRestResponseAsync() {
        return service.getComplexNull();
    }

    /**
     * Get array of complex type null value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Product>> getComplexNullAsync() {
        return getComplexNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Product>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get empty array of complex type [].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Product&gt; object if successful.
     */
    public List<Product> getComplexEmpty() {
        return getComplexEmptyAsync().blockingGet();
    }

    /**
     * Get empty array of complex type [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Product>> getComplexEmptyAsync(ServiceCallback<List<Product>> serviceCallback) {
        return ServiceFuture.fromBody(getComplexEmptyAsync(), serviceCallback);
    }

    /**
     * Get empty array of complex type [].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Product>>> getComplexEmptyWithRestResponseAsync() {
        return service.getComplexEmpty();
    }

    /**
     * Get empty array of complex type [].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Product>> getComplexEmptyAsync() {
        return getComplexEmptyWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Product>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Product&gt; object if successful.
     */
    public List<Product> getComplexItemNull() {
        return getComplexItemNullAsync().blockingGet();
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Product>> getComplexItemNullAsync(ServiceCallback<List<Product>> serviceCallback) {
        return ServiceFuture.fromBody(getComplexItemNullAsync(), serviceCallback);
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Product>>> getComplexItemNullWithRestResponseAsync() {
        return service.getComplexItemNull();
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Product>> getComplexItemNullAsync() {
        return getComplexItemNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Product>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Product&gt; object if successful.
     */
    public List<Product> getComplexItemEmpty() {
        return getComplexItemEmptyAsync().blockingGet();
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Product>> getComplexItemEmptyAsync(ServiceCallback<List<Product>> serviceCallback) {
        return ServiceFuture.fromBody(getComplexItemEmptyAsync(), serviceCallback);
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Product>>> getComplexItemEmptyWithRestResponseAsync() {
        return service.getComplexItemEmpty();
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Product>> getComplexItemEmptyAsync() {
        return getComplexItemEmptyWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Product>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Product&gt; object if successful.
     */
    public List<Product> getComplexValid() {
        return getComplexValidAsync().blockingGet();
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Product>> getComplexValidAsync(ServiceCallback<List<Product>> serviceCallback) {
        return ServiceFuture.fromBody(getComplexValidAsync(), serviceCallback);
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Product>>> getComplexValidWithRestResponseAsync() {
        return service.getComplexValid();
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Product>> getComplexValidAsync() {
        return getComplexValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Product>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param arrayBody the List&lt;Product&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putComplexValid(@NonNull List<Product> arrayBody) {
        putComplexValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param arrayBody the List&lt;Product&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putComplexValidAsync(@NonNull List<Product> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putComplexValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param arrayBody the List&lt;Product&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putComplexValidWithRestResponseAsync(@NonNull List<Product> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putComplexValid(arrayBody);
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param arrayBody the List&lt;Product&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putComplexValidAsync(@NonNull List<Product> arrayBody) {
        return putComplexValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get a null array.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     */
    public List<List<String>> getArrayNull() {
        return getArrayNullAsync().blockingGet();
    }

    /**
     * Get a null array.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<List<String>>> getArrayNullAsync(ServiceCallback<List<List<String>>> serviceCallback) {
        return ServiceFuture.fromBody(getArrayNullAsync(), serviceCallback);
    }

    /**
     * Get a null array.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<List<String>>>> getArrayNullWithRestResponseAsync() {
        return service.getArrayNull();
    }

    /**
     * Get a null array.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<List<String>>> getArrayNullAsync() {
        return getArrayNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<List<String>>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get an empty array [].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     */
    public List<List<String>> getArrayEmpty() {
        return getArrayEmptyAsync().blockingGet();
    }

    /**
     * Get an empty array [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<List<String>>> getArrayEmptyAsync(ServiceCallback<List<List<String>>> serviceCallback) {
        return ServiceFuture.fromBody(getArrayEmptyAsync(), serviceCallback);
    }

    /**
     * Get an empty array [].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<List<String>>>> getArrayEmptyWithRestResponseAsync() {
        return service.getArrayEmpty();
    }

    /**
     * Get an empty array [].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<List<String>>> getArrayEmptyAsync() {
        return getArrayEmptyWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<List<String>>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     */
    public List<List<String>> getArrayItemNull() {
        return getArrayItemNullAsync().blockingGet();
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<List<String>>> getArrayItemNullAsync(ServiceCallback<List<List<String>>> serviceCallback) {
        return ServiceFuture.fromBody(getArrayItemNullAsync(), serviceCallback);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<List<String>>>> getArrayItemNullWithRestResponseAsync() {
        return service.getArrayItemNull();
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<List<String>>> getArrayItemNullAsync() {
        return getArrayItemNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<List<String>>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     */
    public List<List<String>> getArrayItemEmpty() {
        return getArrayItemEmptyAsync().blockingGet();
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<List<String>>> getArrayItemEmptyAsync(ServiceCallback<List<List<String>>> serviceCallback) {
        return ServiceFuture.fromBody(getArrayItemEmptyAsync(), serviceCallback);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<List<String>>>> getArrayItemEmptyWithRestResponseAsync() {
        return service.getArrayItemEmpty();
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<List<String>>> getArrayItemEmptyAsync() {
        return getArrayItemEmptyWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<List<String>>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     */
    public List<List<String>> getArrayValid() {
        return getArrayValidAsync().blockingGet();
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<List<String>>> getArrayValidAsync(ServiceCallback<List<List<String>>> serviceCallback) {
        return ServiceFuture.fromBody(getArrayValidAsync(), serviceCallback);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<List<String>>>> getArrayValidWithRestResponseAsync() {
        return service.getArrayValid();
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<List<String>>> getArrayValidAsync() {
        return getArrayValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<List<String>>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putArrayValid(@NonNull List<List<String>> arrayBody) {
        putArrayValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putArrayValidAsync(@NonNull List<List<String>> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putArrayValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putArrayValidWithRestResponseAsync(@NonNull List<List<String>> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putArrayValid(arrayBody);
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putArrayValidAsync(@NonNull List<List<String>> arrayBody) {
        return putArrayValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }

    /**
     * Get an array of Dictionaries with value null.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     */
    public List<Map<String, String>> getDictionaryNull() {
        return getDictionaryNullAsync().blockingGet();
    }

    /**
     * Get an array of Dictionaries with value null.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Map<String, String>>> getDictionaryNullAsync(ServiceCallback<List<Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromBody(getDictionaryNullAsync(), serviceCallback);
    }

    /**
     * Get an array of Dictionaries with value null.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Map<String, String>>>> getDictionaryNullWithRestResponseAsync() {
        return service.getDictionaryNull();
    }

    /**
     * Get an array of Dictionaries with value null.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Map<String, String>>> getDictionaryNullAsync() {
        return getDictionaryNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Map<String, String>>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     */
    public List<Map<String, String>> getDictionaryEmpty() {
        return getDictionaryEmptyAsync().blockingGet();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Map<String, String>>> getDictionaryEmptyAsync(ServiceCallback<List<Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromBody(getDictionaryEmptyAsync(), serviceCallback);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Map<String, String>>>> getDictionaryEmptyWithRestResponseAsync() {
        return service.getDictionaryEmpty();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Map<String, String>>> getDictionaryEmptyAsync() {
        return getDictionaryEmptyWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Map<String, String>>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     */
    public List<Map<String, String>> getDictionaryItemNull() {
        return getDictionaryItemNullAsync().blockingGet();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Map<String, String>>> getDictionaryItemNullAsync(ServiceCallback<List<Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromBody(getDictionaryItemNullAsync(), serviceCallback);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Map<String, String>>>> getDictionaryItemNullWithRestResponseAsync() {
        return service.getDictionaryItemNull();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Map<String, String>>> getDictionaryItemNullAsync() {
        return getDictionaryItemNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Map<String, String>>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     */
    public List<Map<String, String>> getDictionaryItemEmpty() {
        return getDictionaryItemEmptyAsync().blockingGet();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Map<String, String>>> getDictionaryItemEmptyAsync(ServiceCallback<List<Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromBody(getDictionaryItemEmptyAsync(), serviceCallback);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Map<String, String>>>> getDictionaryItemEmptyWithRestResponseAsync() {
        return service.getDictionaryItemEmpty();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Map<String, String>>> getDictionaryItemEmptyAsync() {
        return getDictionaryItemEmptyWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Map<String, String>>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     */
    public List<Map<String, String>> getDictionaryValid() {
        return getDictionaryValidAsync().blockingGet();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<List<Map<String, String>>> getDictionaryValidAsync(ServiceCallback<List<Map<String, String>>> serviceCallback) {
        return ServiceFuture.fromBody(getDictionaryValidAsync(), serviceCallback);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<List<Map<String, String>>>> getDictionaryValidWithRestResponseAsync() {
        return service.getDictionaryValid();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<List<Map<String, String>>> getDictionaryValidAsync() {
        return getDictionaryValidWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<List<Map<String, String>>> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putDictionaryValid(@NonNull List<Map<String, String>> arrayBody) {
        putDictionaryValidAsync(arrayBody).blockingAwait();
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putDictionaryValidAsync(@NonNull List<Map<String, String>> arrayBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putDictionaryValidAsync(arrayBody), serviceCallback);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putDictionaryValidWithRestResponseAsync(@NonNull List<Map<String, String>> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDictionaryValid(arrayBody);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putDictionaryValidAsync(@NonNull List<Map<String, String>> arrayBody) {
        return putDictionaryValidWithRestResponseAsync(arrayBody)
            .toCompletable();
    }
}
