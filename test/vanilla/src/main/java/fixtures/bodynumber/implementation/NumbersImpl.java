/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.bodynumber.implementation;

import com.microsoft.rest.v2.BodyResponse;
import com.microsoft.rest.v2.RestProxy;
import com.microsoft.rest.v2.ServiceCallback;
import com.microsoft.rest.v2.ServiceFuture;
import com.microsoft.rest.v2.VoidResponse;
import com.microsoft.rest.v2.annotations.BodyParam;
import com.microsoft.rest.v2.annotations.ExpectedResponses;
import com.microsoft.rest.v2.annotations.GET;
import com.microsoft.rest.v2.annotations.Host;
import com.microsoft.rest.v2.annotations.PUT;
import com.microsoft.rest.v2.annotations.UnexpectedResponseExceptionType;
import fixtures.bodynumber.Numbers;
import fixtures.bodynumber.models.ErrorException;
import io.reactivex.Completable;
import io.reactivex.Maybe;
import io.reactivex.Single;
import io.reactivex.annotations.NonNull;
import java.math.BigDecimal;

/**
 * An instance of this class provides access to all the operations defined in
 * Numbers.
 */
public final class NumbersImpl implements Numbers {
    /**
     * The proxy service used to perform REST calls.
     */
    private NumbersService service;

    /**
     * The service client containing this operation class.
     */
    private AutoRestNumberTestServiceImpl client;

    /**
     * Initializes an instance of NumbersImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    public NumbersImpl(AutoRestNumberTestServiceImpl client) {
        this.service = RestProxy.create(NumbersService.class, client);
        this.client = client;
    }

    /**
     * The interface defining all the services for Numbers to be used by the
     * proxy service to perform REST calls.
     */
    @Host("http://localhost:3000")
    private interface NumbersService {
        @GET("number/null")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<Double>> getNull();

        @GET("number/invalidfloat")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<Double>> getInvalidFloat();

        @GET("number/invaliddouble")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<Double>> getInvalidDouble();

        @GET("number/invaliddecimal")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<BigDecimal>> getInvalidDecimal();

        @PUT("number/big/float/3.402823e+20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putBigFloat(@BodyParam("application/json; charset=utf-8") double numberBody);

        @GET("number/big/float/3.402823e+20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<Double>> getBigFloat();

        @PUT("number/big/double/2.5976931e+101")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putBigDouble(@BodyParam("application/json; charset=utf-8") double numberBody);

        @GET("number/big/double/2.5976931e+101")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<Double>> getBigDouble();

        @PUT("number/big/double/99999999.99")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putBigDoublePositiveDecimal(@BodyParam("application/json; charset=utf-8") double numberBody);

        @GET("number/big/double/99999999.99")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<Double>> getBigDoublePositiveDecimal();

        @PUT("number/big/double/-99999999.99")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putBigDoubleNegativeDecimal(@BodyParam("application/json; charset=utf-8") double numberBody);

        @GET("number/big/double/-99999999.99")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<Double>> getBigDoubleNegativeDecimal();

        @PUT("number/big/decimal/2.5976931e+101")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putBigDecimal(@BodyParam("application/json; charset=utf-8") BigDecimal numberBody);

        @GET("number/big/decimal/2.5976931e+101")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<BigDecimal>> getBigDecimal();

        @PUT("number/big/decimal/99999999.99")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putBigDecimalPositiveDecimal(@BodyParam("application/json; charset=utf-8") BigDecimal numberBody);

        @GET("number/big/decimal/99999999.99")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<BigDecimal>> getBigDecimalPositiveDecimal();

        @PUT("number/big/decimal/-99999999.99")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putBigDecimalNegativeDecimal(@BodyParam("application/json; charset=utf-8") BigDecimal numberBody);

        @GET("number/big/decimal/-99999999.99")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<BigDecimal>> getBigDecimalNegativeDecimal();

        @PUT("number/small/float/3.402823e-20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putSmallFloat(@BodyParam("application/json; charset=utf-8") double numberBody);

        @GET("number/small/float/3.402823e-20")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<Double>> getSmallFloat();

        @PUT("number/small/double/2.5976931e-101")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putSmallDouble(@BodyParam("application/json; charset=utf-8") double numberBody);

        @GET("number/small/double/2.5976931e-101")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<Double>> getSmallDouble();

        @PUT("number/small/decimal/2.5976931e-101")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<VoidResponse> putSmallDecimal(@BodyParam("application/json; charset=utf-8") BigDecimal numberBody);

        @GET("number/small/decimal/2.5976931e-101")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Single<BodyResponse<BigDecimal>> getSmallDecimal();
    }

    /**
     * Get null Number value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the double object if successful.
     */
    public double getNull() {
        return getNullAsync().blockingGet();
    }

    /**
     * Get null Number value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Double> getNullAsync(ServiceCallback<Double> serviceCallback) {
        return ServiceFuture.fromBody(getNullAsync(), serviceCallback);
    }

    /**
     * Get null Number value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<Double>> getNullWithRestResponseAsync() {
        return service.getNull();
    }

    /**
     * Get null Number value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<Double> getNullAsync() {
        return getNullWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<Double> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get invalid float Number value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the double object if successful.
     */
    public double getInvalidFloat() {
        return getInvalidFloatAsync().blockingGet();
    }

    /**
     * Get invalid float Number value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Double> getInvalidFloatAsync(ServiceCallback<Double> serviceCallback) {
        return ServiceFuture.fromBody(getInvalidFloatAsync(), serviceCallback);
    }

    /**
     * Get invalid float Number value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<Double>> getInvalidFloatWithRestResponseAsync() {
        return service.getInvalidFloat();
    }

    /**
     * Get invalid float Number value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<Double> getInvalidFloatAsync() {
        return getInvalidFloatWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<Double> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get invalid double Number value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the double object if successful.
     */
    public double getInvalidDouble() {
        return getInvalidDoubleAsync().blockingGet();
    }

    /**
     * Get invalid double Number value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Double> getInvalidDoubleAsync(ServiceCallback<Double> serviceCallback) {
        return ServiceFuture.fromBody(getInvalidDoubleAsync(), serviceCallback);
    }

    /**
     * Get invalid double Number value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<Double>> getInvalidDoubleWithRestResponseAsync() {
        return service.getInvalidDouble();
    }

    /**
     * Get invalid double Number value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<Double> getInvalidDoubleAsync() {
        return getInvalidDoubleWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<Double> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Get invalid decimal Number value.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the BigDecimal object if successful.
     */
    public BigDecimal getInvalidDecimal() {
        return getInvalidDecimalAsync().blockingGet();
    }

    /**
     * Get invalid decimal Number value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<BigDecimal> getInvalidDecimalAsync(ServiceCallback<BigDecimal> serviceCallback) {
        return ServiceFuture.fromBody(getInvalidDecimalAsync(), serviceCallback);
    }

    /**
     * Get invalid decimal Number value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<BigDecimal>> getInvalidDecimalWithRestResponseAsync() {
        return service.getInvalidDecimal();
    }

    /**
     * Get invalid decimal Number value.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<BigDecimal> getInvalidDecimalAsync() {
        return getInvalidDecimalWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<BigDecimal> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put big float value 3.402823e+20.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putBigFloat(@NonNull double numberBody) {
        putBigFloatAsync(numberBody).blockingAwait();
    }

    /**
     * Put big float value 3.402823e+20.
     *
     * @param numberBody the double value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putBigFloatAsync(@NonNull double numberBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putBigFloatAsync(numberBody), serviceCallback);
    }

    /**
     * Put big float value 3.402823e+20.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putBigFloatWithRestResponseAsync(@NonNull double numberBody) {
        return service.putBigFloat(numberBody);
    }

    /**
     * Put big float value 3.402823e+20.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putBigFloatAsync(@NonNull double numberBody) {
        return putBigFloatWithRestResponseAsync(numberBody)
            .toCompletable();
    }

    /**
     * Get big float value 3.402823e+20.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the double object if successful.
     */
    public double getBigFloat() {
        return getBigFloatAsync().blockingGet();
    }

    /**
     * Get big float value 3.402823e+20.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Double> getBigFloatAsync(ServiceCallback<Double> serviceCallback) {
        return ServiceFuture.fromBody(getBigFloatAsync(), serviceCallback);
    }

    /**
     * Get big float value 3.402823e+20.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<Double>> getBigFloatWithRestResponseAsync() {
        return service.getBigFloat();
    }

    /**
     * Get big float value 3.402823e+20.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<Double> getBigFloatAsync() {
        return getBigFloatWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<Double> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put big double value 2.5976931e+101.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putBigDouble(@NonNull double numberBody) {
        putBigDoubleAsync(numberBody).blockingAwait();
    }

    /**
     * Put big double value 2.5976931e+101.
     *
     * @param numberBody the double value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putBigDoubleAsync(@NonNull double numberBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putBigDoubleAsync(numberBody), serviceCallback);
    }

    /**
     * Put big double value 2.5976931e+101.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putBigDoubleWithRestResponseAsync(@NonNull double numberBody) {
        return service.putBigDouble(numberBody);
    }

    /**
     * Put big double value 2.5976931e+101.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putBigDoubleAsync(@NonNull double numberBody) {
        return putBigDoubleWithRestResponseAsync(numberBody)
            .toCompletable();
    }

    /**
     * Get big double value 2.5976931e+101.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the double object if successful.
     */
    public double getBigDouble() {
        return getBigDoubleAsync().blockingGet();
    }

    /**
     * Get big double value 2.5976931e+101.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Double> getBigDoubleAsync(ServiceCallback<Double> serviceCallback) {
        return ServiceFuture.fromBody(getBigDoubleAsync(), serviceCallback);
    }

    /**
     * Get big double value 2.5976931e+101.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<Double>> getBigDoubleWithRestResponseAsync() {
        return service.getBigDouble();
    }

    /**
     * Get big double value 2.5976931e+101.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<Double> getBigDoubleAsync() {
        return getBigDoubleWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<Double> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put big double value 99999999.99.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putBigDoublePositiveDecimal() {
        putBigDoublePositiveDecimalAsync().blockingAwait();
    }

    /**
     * Put big double value 99999999.99.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putBigDoublePositiveDecimalAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putBigDoublePositiveDecimalAsync(), serviceCallback);
    }

    /**
     * Put big double value 99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putBigDoublePositiveDecimalWithRestResponseAsync() {
        final double numberBody = 99999999.99;
        return service.putBigDoublePositiveDecimal(numberBody);
    }

    /**
     * Put big double value 99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putBigDoublePositiveDecimalAsync() {
        return putBigDoublePositiveDecimalWithRestResponseAsync()
            .toCompletable();
    }

    /**
     * Get big double value 99999999.99.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the double object if successful.
     */
    public double getBigDoublePositiveDecimal() {
        return getBigDoublePositiveDecimalAsync().blockingGet();
    }

    /**
     * Get big double value 99999999.99.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Double> getBigDoublePositiveDecimalAsync(ServiceCallback<Double> serviceCallback) {
        return ServiceFuture.fromBody(getBigDoublePositiveDecimalAsync(), serviceCallback);
    }

    /**
     * Get big double value 99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<Double>> getBigDoublePositiveDecimalWithRestResponseAsync() {
        return service.getBigDoublePositiveDecimal();
    }

    /**
     * Get big double value 99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<Double> getBigDoublePositiveDecimalAsync() {
        return getBigDoublePositiveDecimalWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<Double> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put big double value -99999999.99.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putBigDoubleNegativeDecimal() {
        putBigDoubleNegativeDecimalAsync().blockingAwait();
    }

    /**
     * Put big double value -99999999.99.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putBigDoubleNegativeDecimalAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putBigDoubleNegativeDecimalAsync(), serviceCallback);
    }

    /**
     * Put big double value -99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putBigDoubleNegativeDecimalWithRestResponseAsync() {
        final double numberBody = -99999999.99;
        return service.putBigDoubleNegativeDecimal(numberBody);
    }

    /**
     * Put big double value -99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putBigDoubleNegativeDecimalAsync() {
        return putBigDoubleNegativeDecimalWithRestResponseAsync()
            .toCompletable();
    }

    /**
     * Get big double value -99999999.99.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the double object if successful.
     */
    public double getBigDoubleNegativeDecimal() {
        return getBigDoubleNegativeDecimalAsync().blockingGet();
    }

    /**
     * Get big double value -99999999.99.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Double> getBigDoubleNegativeDecimalAsync(ServiceCallback<Double> serviceCallback) {
        return ServiceFuture.fromBody(getBigDoubleNegativeDecimalAsync(), serviceCallback);
    }

    /**
     * Get big double value -99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<Double>> getBigDoubleNegativeDecimalWithRestResponseAsync() {
        return service.getBigDoubleNegativeDecimal();
    }

    /**
     * Get big double value -99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<Double> getBigDoubleNegativeDecimalAsync() {
        return getBigDoubleNegativeDecimalWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<Double> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put big decimal value 2.5976931e+101.
     *
     * @param numberBody the BigDecimal value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putBigDecimal(@NonNull BigDecimal numberBody) {
        putBigDecimalAsync(numberBody).blockingAwait();
    }

    /**
     * Put big decimal value 2.5976931e+101.
     *
     * @param numberBody the BigDecimal value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putBigDecimalAsync(@NonNull BigDecimal numberBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putBigDecimalAsync(numberBody), serviceCallback);
    }

    /**
     * Put big decimal value 2.5976931e+101.
     *
     * @param numberBody the BigDecimal value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putBigDecimalWithRestResponseAsync(@NonNull BigDecimal numberBody) {
        if (numberBody == null) {
            throw new IllegalArgumentException("Parameter numberBody is required and cannot be null.");
        }
        return service.putBigDecimal(numberBody);
    }

    /**
     * Put big decimal value 2.5976931e+101.
     *
     * @param numberBody the BigDecimal value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putBigDecimalAsync(@NonNull BigDecimal numberBody) {
        return putBigDecimalWithRestResponseAsync(numberBody)
            .toCompletable();
    }

    /**
     * Get big decimal value 2.5976931e+101.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the BigDecimal object if successful.
     */
    public BigDecimal getBigDecimal() {
        return getBigDecimalAsync().blockingGet();
    }

    /**
     * Get big decimal value 2.5976931e+101.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<BigDecimal> getBigDecimalAsync(ServiceCallback<BigDecimal> serviceCallback) {
        return ServiceFuture.fromBody(getBigDecimalAsync(), serviceCallback);
    }

    /**
     * Get big decimal value 2.5976931e+101.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<BigDecimal>> getBigDecimalWithRestResponseAsync() {
        return service.getBigDecimal();
    }

    /**
     * Get big decimal value 2.5976931e+101.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<BigDecimal> getBigDecimalAsync() {
        return getBigDecimalWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<BigDecimal> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put big decimal value 99999999.99.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putBigDecimalPositiveDecimal() {
        putBigDecimalPositiveDecimalAsync().blockingAwait();
    }

    /**
     * Put big decimal value 99999999.99.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putBigDecimalPositiveDecimalAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putBigDecimalPositiveDecimalAsync(), serviceCallback);
    }

    /**
     * Put big decimal value 99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putBigDecimalPositiveDecimalWithRestResponseAsync() {
        final BigDecimal numberBody = new BigDecimal("99999999.99");
        return service.putBigDecimalPositiveDecimal(numberBody);
    }

    /**
     * Put big decimal value 99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putBigDecimalPositiveDecimalAsync() {
        return putBigDecimalPositiveDecimalWithRestResponseAsync()
            .toCompletable();
    }

    /**
     * Get big decimal value 99999999.99.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the BigDecimal object if successful.
     */
    public BigDecimal getBigDecimalPositiveDecimal() {
        return getBigDecimalPositiveDecimalAsync().blockingGet();
    }

    /**
     * Get big decimal value 99999999.99.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<BigDecimal> getBigDecimalPositiveDecimalAsync(ServiceCallback<BigDecimal> serviceCallback) {
        return ServiceFuture.fromBody(getBigDecimalPositiveDecimalAsync(), serviceCallback);
    }

    /**
     * Get big decimal value 99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<BigDecimal>> getBigDecimalPositiveDecimalWithRestResponseAsync() {
        return service.getBigDecimalPositiveDecimal();
    }

    /**
     * Get big decimal value 99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<BigDecimal> getBigDecimalPositiveDecimalAsync() {
        return getBigDecimalPositiveDecimalWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<BigDecimal> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put big decimal value -99999999.99.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putBigDecimalNegativeDecimal() {
        putBigDecimalNegativeDecimalAsync().blockingAwait();
    }

    /**
     * Put big decimal value -99999999.99.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putBigDecimalNegativeDecimalAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putBigDecimalNegativeDecimalAsync(), serviceCallback);
    }

    /**
     * Put big decimal value -99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putBigDecimalNegativeDecimalWithRestResponseAsync() {
        final BigDecimal numberBody = new BigDecimal("-99999999.99");
        return service.putBigDecimalNegativeDecimal(numberBody);
    }

    /**
     * Put big decimal value -99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putBigDecimalNegativeDecimalAsync() {
        return putBigDecimalNegativeDecimalWithRestResponseAsync()
            .toCompletable();
    }

    /**
     * Get big decimal value -99999999.99.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the BigDecimal object if successful.
     */
    public BigDecimal getBigDecimalNegativeDecimal() {
        return getBigDecimalNegativeDecimalAsync().blockingGet();
    }

    /**
     * Get big decimal value -99999999.99.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<BigDecimal> getBigDecimalNegativeDecimalAsync(ServiceCallback<BigDecimal> serviceCallback) {
        return ServiceFuture.fromBody(getBigDecimalNegativeDecimalAsync(), serviceCallback);
    }

    /**
     * Get big decimal value -99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<BigDecimal>> getBigDecimalNegativeDecimalWithRestResponseAsync() {
        return service.getBigDecimalNegativeDecimal();
    }

    /**
     * Get big decimal value -99999999.99.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<BigDecimal> getBigDecimalNegativeDecimalAsync() {
        return getBigDecimalNegativeDecimalWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<BigDecimal> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put small float value 3.402823e-20.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putSmallFloat(@NonNull double numberBody) {
        putSmallFloatAsync(numberBody).blockingAwait();
    }

    /**
     * Put small float value 3.402823e-20.
     *
     * @param numberBody the double value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putSmallFloatAsync(@NonNull double numberBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putSmallFloatAsync(numberBody), serviceCallback);
    }

    /**
     * Put small float value 3.402823e-20.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putSmallFloatWithRestResponseAsync(@NonNull double numberBody) {
        return service.putSmallFloat(numberBody);
    }

    /**
     * Put small float value 3.402823e-20.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putSmallFloatAsync(@NonNull double numberBody) {
        return putSmallFloatWithRestResponseAsync(numberBody)
            .toCompletable();
    }

    /**
     * Get big double value 3.402823e-20.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the double object if successful.
     */
    public double getSmallFloat() {
        return getSmallFloatAsync().blockingGet();
    }

    /**
     * Get big double value 3.402823e-20.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Double> getSmallFloatAsync(ServiceCallback<Double> serviceCallback) {
        return ServiceFuture.fromBody(getSmallFloatAsync(), serviceCallback);
    }

    /**
     * Get big double value 3.402823e-20.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<Double>> getSmallFloatWithRestResponseAsync() {
        return service.getSmallFloat();
    }

    /**
     * Get big double value 3.402823e-20.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<Double> getSmallFloatAsync() {
        return getSmallFloatWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<Double> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put small double value 2.5976931e-101.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putSmallDouble(@NonNull double numberBody) {
        putSmallDoubleAsync(numberBody).blockingAwait();
    }

    /**
     * Put small double value 2.5976931e-101.
     *
     * @param numberBody the double value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putSmallDoubleAsync(@NonNull double numberBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putSmallDoubleAsync(numberBody), serviceCallback);
    }

    /**
     * Put small double value 2.5976931e-101.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putSmallDoubleWithRestResponseAsync(@NonNull double numberBody) {
        return service.putSmallDouble(numberBody);
    }

    /**
     * Put small double value 2.5976931e-101.
     *
     * @param numberBody the double value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putSmallDoubleAsync(@NonNull double numberBody) {
        return putSmallDoubleWithRestResponseAsync(numberBody)
            .toCompletable();
    }

    /**
     * Get big double value 2.5976931e-101.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the double object if successful.
     */
    public double getSmallDouble() {
        return getSmallDoubleAsync().blockingGet();
    }

    /**
     * Get big double value 2.5976931e-101.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Double> getSmallDoubleAsync(ServiceCallback<Double> serviceCallback) {
        return ServiceFuture.fromBody(getSmallDoubleAsync(), serviceCallback);
    }

    /**
     * Get big double value 2.5976931e-101.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<Double>> getSmallDoubleWithRestResponseAsync() {
        return service.getSmallDouble();
    }

    /**
     * Get big double value 2.5976931e-101.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<Double> getSmallDoubleAsync() {
        return getSmallDoubleWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<Double> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }

    /**
     * Put small decimal value 2.5976931e-101.
     *
     * @param numberBody the BigDecimal value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public void putSmallDecimal(@NonNull BigDecimal numberBody) {
        putSmallDecimalAsync(numberBody).blockingAwait();
    }

    /**
     * Put small decimal value 2.5976931e-101.
     *
     * @param numberBody the BigDecimal value.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<Void> putSmallDecimalAsync(@NonNull BigDecimal numberBody, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(putSmallDecimalAsync(numberBody), serviceCallback);
    }

    /**
     * Put small decimal value 2.5976931e-101.
     *
     * @param numberBody the BigDecimal value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Single<VoidResponse> putSmallDecimalWithRestResponseAsync(@NonNull BigDecimal numberBody) {
        if (numberBody == null) {
            throw new IllegalArgumentException("Parameter numberBody is required and cannot be null.");
        }
        return service.putSmallDecimal(numberBody);
    }

    /**
     * Put small decimal value 2.5976931e-101.
     *
     * @param numberBody the BigDecimal value.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Single which performs the network request upon subscription.
     */
    public Completable putSmallDecimalAsync(@NonNull BigDecimal numberBody) {
        return putSmallDecimalWithRestResponseAsync(numberBody)
            .toCompletable();
    }

    /**
     * Get small decimal value 2.5976931e-101.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the BigDecimal object if successful.
     */
    public BigDecimal getSmallDecimal() {
        return getSmallDecimalAsync().blockingGet();
    }

    /**
     * Get small decimal value 2.5976931e-101.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a ServiceFuture which will be completed with the result of the network request.
     */
    public ServiceFuture<BigDecimal> getSmallDecimalAsync(ServiceCallback<BigDecimal> serviceCallback) {
        return ServiceFuture.fromBody(getSmallDecimalAsync(), serviceCallback);
    }

    /**
     * Get small decimal value 2.5976931e-101.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Single<BodyResponse<BigDecimal>> getSmallDecimalWithRestResponseAsync() {
        return service.getSmallDecimal();
    }

    /**
     * Get small decimal value 2.5976931e-101.
     *
     * @return a Single which performs the network request upon subscription.
     */
    public Maybe<BigDecimal> getSmallDecimalAsync() {
        return getSmallDecimalWithRestResponseAsync()
            .flatMapMaybe((BodyResponse<BigDecimal> res) -> res.body() == null ? Maybe.empty() : Maybe.just(res.body()));
    }
}
