// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

package fixtures.report.implementation;

import com.azure.core.http.HttpPipeline;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.implementation.RestProxy;
import com.azure.core.implementation.annotation.ExpectedResponses;
import com.azure.core.implementation.annotation.Get;
import com.azure.core.implementation.annotation.Host;
import com.azure.core.implementation.annotation.QueryParam;
import com.azure.core.implementation.annotation.ReturnType;
import com.azure.core.implementation.annotation.ServiceInterface;
import com.azure.core.implementation.annotation.ServiceMethod;
import com.azure.core.implementation.annotation.UnexpectedResponseExceptionType;
import fixtures.report.AutoRestReportService;
import fixtures.report.models.ErrorException;
import java.util.Map;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the AutoRestReportService type.
 */
public final class AutoRestReportServiceImpl implements AutoRestReportService {
    /**
     * The proxy service used to perform REST calls.
     */
    private AutoRestReportServiceService service;

    /**
     * The HTTP pipeline to send requests through.
     */
    private HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /**
     * Initializes an instance of AutoRestReportService client.
     */
    public AutoRestReportServiceImpl() {
        this(RestProxy.createDefaultPipeline());
    }

    /**
     * Initializes an instance of AutoRestReportService client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     */
    public AutoRestReportServiceImpl(HttpPipeline httpPipeline) {
        this.httpPipeline = httpPipeline;
        this.service = RestProxy.create(AutoRestReportServiceService.class, this.httpPipeline);
    }

    /**
     * The interface defining all the services for AutoRestReportService to be
     * used by the proxy service to perform REST calls.
     */
    @Host("http://localhost:3000")
    @ServiceInterface(name = "AutoRestReportService")
    private interface AutoRestReportServiceService {
        @Get("report")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(ErrorException.class)
        Mono<SimpleResponse<Map<String, Integer>>> getReport(@QueryParam("qualifier") String qualifier);
    }

    /**
     * Get test coverage report.
     *
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the Map&lt;String, Integer&gt; object if successful.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Map<String, Integer> getReport() {
        return getReportAsync().block();
    }

    /**
     * Get test coverage report.
     *
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Map<String, Integer>>> getReportWithRestResponseAsync() {
        final String qualifier = null;
        return service.getReport(qualifier);
    }

    /**
     * Get test coverage report.
     *
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Map<String, Integer>> getReportAsync() {
        return getReportWithRestResponseAsync()
            .flatMap((SimpleResponse<Map<String, Integer>> res) -> {
                if (res.value() != null) {
                    return Mono.just(res.value());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Get test coverage report.
     *
     * @param qualifier If specified, qualifies the generated report further (e.g. '2.7' vs '3.5' in for Python). The only effect is, that generators that run all tests several times, can distinguish the generated reports.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws ErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the Map&lt;String, Integer&gt; object if successful.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Map<String, Integer> getReport(String qualifier) {
        return getReportAsync(qualifier).block();
    }

    /**
     * Get test coverage report.
     *
     * @param qualifier If specified, qualifies the generated report further (e.g. '2.7' vs '3.5' in for Python). The only effect is, that generators that run all tests several times, can distinguish the generated reports.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Map<String, Integer>>> getReportWithRestResponseAsync(String qualifier) {
        return service.getReport(qualifier);
    }

    /**
     * Get test coverage report.
     *
     * @param qualifier If specified, qualifies the generated report further (e.g. '2.7' vs '3.5' in for Python). The only effect is, that generators that run all tests several times, can distinguish the generated reports.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Map<String, Integer>> getReportAsync(String qualifier) {
        return getReportWithRestResponseAsync(qualifier)
            .flatMap((SimpleResponse<Map<String, Integer>> res) -> {
                if (res.value() != null) {
                    return Mono.just(res.value());
                } else {
                    return Mono.empty();
                }
            });
    }
}
