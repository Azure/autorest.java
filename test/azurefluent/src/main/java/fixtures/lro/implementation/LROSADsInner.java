/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.lro.implementation;

import com.google.common.reflect.TypeToken;
import com.microsoft.azure.v2.AzureProxy;
import com.microsoft.azure.v2.CloudException;
import com.microsoft.azure.v2.OperationStatus;
import com.microsoft.azure.v2.util.ServiceFutureUtil;
import com.microsoft.rest.v2.RestResponse;
import com.microsoft.rest.v2.ServiceCallback;
import com.microsoft.rest.v2.ServiceFuture;
import com.microsoft.rest.v2.Validator;
import com.microsoft.rest.v2.annotations.BodyParam;
import com.microsoft.rest.v2.annotations.DELETE;
import com.microsoft.rest.v2.annotations.ExpectedResponses;
import com.microsoft.rest.v2.annotations.HeaderParam;
import com.microsoft.rest.v2.annotations.Headers;
import com.microsoft.rest.v2.annotations.Host;
import com.microsoft.rest.v2.annotations.POST;
import com.microsoft.rest.v2.annotations.PUT;
import com.microsoft.rest.v2.annotations.UnexpectedResponseExceptionType;
import com.microsoft.rest.v2.http.HttpClient;
import java.io.IOException;
import rx.Observable;
import rx.Single;
import rx.functions.Func1;

/**
 * An instance of this class provides access to all the operations defined in
 * LROSADs.
 */
public class LROSADsInner {
    /** The RestProxy service to perform REST calls. */
    private LROSADsService service;
    /** The service client containing this operation class. */
    private AutoRestLongRunningOperationTestServiceImpl client;

    /**
     * Initializes an instance of LROSADsInner.
     *
     * @param client the instance of the service client containing this operation class.
     */
    public LROSADsInner(AutoRestLongRunningOperationTestServiceImpl client) {
        this.service = AzureProxy.create(LROSADsService.class, client);
        this.client = client;
    }

    /**
     * The interface defining all the services for LROSADs to be used by
     * RestProxy to perform REST calls.
     */
    @Host("http://localhost")
    interface LROSADsService {
        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPutNonRetry400" })
        @PUT("lro/nonretryerror/put/400")
        @ExpectedResponses({200, 201, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<ProductInner>> beginPutNonRetry400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs putNonRetry400" })
        @PUT("lro/nonretryerror/put/400")
        @ExpectedResponses({200, 201, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<Void, ProductInner>> putNonRetry400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPutNonRetry201Creating400" })
        @PUT("lro/nonretryerror/put/201/creating/400")
        @ExpectedResponses({200, 201, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<ProductInner>> beginPutNonRetry201Creating400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs putNonRetry201Creating400" })
        @PUT("lro/nonretryerror/put/201/creating/400")
        @ExpectedResponses({200, 201, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<Void, ProductInner>> putNonRetry201Creating400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPutNonRetry201Creating400InvalidJson" })
        @PUT("lro/nonretryerror/put/201/creating/400/invalidjson")
        @ExpectedResponses({200, 201, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<ProductInner>> beginPutNonRetry201Creating400InvalidJson(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs putNonRetry201Creating400InvalidJson" })
        @PUT("lro/nonretryerror/put/201/creating/400/invalidjson")
        @ExpectedResponses({200, 201, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<Void, ProductInner>> putNonRetry201Creating400InvalidJson(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPutAsyncRelativeRetry400" })
        @PUT("lro/nonretryerror/putasync/retry/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetry400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs putAsyncRelativeRetry400" })
        @PUT("lro/nonretryerror/putasync/retry/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPutAsyncRelativeRetry400HeadersInner, ProductInner>> putAsyncRelativeRetry400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginDeleteNonRetry400" })
        @DELETE("lro/nonretryerror/delete/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginDeleteNonRetry400(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs deleteNonRetry400" })
        @DELETE("lro/nonretryerror/delete/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsDeleteNonRetry400HeadersInner, Void>> deleteNonRetry400(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginDelete202NonRetry400" })
        @DELETE("lro/nonretryerror/delete/202/retry/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginDelete202NonRetry400(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs delete202NonRetry400" })
        @DELETE("lro/nonretryerror/delete/202/retry/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsDelete202NonRetry400HeadersInner, Void>> delete202NonRetry400(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginDeleteAsyncRelativeRetry400" })
        @DELETE("lro/nonretryerror/deleteasync/retry/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginDeleteAsyncRelativeRetry400(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs deleteAsyncRelativeRetry400" })
        @DELETE("lro/nonretryerror/deleteasync/retry/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsDeleteAsyncRelativeRetry400HeadersInner, Void>> deleteAsyncRelativeRetry400(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPostNonRetry400" })
        @POST("lro/nonretryerror/post/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginPostNonRetry400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs postNonRetry400" })
        @POST("lro/nonretryerror/post/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPostNonRetry400HeadersInner, Void>> postNonRetry400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPost202NonRetry400" })
        @POST("lro/nonretryerror/post/202/retry/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginPost202NonRetry400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs post202NonRetry400" })
        @POST("lro/nonretryerror/post/202/retry/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPost202NonRetry400HeadersInner, Void>> post202NonRetry400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPostAsyncRelativeRetry400" })
        @POST("lro/nonretryerror/postasync/retry/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginPostAsyncRelativeRetry400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs postAsyncRelativeRetry400" })
        @POST("lro/nonretryerror/postasync/retry/400")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPostAsyncRelativeRetry400HeadersInner, Void>> postAsyncRelativeRetry400(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPutError201NoProvisioningStatePayload" })
        @PUT("lro/error/put/201/noprovisioningstatepayload")
        @ExpectedResponses({200, 201, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<ProductInner>> beginPutError201NoProvisioningStatePayload(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs putError201NoProvisioningStatePayload" })
        @PUT("lro/error/put/201/noprovisioningstatepayload")
        @ExpectedResponses({200, 201, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<Void, ProductInner>> putError201NoProvisioningStatePayload(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPutAsyncRelativeRetryNoStatus" })
        @PUT("lro/error/putasync/retry/nostatus")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryNoStatus(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs putAsyncRelativeRetryNoStatus" })
        @PUT("lro/error/putasync/retry/nostatus")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPutAsyncRelativeRetryNoStatusHeadersInner, ProductInner>> putAsyncRelativeRetryNoStatus(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPutAsyncRelativeRetryNoStatusPayload" })
        @PUT("lro/error/putasync/retry/nostatuspayload")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryNoStatusPayload(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs putAsyncRelativeRetryNoStatusPayload" })
        @PUT("lro/error/putasync/retry/nostatuspayload")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPutAsyncRelativeRetryNoStatusPayloadHeadersInner, ProductInner>> putAsyncRelativeRetryNoStatusPayload(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginDelete204Succeeded" })
        @DELETE("lro/error/delete/204/nolocation")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginDelete204Succeeded(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs delete204Succeeded" })
        @DELETE("lro/error/delete/204/nolocation")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<Void, Void>> delete204Succeeded(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginDeleteAsyncRelativeRetryNoStatus" })
        @DELETE("lro/error/deleteasync/retry/nostatus")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginDeleteAsyncRelativeRetryNoStatus(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs deleteAsyncRelativeRetryNoStatus" })
        @DELETE("lro/error/deleteasync/retry/nostatus")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsDeleteAsyncRelativeRetryNoStatusHeadersInner, Void>> deleteAsyncRelativeRetryNoStatus(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPost202NoLocation" })
        @POST("lro/error/post/202/nolocation")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginPost202NoLocation(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs post202NoLocation" })
        @POST("lro/error/post/202/nolocation")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPost202NoLocationHeadersInner, Void>> post202NoLocation(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPostAsyncRelativeRetryNoPayload" })
        @POST("lro/error/postasync/retry/nopayload")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginPostAsyncRelativeRetryNoPayload(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs postAsyncRelativeRetryNoPayload" })
        @POST("lro/error/postasync/retry/nopayload")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPostAsyncRelativeRetryNoPayloadHeadersInner, Void>> postAsyncRelativeRetryNoPayload(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPut200InvalidJson" })
        @PUT("lro/error/put/200/invalidjson")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<ProductInner>> beginPut200InvalidJson(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs put200InvalidJson" })
        @PUT("lro/error/put/200/invalidjson")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<Void, ProductInner>> put200InvalidJson(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPutAsyncRelativeRetryInvalidHeader" })
        @PUT("lro/error/putasync/retry/invalidheader")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryInvalidHeader(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs putAsyncRelativeRetryInvalidHeader" })
        @PUT("lro/error/putasync/retry/invalidheader")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPutAsyncRelativeRetryInvalidHeaderHeadersInner, ProductInner>> putAsyncRelativeRetryInvalidHeader(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPutAsyncRelativeRetryInvalidJsonPolling" })
        @PUT("lro/error/putasync/retry/invalidjsonpolling")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryInvalidJsonPolling(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs putAsyncRelativeRetryInvalidJsonPolling" })
        @PUT("lro/error/putasync/retry/invalidjsonpolling")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPutAsyncRelativeRetryInvalidJsonPollingHeadersInner, ProductInner>> putAsyncRelativeRetryInvalidJsonPolling(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginDelete202RetryInvalidHeader" })
        @DELETE("lro/error/delete/202/retry/invalidheader")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginDelete202RetryInvalidHeader(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs delete202RetryInvalidHeader" })
        @DELETE("lro/error/delete/202/retry/invalidheader")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsDelete202RetryInvalidHeaderHeadersInner, Void>> delete202RetryInvalidHeader(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginDeleteAsyncRelativeRetryInvalidHeader" })
        @DELETE("lro/error/deleteasync/retry/invalidheader")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginDeleteAsyncRelativeRetryInvalidHeader(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs deleteAsyncRelativeRetryInvalidHeader" })
        @DELETE("lro/error/deleteasync/retry/invalidheader")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidHeaderHeadersInner, Void>> deleteAsyncRelativeRetryInvalidHeader(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginDeleteAsyncRelativeRetryInvalidJsonPolling" })
        @DELETE("lro/error/deleteasync/retry/invalidjsonpolling")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginDeleteAsyncRelativeRetryInvalidJsonPolling(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs deleteAsyncRelativeRetryInvalidJsonPolling" })
        @DELETE("lro/error/deleteasync/retry/invalidjsonpolling")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void>> deleteAsyncRelativeRetryInvalidJsonPolling(@HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPost202RetryInvalidHeader" })
        @POST("lro/error/post/202/retry/invalidheader")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginPost202RetryInvalidHeader(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs post202RetryInvalidHeader" })
        @POST("lro/error/post/202/retry/invalidheader")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPost202RetryInvalidHeaderHeadersInner, Void>> post202RetryInvalidHeader(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPostAsyncRelativeRetryInvalidHeader" })
        @POST("lro/error/postasync/retry/invalidheader")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginPostAsyncRelativeRetryInvalidHeader(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs postAsyncRelativeRetryInvalidHeader" })
        @POST("lro/error/postasync/retry/invalidheader")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPostAsyncRelativeRetryInvalidHeaderHeadersInner, Void>> postAsyncRelativeRetryInvalidHeader(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs beginPostAsyncRelativeRetryInvalidJsonPolling" })
        @POST("lro/error/postasync/retry/invalidjsonpolling")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Observable<OperationStatus<Void>> beginPostAsyncRelativeRetryInvalidJsonPolling(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

        @Headers({ "x-ms-logging-context: fixtures.lro.LROSADs postAsyncRelativeRetryInvalidJsonPolling" })
        @POST("lro/error/postasync/retry/invalidjsonpolling")
        @ExpectedResponses({200, 202, 204})
        @UnexpectedResponseExceptionType(CloudException.class)
        Single<RestResponse<LROSADsPostAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void>> postAsyncRelativeRetryInvalidJsonPolling(@BodyParam("application/json; charset=utf-8") ProductInner product, @HeaderParam("accept-language") String acceptLanguage);

    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutNonRetry400() {
        return beginPutNonRetry400Async().toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutNonRetry400Async(final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutNonRetry400Async(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutNonRetry400Async() {
        final ProductInner product = null;
        return service.beginPutNonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutNonRetry400(ProductInner product) {
        return beginPutNonRetry400Async(product).toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutNonRetry400Async(ProductInner product, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutNonRetry400Async(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutNonRetry400Async(ProductInner product) {
        Validator.validate(product);
        return service.beginPutNonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putNonRetry400() {
        return putNonRetry400Async().toBlocking().value();
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putNonRetry400Async(ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putNonRetry400Async(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<RestResponse<Void, ProductInner>> putNonRetry400WithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.putNonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<ProductInner> putNonRetry400Async() {
        return putNonRetry400WithRestResponseAsync()
            .map(new Func1<RestResponse<Void, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<Void, ProductInner> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putNonRetry400(ProductInner product) {
        return putNonRetry400Async(product).toBlocking().value();
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putNonRetry400Async(ProductInner product, ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putNonRetry400Async(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<RestResponse<Void, ProductInner>> putNonRetry400WithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.putNonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 400 to the initial request.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<ProductInner> putNonRetry400Async(ProductInner product) {
        return putNonRetry400WithRestResponseAsync(product)
            .map(new Func1<RestResponse<Void, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<Void, ProductInner> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutNonRetry201Creating400() {
        return beginPutNonRetry201Creating400Async().toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutNonRetry201Creating400Async(final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutNonRetry201Creating400Async(), serviceCallback);
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutNonRetry201Creating400Async() {
        final ProductInner product = null;
        return service.beginPutNonRetry201Creating400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutNonRetry201Creating400(ProductInner product) {
        return beginPutNonRetry201Creating400Async(product).toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutNonRetry201Creating400Async(ProductInner product, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutNonRetry201Creating400Async(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutNonRetry201Creating400Async(ProductInner product) {
        Validator.validate(product);
        return service.beginPutNonRetry201Creating400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putNonRetry201Creating400() {
        return putNonRetry201Creating400Async().toBlocking().value();
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putNonRetry201Creating400Async(ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putNonRetry201Creating400Async(), serviceCallback);
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<RestResponse<Void, ProductInner>> putNonRetry201Creating400WithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.putNonRetry201Creating400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<ProductInner> putNonRetry201Creating400Async() {
        return putNonRetry201Creating400WithRestResponseAsync()
            .map(new Func1<RestResponse<Void, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<Void, ProductInner> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putNonRetry201Creating400(ProductInner product) {
        return putNonRetry201Creating400Async(product).toBlocking().value();
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putNonRetry201Creating400Async(ProductInner product, ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putNonRetry201Creating400Async(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<RestResponse<Void, ProductInner>> putNonRetry201Creating400WithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.putNonRetry201Creating400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<ProductInner> putNonRetry201Creating400Async(ProductInner product) {
        return putNonRetry201Creating400WithRestResponseAsync(product)
            .map(new Func1<RestResponse<Void, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<Void, ProductInner> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutNonRetry201Creating400InvalidJson() {
        return beginPutNonRetry201Creating400InvalidJsonAsync().toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutNonRetry201Creating400InvalidJsonAsync(final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutNonRetry201Creating400InvalidJsonAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutNonRetry201Creating400InvalidJsonAsync() {
        final ProductInner product = null;
        return service.beginPutNonRetry201Creating400InvalidJson(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutNonRetry201Creating400InvalidJson(ProductInner product) {
        return beginPutNonRetry201Creating400InvalidJsonAsync(product).toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutNonRetry201Creating400InvalidJsonAsync(ProductInner product, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutNonRetry201Creating400InvalidJsonAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutNonRetry201Creating400InvalidJsonAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPutNonRetry201Creating400InvalidJson(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putNonRetry201Creating400InvalidJson() {
        return putNonRetry201Creating400InvalidJsonAsync().toBlocking().value();
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putNonRetry201Creating400InvalidJsonAsync(ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putNonRetry201Creating400InvalidJsonAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<RestResponse<Void, ProductInner>> putNonRetry201Creating400InvalidJsonWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.putNonRetry201Creating400InvalidJson(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<ProductInner> putNonRetry201Creating400InvalidJsonAsync() {
        return putNonRetry201Creating400InvalidJsonWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<Void, ProductInner> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putNonRetry201Creating400InvalidJson(ProductInner product) {
        return putNonRetry201Creating400InvalidJsonAsync(product).toBlocking().value();
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putNonRetry201Creating400InvalidJsonAsync(ProductInner product, ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putNonRetry201Creating400InvalidJsonAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<RestResponse<Void, ProductInner>> putNonRetry201Creating400InvalidJsonWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.putNonRetry201Creating400InvalidJson(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a Product with 'ProvisioningState' = 'Creating' and 201 response code.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<ProductInner> putNonRetry201Creating400InvalidJsonAsync(ProductInner product) {
        return putNonRetry201Creating400InvalidJsonWithRestResponseAsync(product)
            .map(new Func1<RestResponse<Void, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<Void, ProductInner> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutAsyncRelativeRetry400() {
        return beginPutAsyncRelativeRetry400Async().toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutAsyncRelativeRetry400Async(final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutAsyncRelativeRetry400Async(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetry400Async() {
        final ProductInner product = null;
        return service.beginPutAsyncRelativeRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutAsyncRelativeRetry400(ProductInner product) {
        return beginPutAsyncRelativeRetry400Async(product).toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutAsyncRelativeRetry400Async(ProductInner product, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutAsyncRelativeRetry400Async(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetry400Async(ProductInner product) {
        Validator.validate(product);
        return service.beginPutAsyncRelativeRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putAsyncRelativeRetry400() {
        return putAsyncRelativeRetry400Async().toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putAsyncRelativeRetry400Async(ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putAsyncRelativeRetry400Async(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetry400HeadersInner, ProductInner> object
     */
    public Single<RestResponse<LROSADsPutAsyncRelativeRetry400HeadersInner, ProductInner>> putAsyncRelativeRetry400WithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.putAsyncRelativeRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetry400HeadersInner, ProductInner> object
     */
    public Single<ProductInner> putAsyncRelativeRetry400Async() {
        return putAsyncRelativeRetry400WithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPutAsyncRelativeRetry400HeadersInner, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<LROSADsPutAsyncRelativeRetry400HeadersInner, ProductInner> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putAsyncRelativeRetry400(ProductInner product) {
        return putAsyncRelativeRetry400Async(product).toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putAsyncRelativeRetry400Async(ProductInner product, ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putAsyncRelativeRetry400Async(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetry400HeadersInner, ProductInner> object
     */
    public Single<RestResponse<LROSADsPutAsyncRelativeRetry400HeadersInner, ProductInner>> putAsyncRelativeRetry400WithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.putAsyncRelativeRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 with ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetry400HeadersInner, ProductInner> object
     */
    public Single<ProductInner> putAsyncRelativeRetry400Async(ProductInner product) {
        return putAsyncRelativeRetry400WithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPutAsyncRelativeRetry400HeadersInner, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<LROSADsPutAsyncRelativeRetry400HeadersInner, ProductInner> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running delete request, service returns a 400 with an error body.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDeleteNonRetry400() {
        beginDeleteNonRetry400Async().toBlocking().last();
    }

    /**
     * Long running delete request, service returns a 400 with an error body.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDeleteNonRetry400Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginDeleteNonRetry400Async(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 400 with an error body.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginDeleteNonRetry400Async() {
        return service.beginDeleteNonRetry400(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 400 with an error body.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void deleteNonRetry400() {
        deleteNonRetry400Async().toBlocking().value();
    }

    /**
     * Long running delete request, service returns a 400 with an error body.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteNonRetry400Async(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(deleteNonRetry400Async(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 400 with an error body.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDeleteNonRetry400HeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsDeleteNonRetry400HeadersInner, Void>> deleteNonRetry400WithRestResponseAsync() {
        return service.deleteNonRetry400(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 400 with an error body.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDeleteNonRetry400HeadersInner, Void> object
     */
    public Single<Void> deleteNonRetry400Async() {
        return deleteNonRetry400WithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsDeleteNonRetry400HeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsDeleteNonRetry400HeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running delete request, service returns a 202 with a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDelete202NonRetry400() {
        beginDelete202NonRetry400Async().toBlocking().last();
    }

    /**
     * Long running delete request, service returns a 202 with a location header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDelete202NonRetry400Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginDelete202NonRetry400Async(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 with a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginDelete202NonRetry400Async() {
        return service.beginDelete202NonRetry400(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 with a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void delete202NonRetry400() {
        delete202NonRetry400Async().toBlocking().value();
    }

    /**
     * Long running delete request, service returns a 202 with a location header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> delete202NonRetry400Async(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(delete202NonRetry400Async(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 with a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDelete202NonRetry400HeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsDelete202NonRetry400HeadersInner, Void>> delete202NonRetry400WithRestResponseAsync() {
        return service.delete202NonRetry400(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 with a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDelete202NonRetry400HeadersInner, Void> object
     */
    public Single<Void> delete202NonRetry400Async() {
        return delete202NonRetry400WithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsDelete202NonRetry400HeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsDelete202NonRetry400HeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDeleteAsyncRelativeRetry400() {
        beginDeleteAsyncRelativeRetry400Async().toBlocking().last();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDeleteAsyncRelativeRetry400Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginDeleteAsyncRelativeRetry400Async(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginDeleteAsyncRelativeRetry400Async() {
        return service.beginDeleteAsyncRelativeRetry400(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void deleteAsyncRelativeRetry400() {
        deleteAsyncRelativeRetry400Async().toBlocking().value();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsyncRelativeRetry400Async(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(deleteAsyncRelativeRetry400Async(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDeleteAsyncRelativeRetry400HeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsDeleteAsyncRelativeRetry400HeadersInner, Void>> deleteAsyncRelativeRetry400WithRestResponseAsync() {
        return service.deleteAsyncRelativeRetry400(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDeleteAsyncRelativeRetry400HeadersInner, Void> object
     */
    public Single<Void> deleteAsyncRelativeRetry400Async() {
        return deleteAsyncRelativeRetry400WithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsDeleteAsyncRelativeRetry400HeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsDeleteAsyncRelativeRetry400HeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPostNonRetry400() {
        beginPostNonRetry400Async().toBlocking().last().result();
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPostNonRetry400Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPostNonRetry400Async(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPostNonRetry400Async() {
        final ProductInner product = null;
        return service.beginPostNonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPostNonRetry400(ProductInner product) {
        beginPostNonRetry400Async(product).toBlocking().last();
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPostNonRetry400Async(ProductInner product, final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPostNonRetry400Async(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPostNonRetry400Async(ProductInner product) {
        Validator.validate(product);
        return service.beginPostNonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void postNonRetry400() {
        postNonRetry400Async().toBlocking().value();
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postNonRetry400Async(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(postNonRetry400Async(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostNonRetry400HeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPostNonRetry400HeadersInner, Void>> postNonRetry400WithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.postNonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostNonRetry400HeadersInner, Void> object
     */
    public Single<Void> postNonRetry400Async() {
        return postNonRetry400WithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPostNonRetry400HeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPostNonRetry400HeadersInner, Void> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void postNonRetry400(ProductInner product) {
        postNonRetry400Async(product).toBlocking().value();
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postNonRetry400Async(ProductInner product, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(postNonRetry400Async(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostNonRetry400HeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPostNonRetry400HeadersInner, Void>> postNonRetry400WithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.postNonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 400 with no error body.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostNonRetry400HeadersInner, Void> object
     */
    public Single<Void> postNonRetry400Async(ProductInner product) {
        return postNonRetry400WithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPostNonRetry400HeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPostNonRetry400HeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPost202NonRetry400() {
        beginPost202NonRetry400Async().toBlocking().last().result();
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPost202NonRetry400Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPost202NonRetry400Async(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPost202NonRetry400Async() {
        final ProductInner product = null;
        return service.beginPost202NonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPost202NonRetry400(ProductInner product) {
        beginPost202NonRetry400Async(product).toBlocking().last();
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPost202NonRetry400Async(ProductInner product, final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPost202NonRetry400Async(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPost202NonRetry400Async(ProductInner product) {
        Validator.validate(product);
        return service.beginPost202NonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void post202NonRetry400() {
        post202NonRetry400Async().toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> post202NonRetry400Async(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(post202NonRetry400Async(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202NonRetry400HeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPost202NonRetry400HeadersInner, Void>> post202NonRetry400WithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.post202NonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202NonRetry400HeadersInner, Void> object
     */
    public Single<Void> post202NonRetry400Async() {
        return post202NonRetry400WithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPost202NonRetry400HeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPost202NonRetry400HeadersInner, Void> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void post202NonRetry400(ProductInner product) {
        post202NonRetry400Async(product).toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> post202NonRetry400Async(ProductInner product, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(post202NonRetry400Async(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202NonRetry400HeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPost202NonRetry400HeadersInner, Void>> post202NonRetry400WithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.post202NonRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 with a location header.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202NonRetry400HeadersInner, Void> object
     */
    public Single<Void> post202NonRetry400Async(ProductInner product) {
        return post202NonRetry400WithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPost202NonRetry400HeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPost202NonRetry400HeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPostAsyncRelativeRetry400() {
        beginPostAsyncRelativeRetry400Async().toBlocking().last().result();
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPostAsyncRelativeRetry400Async(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPostAsyncRelativeRetry400Async(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPostAsyncRelativeRetry400Async() {
        final ProductInner product = null;
        return service.beginPostAsyncRelativeRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPostAsyncRelativeRetry400(ProductInner product) {
        beginPostAsyncRelativeRetry400Async(product).toBlocking().last();
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPostAsyncRelativeRetry400Async(ProductInner product, final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPostAsyncRelativeRetry400Async(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPostAsyncRelativeRetry400Async(ProductInner product) {
        Validator.validate(product);
        return service.beginPostAsyncRelativeRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void postAsyncRelativeRetry400() {
        postAsyncRelativeRetry400Async().toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postAsyncRelativeRetry400Async(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(postAsyncRelativeRetry400Async(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetry400HeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPostAsyncRelativeRetry400HeadersInner, Void>> postAsyncRelativeRetry400WithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.postAsyncRelativeRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetry400HeadersInner, Void> object
     */
    public Single<Void> postAsyncRelativeRetry400Async() {
        return postAsyncRelativeRetry400WithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPostAsyncRelativeRetry400HeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPostAsyncRelativeRetry400HeadersInner, Void> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void postAsyncRelativeRetry400(ProductInner product) {
        postAsyncRelativeRetry400Async(product).toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postAsyncRelativeRetry400Async(ProductInner product, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(postAsyncRelativeRetry400Async(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetry400HeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPostAsyncRelativeRetry400HeadersInner, Void>> postAsyncRelativeRetry400WithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.postAsyncRelativeRetry400(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetry400HeadersInner, Void> object
     */
    public Single<Void> postAsyncRelativeRetry400Async(ProductInner product) {
        return postAsyncRelativeRetry400WithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPostAsyncRelativeRetry400HeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPostAsyncRelativeRetry400HeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutError201NoProvisioningStatePayload() {
        return beginPutError201NoProvisioningStatePayloadAsync().toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutError201NoProvisioningStatePayloadAsync(final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutError201NoProvisioningStatePayloadAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutError201NoProvisioningStatePayloadAsync() {
        final ProductInner product = null;
        return service.beginPutError201NoProvisioningStatePayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutError201NoProvisioningStatePayload(ProductInner product) {
        return beginPutError201NoProvisioningStatePayloadAsync(product).toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutError201NoProvisioningStatePayloadAsync(ProductInner product, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutError201NoProvisioningStatePayloadAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutError201NoProvisioningStatePayloadAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPutError201NoProvisioningStatePayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putError201NoProvisioningStatePayload() {
        return putError201NoProvisioningStatePayloadAsync().toBlocking().value();
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putError201NoProvisioningStatePayloadAsync(ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putError201NoProvisioningStatePayloadAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<RestResponse<Void, ProductInner>> putError201NoProvisioningStatePayloadWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.putError201NoProvisioningStatePayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<ProductInner> putError201NoProvisioningStatePayloadAsync() {
        return putError201NoProvisioningStatePayloadWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<Void, ProductInner> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putError201NoProvisioningStatePayload(ProductInner product) {
        return putError201NoProvisioningStatePayloadAsync(product).toBlocking().value();
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putError201NoProvisioningStatePayloadAsync(ProductInner product, ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putError201NoProvisioningStatePayloadAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<RestResponse<Void, ProductInner>> putError201NoProvisioningStatePayloadWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.putError201NoProvisioningStatePayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 201 to the initial request with no payload.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<ProductInner> putError201NoProvisioningStatePayloadAsync(ProductInner product) {
        return putError201NoProvisioningStatePayloadWithRestResponseAsync(product)
            .map(new Func1<RestResponse<Void, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<Void, ProductInner> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutAsyncRelativeRetryNoStatus() {
        return beginPutAsyncRelativeRetryNoStatusAsync().toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutAsyncRelativeRetryNoStatusAsync(final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutAsyncRelativeRetryNoStatusAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryNoStatusAsync() {
        final ProductInner product = null;
        return service.beginPutAsyncRelativeRetryNoStatus(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutAsyncRelativeRetryNoStatus(ProductInner product) {
        return beginPutAsyncRelativeRetryNoStatusAsync(product).toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutAsyncRelativeRetryNoStatusAsync(ProductInner product, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutAsyncRelativeRetryNoStatusAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryNoStatusAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPutAsyncRelativeRetryNoStatus(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putAsyncRelativeRetryNoStatus() {
        return putAsyncRelativeRetryNoStatusAsync().toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putAsyncRelativeRetryNoStatusAsync(ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putAsyncRelativeRetryNoStatusAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryNoStatusHeadersInner, ProductInner> object
     */
    public Single<RestResponse<LROSADsPutAsyncRelativeRetryNoStatusHeadersInner, ProductInner>> putAsyncRelativeRetryNoStatusWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.putAsyncRelativeRetryNoStatus(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryNoStatusHeadersInner, ProductInner> object
     */
    public Single<ProductInner> putAsyncRelativeRetryNoStatusAsync() {
        return putAsyncRelativeRetryNoStatusWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPutAsyncRelativeRetryNoStatusHeadersInner, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<LROSADsPutAsyncRelativeRetryNoStatusHeadersInner, ProductInner> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putAsyncRelativeRetryNoStatus(ProductInner product) {
        return putAsyncRelativeRetryNoStatusAsync(product).toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putAsyncRelativeRetryNoStatusAsync(ProductInner product, ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putAsyncRelativeRetryNoStatusAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryNoStatusHeadersInner, ProductInner> object
     */
    public Single<RestResponse<LROSADsPutAsyncRelativeRetryNoStatusHeadersInner, ProductInner>> putAsyncRelativeRetryNoStatusWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.putAsyncRelativeRetryNoStatus(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryNoStatusHeadersInner, ProductInner> object
     */
    public Single<ProductInner> putAsyncRelativeRetryNoStatusAsync(ProductInner product) {
        return putAsyncRelativeRetryNoStatusWithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPutAsyncRelativeRetryNoStatusHeadersInner, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<LROSADsPutAsyncRelativeRetryNoStatusHeadersInner, ProductInner> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutAsyncRelativeRetryNoStatusPayload() {
        return beginPutAsyncRelativeRetryNoStatusPayloadAsync().toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutAsyncRelativeRetryNoStatusPayloadAsync(final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutAsyncRelativeRetryNoStatusPayloadAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryNoStatusPayloadAsync() {
        final ProductInner product = null;
        return service.beginPutAsyncRelativeRetryNoStatusPayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutAsyncRelativeRetryNoStatusPayload(ProductInner product) {
        return beginPutAsyncRelativeRetryNoStatusPayloadAsync(product).toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutAsyncRelativeRetryNoStatusPayloadAsync(ProductInner product, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutAsyncRelativeRetryNoStatusPayloadAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryNoStatusPayloadAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPutAsyncRelativeRetryNoStatusPayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putAsyncRelativeRetryNoStatusPayload() {
        return putAsyncRelativeRetryNoStatusPayloadAsync().toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putAsyncRelativeRetryNoStatusPayloadAsync(ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putAsyncRelativeRetryNoStatusPayloadAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryNoStatusPayloadHeadersInner, ProductInner> object
     */
    public Single<RestResponse<LROSADsPutAsyncRelativeRetryNoStatusPayloadHeadersInner, ProductInner>> putAsyncRelativeRetryNoStatusPayloadWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.putAsyncRelativeRetryNoStatusPayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryNoStatusPayloadHeadersInner, ProductInner> object
     */
    public Single<ProductInner> putAsyncRelativeRetryNoStatusPayloadAsync() {
        return putAsyncRelativeRetryNoStatusPayloadWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPutAsyncRelativeRetryNoStatusPayloadHeadersInner, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<LROSADsPutAsyncRelativeRetryNoStatusPayloadHeadersInner, ProductInner> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putAsyncRelativeRetryNoStatusPayload(ProductInner product) {
        return putAsyncRelativeRetryNoStatusPayloadAsync(product).toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putAsyncRelativeRetryNoStatusPayloadAsync(ProductInner product, ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putAsyncRelativeRetryNoStatusPayloadAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryNoStatusPayloadHeadersInner, ProductInner> object
     */
    public Single<RestResponse<LROSADsPutAsyncRelativeRetryNoStatusPayloadHeadersInner, ProductInner>> putAsyncRelativeRetryNoStatusPayloadWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.putAsyncRelativeRetryNoStatusPayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryNoStatusPayloadHeadersInner, ProductInner> object
     */
    public Single<ProductInner> putAsyncRelativeRetryNoStatusPayloadAsync(ProductInner product) {
        return putAsyncRelativeRetryNoStatusPayloadWithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPutAsyncRelativeRetryNoStatusPayloadHeadersInner, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<LROSADsPutAsyncRelativeRetryNoStatusPayloadHeadersInner, ProductInner> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running delete request, service returns a 204 to the initial request, indicating success.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDelete204Succeeded() {
        beginDelete204SucceededAsync().toBlocking().last();
    }

    /**
     * Long running delete request, service returns a 204 to the initial request, indicating success.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDelete204SucceededAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginDelete204SucceededAsync(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 204 to the initial request, indicating success.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginDelete204SucceededAsync() {
        return service.beginDelete204Succeeded(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 204 to the initial request, indicating success.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void delete204Succeeded() {
        delete204SucceededAsync().toBlocking().value();
    }

    /**
     * Long running delete request, service returns a 204 to the initial request, indicating success.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> delete204SucceededAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(delete204SucceededAsync(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 204 to the initial request, indicating success.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<RestResponse<Void, Void>> delete204SucceededWithRestResponseAsync() {
        return service.delete204Succeeded(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 204 to the initial request, indicating success.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, Void> object
     */
    public Single<Void> delete204SucceededAsync() {
        return delete204SucceededWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, Void>, Void>() { public Void call(RestResponse<Void, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDeleteAsyncRelativeRetryNoStatus() {
        beginDeleteAsyncRelativeRetryNoStatusAsync().toBlocking().last();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDeleteAsyncRelativeRetryNoStatusAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginDeleteAsyncRelativeRetryNoStatusAsync(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginDeleteAsyncRelativeRetryNoStatusAsync() {
        return service.beginDeleteAsyncRelativeRetryNoStatus(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void deleteAsyncRelativeRetryNoStatus() {
        deleteAsyncRelativeRetryNoStatusAsync().toBlocking().value();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsyncRelativeRetryNoStatusAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(deleteAsyncRelativeRetryNoStatusAsync(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDeleteAsyncRelativeRetryNoStatusHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsDeleteAsyncRelativeRetryNoStatusHeadersInner, Void>> deleteAsyncRelativeRetryNoStatusWithRestResponseAsync() {
        return service.deleteAsyncRelativeRetryNoStatus(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDeleteAsyncRelativeRetryNoStatusHeadersInner, Void> object
     */
    public Single<Void> deleteAsyncRelativeRetryNoStatusAsync() {
        return deleteAsyncRelativeRetryNoStatusWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsDeleteAsyncRelativeRetryNoStatusHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsDeleteAsyncRelativeRetryNoStatusHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPost202NoLocation() {
        beginPost202NoLocationAsync().toBlocking().last().result();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPost202NoLocationAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPost202NoLocationAsync(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPost202NoLocationAsync() {
        final ProductInner product = null;
        return service.beginPost202NoLocation(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPost202NoLocation(ProductInner product) {
        beginPost202NoLocationAsync(product).toBlocking().last();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPost202NoLocationAsync(ProductInner product, final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPost202NoLocationAsync(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPost202NoLocationAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPost202NoLocation(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void post202NoLocation() {
        post202NoLocationAsync().toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> post202NoLocationAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(post202NoLocationAsync(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202NoLocationHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPost202NoLocationHeadersInner, Void>> post202NoLocationWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.post202NoLocation(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202NoLocationHeadersInner, Void> object
     */
    public Single<Void> post202NoLocationAsync() {
        return post202NoLocationWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPost202NoLocationHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPost202NoLocationHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void post202NoLocation(ProductInner product) {
        post202NoLocationAsync(product).toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> post202NoLocationAsync(ProductInner product, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(post202NoLocationAsync(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202NoLocationHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPost202NoLocationHeadersInner, Void>> post202NoLocationWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.post202NoLocation(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, without a location header.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202NoLocationHeadersInner, Void> object
     */
    public Single<Void> post202NoLocationAsync(ProductInner product) {
        return post202NoLocationWithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPost202NoLocationHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPost202NoLocationHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPostAsyncRelativeRetryNoPayload() {
        beginPostAsyncRelativeRetryNoPayloadAsync().toBlocking().last().result();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPostAsyncRelativeRetryNoPayloadAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPostAsyncRelativeRetryNoPayloadAsync(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPostAsyncRelativeRetryNoPayloadAsync() {
        final ProductInner product = null;
        return service.beginPostAsyncRelativeRetryNoPayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPostAsyncRelativeRetryNoPayload(ProductInner product) {
        beginPostAsyncRelativeRetryNoPayloadAsync(product).toBlocking().last();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPostAsyncRelativeRetryNoPayloadAsync(ProductInner product, final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPostAsyncRelativeRetryNoPayloadAsync(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPostAsyncRelativeRetryNoPayloadAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPostAsyncRelativeRetryNoPayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void postAsyncRelativeRetryNoPayload() {
        postAsyncRelativeRetryNoPayloadAsync().toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postAsyncRelativeRetryNoPayloadAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(postAsyncRelativeRetryNoPayloadAsync(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryNoPayloadHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPostAsyncRelativeRetryNoPayloadHeadersInner, Void>> postAsyncRelativeRetryNoPayloadWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.postAsyncRelativeRetryNoPayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryNoPayloadHeadersInner, Void> object
     */
    public Single<Void> postAsyncRelativeRetryNoPayloadAsync() {
        return postAsyncRelativeRetryNoPayloadWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPostAsyncRelativeRetryNoPayloadHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPostAsyncRelativeRetryNoPayloadHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void postAsyncRelativeRetryNoPayload(ProductInner product) {
        postAsyncRelativeRetryNoPayloadAsync(product).toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postAsyncRelativeRetryNoPayloadAsync(ProductInner product, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(postAsyncRelativeRetryNoPayloadAsync(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryNoPayloadHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPostAsyncRelativeRetryNoPayloadHeadersInner, Void>> postAsyncRelativeRetryNoPayloadWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.postAsyncRelativeRetryNoPayload(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryNoPayloadHeadersInner, Void> object
     */
    public Single<Void> postAsyncRelativeRetryNoPayloadAsync(ProductInner product) {
        return postAsyncRelativeRetryNoPayloadWithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPostAsyncRelativeRetryNoPayloadHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPostAsyncRelativeRetryNoPayloadHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPut200InvalidJson() {
        return beginPut200InvalidJsonAsync().toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPut200InvalidJsonAsync(final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPut200InvalidJsonAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPut200InvalidJsonAsync() {
        final ProductInner product = null;
        return service.beginPut200InvalidJson(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPut200InvalidJson(ProductInner product) {
        return beginPut200InvalidJsonAsync(product).toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPut200InvalidJsonAsync(ProductInner product, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPut200InvalidJsonAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPut200InvalidJsonAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPut200InvalidJson(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner put200InvalidJson() {
        return put200InvalidJsonAsync().toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> put200InvalidJsonAsync(ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(put200InvalidJsonAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<RestResponse<Void, ProductInner>> put200InvalidJsonWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.put200InvalidJson(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<ProductInner> put200InvalidJsonAsync() {
        return put200InvalidJsonWithRestResponseAsync()
            .map(new Func1<RestResponse<Void, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<Void, ProductInner> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner put200InvalidJson(ProductInner product) {
        return put200InvalidJsonAsync(product).toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> put200InvalidJsonAsync(ProductInner product, ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(put200InvalidJsonAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<RestResponse<Void, ProductInner>> put200InvalidJsonWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.put200InvalidJson(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that is not a valid json.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<Void, ProductInner> object
     */
    public Single<ProductInner> put200InvalidJsonAsync(ProductInner product) {
        return put200InvalidJsonWithRestResponseAsync(product)
            .map(new Func1<RestResponse<Void, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<Void, ProductInner> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutAsyncRelativeRetryInvalidHeader() {
        return beginPutAsyncRelativeRetryInvalidHeaderAsync().toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutAsyncRelativeRetryInvalidHeaderAsync(final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutAsyncRelativeRetryInvalidHeaderAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryInvalidHeaderAsync() {
        final ProductInner product = null;
        return service.beginPutAsyncRelativeRetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutAsyncRelativeRetryInvalidHeader(ProductInner product) {
        return beginPutAsyncRelativeRetryInvalidHeaderAsync(product).toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutAsyncRelativeRetryInvalidHeaderAsync(ProductInner product, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutAsyncRelativeRetryInvalidHeaderAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryInvalidHeaderAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPutAsyncRelativeRetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putAsyncRelativeRetryInvalidHeader() {
        return putAsyncRelativeRetryInvalidHeaderAsync().toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putAsyncRelativeRetryInvalidHeaderAsync(ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putAsyncRelativeRetryInvalidHeaderAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryInvalidHeaderHeadersInner, ProductInner> object
     */
    public Single<RestResponse<LROSADsPutAsyncRelativeRetryInvalidHeaderHeadersInner, ProductInner>> putAsyncRelativeRetryInvalidHeaderWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.putAsyncRelativeRetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryInvalidHeaderHeadersInner, ProductInner> object
     */
    public Single<ProductInner> putAsyncRelativeRetryInvalidHeaderAsync() {
        return putAsyncRelativeRetryInvalidHeaderWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPutAsyncRelativeRetryInvalidHeaderHeadersInner, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<LROSADsPutAsyncRelativeRetryInvalidHeaderHeadersInner, ProductInner> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putAsyncRelativeRetryInvalidHeader(ProductInner product) {
        return putAsyncRelativeRetryInvalidHeaderAsync(product).toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putAsyncRelativeRetryInvalidHeaderAsync(ProductInner product, ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putAsyncRelativeRetryInvalidHeaderAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryInvalidHeaderHeadersInner, ProductInner> object
     */
    public Single<RestResponse<LROSADsPutAsyncRelativeRetryInvalidHeaderHeadersInner, ProductInner>> putAsyncRelativeRetryInvalidHeaderWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.putAsyncRelativeRetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryInvalidHeaderHeadersInner, ProductInner> object
     */
    public Single<ProductInner> putAsyncRelativeRetryInvalidHeaderAsync(ProductInner product) {
        return putAsyncRelativeRetryInvalidHeaderWithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPutAsyncRelativeRetryInvalidHeaderHeadersInner, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<LROSADsPutAsyncRelativeRetryInvalidHeaderHeadersInner, ProductInner> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutAsyncRelativeRetryInvalidJsonPolling() {
        return beginPutAsyncRelativeRetryInvalidJsonPollingAsync().toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutAsyncRelativeRetryInvalidJsonPollingAsync(final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutAsyncRelativeRetryInvalidJsonPollingAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryInvalidJsonPollingAsync() {
        final ProductInner product = null;
        return service.beginPutAsyncRelativeRetryInvalidJsonPolling(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner beginPutAsyncRelativeRetryInvalidJsonPolling(ProductInner product) {
        return beginPutAsyncRelativeRetryInvalidJsonPollingAsync(product).toBlocking().last().result();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> beginPutAsyncRelativeRetryInvalidJsonPollingAsync(ProductInner product, final ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPutAsyncRelativeRetryInvalidJsonPollingAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<ProductInner>> beginPutAsyncRelativeRetryInvalidJsonPollingAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPutAsyncRelativeRetryInvalidJsonPolling(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putAsyncRelativeRetryInvalidJsonPolling() {
        return putAsyncRelativeRetryInvalidJsonPollingAsync().toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putAsyncRelativeRetryInvalidJsonPollingAsync(ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putAsyncRelativeRetryInvalidJsonPollingAsync(), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryInvalidJsonPollingHeadersInner, ProductInner> object
     */
    public Single<RestResponse<LROSADsPutAsyncRelativeRetryInvalidJsonPollingHeadersInner, ProductInner>> putAsyncRelativeRetryInvalidJsonPollingWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.putAsyncRelativeRetryInvalidJsonPolling(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryInvalidJsonPollingHeadersInner, ProductInner> object
     */
    public Single<ProductInner> putAsyncRelativeRetryInvalidJsonPollingAsync() {
        return putAsyncRelativeRetryInvalidJsonPollingWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPutAsyncRelativeRetryInvalidJsonPollingHeadersInner, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<LROSADsPutAsyncRelativeRetryInvalidJsonPollingHeadersInner, ProductInner> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the ProductInner object if successful.
     */
    public ProductInner putAsyncRelativeRetryInvalidJsonPolling(ProductInner product) {
        return putAsyncRelativeRetryInvalidJsonPollingAsync(product).toBlocking().value();
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<ProductInner> putAsyncRelativeRetryInvalidJsonPollingAsync(ProductInner product, ServiceCallback<ProductInner> serviceCallback) {
        return ServiceFuture.fromBody(putAsyncRelativeRetryInvalidJsonPollingAsync(product), serviceCallback);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryInvalidJsonPollingHeadersInner, ProductInner> object
     */
    public Single<RestResponse<LROSADsPutAsyncRelativeRetryInvalidJsonPollingHeadersInner, ProductInner>> putAsyncRelativeRetryInvalidJsonPollingWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.putAsyncRelativeRetryInvalidJsonPolling(product, this.client.acceptLanguage());
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPutAsyncRelativeRetryInvalidJsonPollingHeadersInner, ProductInner> object
     */
    public Single<ProductInner> putAsyncRelativeRetryInvalidJsonPollingAsync(ProductInner product) {
        return putAsyncRelativeRetryInvalidJsonPollingWithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPutAsyncRelativeRetryInvalidJsonPollingHeadersInner, ProductInner>, ProductInner>() { public ProductInner call(RestResponse<LROSADsPutAsyncRelativeRetryInvalidJsonPollingHeadersInner, ProductInner> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running delete request, service returns a 202 to the initial request receing a reponse with an invalid 'Location' and 'Retry-After' headers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDelete202RetryInvalidHeader() {
        beginDelete202RetryInvalidHeaderAsync().toBlocking().last();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request receing a reponse with an invalid 'Location' and 'Retry-After' headers.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDelete202RetryInvalidHeaderAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginDelete202RetryInvalidHeaderAsync(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request receing a reponse with an invalid 'Location' and 'Retry-After' headers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginDelete202RetryInvalidHeaderAsync() {
        return service.beginDelete202RetryInvalidHeader(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 to the initial request receing a reponse with an invalid 'Location' and 'Retry-After' headers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void delete202RetryInvalidHeader() {
        delete202RetryInvalidHeaderAsync().toBlocking().value();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request receing a reponse with an invalid 'Location' and 'Retry-After' headers.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> delete202RetryInvalidHeaderAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(delete202RetryInvalidHeaderAsync(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request receing a reponse with an invalid 'Location' and 'Retry-After' headers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDelete202RetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsDelete202RetryInvalidHeaderHeadersInner, Void>> delete202RetryInvalidHeaderWithRestResponseAsync() {
        return service.delete202RetryInvalidHeader(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 to the initial request receing a reponse with an invalid 'Location' and 'Retry-After' headers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDelete202RetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<Void> delete202RetryInvalidHeaderAsync() {
        return delete202RetryInvalidHeaderWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsDelete202RetryInvalidHeaderHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsDelete202RetryInvalidHeaderHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running delete request, service returns a 202 to the initial request. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDeleteAsyncRelativeRetryInvalidHeader() {
        beginDeleteAsyncRelativeRetryInvalidHeaderAsync().toBlocking().last();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDeleteAsyncRelativeRetryInvalidHeaderAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginDeleteAsyncRelativeRetryInvalidHeaderAsync(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginDeleteAsyncRelativeRetryInvalidHeaderAsync() {
        return service.beginDeleteAsyncRelativeRetryInvalidHeader(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void deleteAsyncRelativeRetryInvalidHeader() {
        deleteAsyncRelativeRetryInvalidHeaderAsync().toBlocking().value();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsyncRelativeRetryInvalidHeaderAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(deleteAsyncRelativeRetryInvalidHeaderAsync(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidHeaderHeadersInner, Void>> deleteAsyncRelativeRetryInvalidHeaderWithRestResponseAsync() {
        return service.deleteAsyncRelativeRetryInvalidHeader(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<Void> deleteAsyncRelativeRetryInvalidHeaderAsync() {
        return deleteAsyncRelativeRetryInvalidHeaderWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidHeaderHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidHeaderHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginDeleteAsyncRelativeRetryInvalidJsonPolling() {
        beginDeleteAsyncRelativeRetryInvalidJsonPollingAsync().toBlocking().last();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginDeleteAsyncRelativeRetryInvalidJsonPollingAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginDeleteAsyncRelativeRetryInvalidJsonPollingAsync(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginDeleteAsyncRelativeRetryInvalidJsonPollingAsync() {
        return service.beginDeleteAsyncRelativeRetryInvalidJsonPolling(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void deleteAsyncRelativeRetryInvalidJsonPolling() {
        deleteAsyncRelativeRetryInvalidJsonPollingAsync().toBlocking().value();
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deleteAsyncRelativeRetryInvalidJsonPollingAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(deleteAsyncRelativeRetryInvalidJsonPollingAsync(), serviceCallback);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void>> deleteAsyncRelativeRetryInvalidJsonPollingWithRestResponseAsync() {
        return service.deleteAsyncRelativeRetryInvalidJsonPolling(this.client.acceptLanguage());
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void> object
     */
    public Single<Void> deleteAsyncRelativeRetryInvalidJsonPollingAsync() {
        return deleteAsyncRelativeRetryInvalidJsonPollingWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsDeleteAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPost202RetryInvalidHeader() {
        beginPost202RetryInvalidHeaderAsync().toBlocking().last().result();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPost202RetryInvalidHeaderAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPost202RetryInvalidHeaderAsync(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPost202RetryInvalidHeaderAsync() {
        final ProductInner product = null;
        return service.beginPost202RetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPost202RetryInvalidHeader(ProductInner product) {
        beginPost202RetryInvalidHeaderAsync(product).toBlocking().last();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPost202RetryInvalidHeaderAsync(ProductInner product, final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPost202RetryInvalidHeaderAsync(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPost202RetryInvalidHeaderAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPost202RetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void post202RetryInvalidHeader() {
        post202RetryInvalidHeaderAsync().toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> post202RetryInvalidHeaderAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(post202RetryInvalidHeaderAsync(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202RetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPost202RetryInvalidHeaderHeadersInner, Void>> post202RetryInvalidHeaderWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.post202RetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202RetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<Void> post202RetryInvalidHeaderAsync() {
        return post202RetryInvalidHeaderWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPost202RetryInvalidHeaderHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPost202RetryInvalidHeaderHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void post202RetryInvalidHeader(ProductInner product) {
        post202RetryInvalidHeaderAsync(product).toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> post202RetryInvalidHeaderAsync(ProductInner product, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(post202RetryInvalidHeaderAsync(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202RetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPost202RetryInvalidHeaderHeadersInner, Void>> post202RetryInvalidHeaderWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.post202RetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with invalid 'Location' and 'Retry-After' headers.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPost202RetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<Void> post202RetryInvalidHeaderAsync(ProductInner product) {
        return post202RetryInvalidHeaderWithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPost202RetryInvalidHeaderHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPost202RetryInvalidHeaderHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPostAsyncRelativeRetryInvalidHeader() {
        beginPostAsyncRelativeRetryInvalidHeaderAsync().toBlocking().last().result();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPostAsyncRelativeRetryInvalidHeaderAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPostAsyncRelativeRetryInvalidHeaderAsync(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPostAsyncRelativeRetryInvalidHeaderAsync() {
        final ProductInner product = null;
        return service.beginPostAsyncRelativeRetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPostAsyncRelativeRetryInvalidHeader(ProductInner product) {
        beginPostAsyncRelativeRetryInvalidHeaderAsync(product).toBlocking().last();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPostAsyncRelativeRetryInvalidHeaderAsync(ProductInner product, final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPostAsyncRelativeRetryInvalidHeaderAsync(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPostAsyncRelativeRetryInvalidHeaderAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPostAsyncRelativeRetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void postAsyncRelativeRetryInvalidHeader() {
        postAsyncRelativeRetryInvalidHeaderAsync().toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postAsyncRelativeRetryInvalidHeaderAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(postAsyncRelativeRetryInvalidHeaderAsync(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPostAsyncRelativeRetryInvalidHeaderHeadersInner, Void>> postAsyncRelativeRetryInvalidHeaderWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.postAsyncRelativeRetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<Void> postAsyncRelativeRetryInvalidHeaderAsync() {
        return postAsyncRelativeRetryInvalidHeaderWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPostAsyncRelativeRetryInvalidHeaderHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPostAsyncRelativeRetryInvalidHeaderHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void postAsyncRelativeRetryInvalidHeader(ProductInner product) {
        postAsyncRelativeRetryInvalidHeaderAsync(product).toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postAsyncRelativeRetryInvalidHeaderAsync(ProductInner product, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(postAsyncRelativeRetryInvalidHeaderAsync(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPostAsyncRelativeRetryInvalidHeaderHeadersInner, Void>> postAsyncRelativeRetryInvalidHeaderWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.postAsyncRelativeRetryInvalidHeader(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. The endpoint indicated in the Azure-AsyncOperation header is invalid.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryInvalidHeaderHeadersInner, Void> object
     */
    public Single<Void> postAsyncRelativeRetryInvalidHeaderAsync(ProductInner product) {
        return postAsyncRelativeRetryInvalidHeaderWithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPostAsyncRelativeRetryInvalidHeaderHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPostAsyncRelativeRetryInvalidHeaderHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPostAsyncRelativeRetryInvalidJsonPolling() {
        beginPostAsyncRelativeRetryInvalidJsonPollingAsync().toBlocking().last().result();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPostAsyncRelativeRetryInvalidJsonPollingAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPostAsyncRelativeRetryInvalidJsonPollingAsync(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPostAsyncRelativeRetryInvalidJsonPollingAsync() {
        final ProductInner product = null;
        return service.beginPostAsyncRelativeRetryInvalidJsonPolling(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void beginPostAsyncRelativeRetryInvalidJsonPolling(ProductInner product) {
        beginPostAsyncRelativeRetryInvalidJsonPollingAsync(product).toBlocking().last();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> beginPostAsyncRelativeRetryInvalidJsonPollingAsync(ProductInner product, final ServiceCallback<Void> serviceCallback) {
        return ServiceFutureUtil.fromLRO(beginPostAsyncRelativeRetryInvalidJsonPollingAsync(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable for the request
     */
    public Observable<OperationStatus<Void>> beginPostAsyncRelativeRetryInvalidJsonPollingAsync(ProductInner product) {
        Validator.validate(product);
        return service.beginPostAsyncRelativeRetryInvalidJsonPolling(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void postAsyncRelativeRetryInvalidJsonPolling() {
        postAsyncRelativeRetryInvalidJsonPollingAsync().toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postAsyncRelativeRetryInvalidJsonPollingAsync(ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(postAsyncRelativeRetryInvalidJsonPollingAsync(), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPostAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void>> postAsyncRelativeRetryInvalidJsonPollingWithRestResponseAsync() {
        final ProductInner product = null;
        Validator.validate(product);
        return service.postAsyncRelativeRetryInvalidJsonPolling(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void> object
     */
    public Single<Void> postAsyncRelativeRetryInvalidJsonPollingAsync() {
        return postAsyncRelativeRetryInvalidJsonPollingWithRestResponseAsync()
            .map(new Func1<RestResponse<LROSADsPostAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPostAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws CloudException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the void object if successful.
     */
    public void postAsyncRelativeRetryInvalidJsonPolling(ProductInner product) {
        postAsyncRelativeRetryInvalidJsonPollingAsync(product).toBlocking().value();
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> postAsyncRelativeRetryInvalidJsonPollingAsync(ProductInner product, ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromBody(postAsyncRelativeRetryInvalidJsonPollingAsync(product), serviceCallback);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void> object
     */
    public Single<RestResponse<LROSADsPostAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void>> postAsyncRelativeRetryInvalidJsonPollingWithRestResponseAsync(ProductInner product) {
        Validator.validate(product);
        return service.postAsyncRelativeRetryInvalidJsonPolling(product, this.client.acceptLanguage());
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=Creating. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status.
     *
     * @param product Product to put
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return a {@link Single} emitting the RestResponse<LROSADsPostAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void> object
     */
    public Single<Void> postAsyncRelativeRetryInvalidJsonPollingAsync(ProductInner product) {
        return postAsyncRelativeRetryInvalidJsonPollingWithRestResponseAsync(product)
            .map(new Func1<RestResponse<LROSADsPostAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void>, Void>() { public Void call(RestResponse<LROSADsPostAsyncRelativeRetryInvalidJsonPollingHeadersInner, Void> restResponse) { return restResponse.body(); } });
        }


}
